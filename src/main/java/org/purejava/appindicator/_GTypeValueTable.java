// Generated by jextract

package org.purejava.appindicator;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct _GTypeValueTable {
 *     GTypeValueInitFunc value_init;
 *     GTypeValueFreeFunc value_free;
 *     GTypeValueCopyFunc value_copy;
 *     GTypeValuePeekPointerFunc value_peek_pointer;
 *     const gchar *collect_format;
 *     GTypeValueCollectFunc collect_value;
 *     const gchar *lcopy_format;
 *     GTypeValueLCopyFunc lcopy_value;
 * }
 * }
 */
public class _GTypeValueTable {

    _GTypeValueTable() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        app_indicator_h.C_POINTER.withName("value_init"),
        app_indicator_h.C_POINTER.withName("value_free"),
        app_indicator_h.C_POINTER.withName("value_copy"),
        app_indicator_h.C_POINTER.withName("value_peek_pointer"),
        app_indicator_h.C_POINTER.withName("collect_format"),
        app_indicator_h.C_POINTER.withName("collect_value"),
        app_indicator_h.C_POINTER.withName("lcopy_format"),
        app_indicator_h.C_POINTER.withName("lcopy_value")
    ).withName("_GTypeValueTable");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final AddressLayout value_init$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("value_init"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GTypeValueInitFunc value_init
     * }
     */
    public static final AddressLayout value_init$layout() {
        return value_init$LAYOUT;
    }

    private static final long value_init$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GTypeValueInitFunc value_init
     * }
     */
    public static final long value_init$offset() {
        return value_init$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GTypeValueInitFunc value_init
     * }
     */
    public static MemorySegment value_init(MemorySegment struct) {
        return struct.get(value_init$LAYOUT, value_init$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GTypeValueInitFunc value_init
     * }
     */
    public static void value_init(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(value_init$LAYOUT, value_init$OFFSET, fieldValue);
    }

    private static final AddressLayout value_free$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("value_free"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GTypeValueFreeFunc value_free
     * }
     */
    public static final AddressLayout value_free$layout() {
        return value_free$LAYOUT;
    }

    private static final long value_free$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GTypeValueFreeFunc value_free
     * }
     */
    public static final long value_free$offset() {
        return value_free$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GTypeValueFreeFunc value_free
     * }
     */
    public static MemorySegment value_free(MemorySegment struct) {
        return struct.get(value_free$LAYOUT, value_free$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GTypeValueFreeFunc value_free
     * }
     */
    public static void value_free(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(value_free$LAYOUT, value_free$OFFSET, fieldValue);
    }

    private static final AddressLayout value_copy$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("value_copy"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GTypeValueCopyFunc value_copy
     * }
     */
    public static final AddressLayout value_copy$layout() {
        return value_copy$LAYOUT;
    }

    private static final long value_copy$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GTypeValueCopyFunc value_copy
     * }
     */
    public static final long value_copy$offset() {
        return value_copy$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GTypeValueCopyFunc value_copy
     * }
     */
    public static MemorySegment value_copy(MemorySegment struct) {
        return struct.get(value_copy$LAYOUT, value_copy$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GTypeValueCopyFunc value_copy
     * }
     */
    public static void value_copy(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(value_copy$LAYOUT, value_copy$OFFSET, fieldValue);
    }

    private static final AddressLayout value_peek_pointer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("value_peek_pointer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GTypeValuePeekPointerFunc value_peek_pointer
     * }
     */
    public static final AddressLayout value_peek_pointer$layout() {
        return value_peek_pointer$LAYOUT;
    }

    private static final long value_peek_pointer$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GTypeValuePeekPointerFunc value_peek_pointer
     * }
     */
    public static final long value_peek_pointer$offset() {
        return value_peek_pointer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GTypeValuePeekPointerFunc value_peek_pointer
     * }
     */
    public static MemorySegment value_peek_pointer(MemorySegment struct) {
        return struct.get(value_peek_pointer$LAYOUT, value_peek_pointer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GTypeValuePeekPointerFunc value_peek_pointer
     * }
     */
    public static void value_peek_pointer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(value_peek_pointer$LAYOUT, value_peek_pointer$OFFSET, fieldValue);
    }

    private static final AddressLayout collect_format$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("collect_format"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const gchar *collect_format
     * }
     */
    public static final AddressLayout collect_format$layout() {
        return collect_format$LAYOUT;
    }

    private static final long collect_format$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const gchar *collect_format
     * }
     */
    public static final long collect_format$offset() {
        return collect_format$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const gchar *collect_format
     * }
     */
    public static MemorySegment collect_format(MemorySegment struct) {
        return struct.get(collect_format$LAYOUT, collect_format$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const gchar *collect_format
     * }
     */
    public static void collect_format(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(collect_format$LAYOUT, collect_format$OFFSET, fieldValue);
    }

    private static final AddressLayout collect_value$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("collect_value"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GTypeValueCollectFunc collect_value
     * }
     */
    public static final AddressLayout collect_value$layout() {
        return collect_value$LAYOUT;
    }

    private static final long collect_value$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GTypeValueCollectFunc collect_value
     * }
     */
    public static final long collect_value$offset() {
        return collect_value$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GTypeValueCollectFunc collect_value
     * }
     */
    public static MemorySegment collect_value(MemorySegment struct) {
        return struct.get(collect_value$LAYOUT, collect_value$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GTypeValueCollectFunc collect_value
     * }
     */
    public static void collect_value(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(collect_value$LAYOUT, collect_value$OFFSET, fieldValue);
    }

    private static final AddressLayout lcopy_format$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("lcopy_format"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const gchar *lcopy_format
     * }
     */
    public static final AddressLayout lcopy_format$layout() {
        return lcopy_format$LAYOUT;
    }

    private static final long lcopy_format$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const gchar *lcopy_format
     * }
     */
    public static final long lcopy_format$offset() {
        return lcopy_format$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const gchar *lcopy_format
     * }
     */
    public static MemorySegment lcopy_format(MemorySegment struct) {
        return struct.get(lcopy_format$LAYOUT, lcopy_format$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const gchar *lcopy_format
     * }
     */
    public static void lcopy_format(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(lcopy_format$LAYOUT, lcopy_format$OFFSET, fieldValue);
    }

    private static final AddressLayout lcopy_value$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("lcopy_value"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GTypeValueLCopyFunc lcopy_value
     * }
     */
    public static final AddressLayout lcopy_value$layout() {
        return lcopy_value$LAYOUT;
    }

    private static final long lcopy_value$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GTypeValueLCopyFunc lcopy_value
     * }
     */
    public static final long lcopy_value$offset() {
        return lcopy_value$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GTypeValueLCopyFunc lcopy_value
     * }
     */
    public static MemorySegment lcopy_value(MemorySegment struct) {
        return struct.get(lcopy_value$LAYOUT, lcopy_value$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GTypeValueLCopyFunc lcopy_value
     * }
     */
    public static void lcopy_value(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(lcopy_value$LAYOUT, lcopy_value$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

