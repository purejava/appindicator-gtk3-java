// Generated by jextract

package org.purejava.appindicator;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct _GtkWidgetClass {
 *     GInitiallyUnownedClass parent_class;
 *     guint activate_signal;
 *     void (*dispatch_child_properties_changed)(GtkWidget *, guint, GParamSpec **);
 *     void (*destroy)(GtkWidget *);
 *     void (*show)(GtkWidget *);
 *     void (*show_all)(GtkWidget *);
 *     void (*hide)(GtkWidget *);
 *     void (*map)(GtkWidget *);
 *     void (*unmap)(GtkWidget *);
 *     void (*realize)(GtkWidget *);
 *     void (*unrealize)(GtkWidget *);
 *     void (*size_allocate)(GtkWidget *, GtkAllocation *);
 *     void (*state_changed)(GtkWidget *, GtkStateType);
 *     void (*state_flags_changed)(GtkWidget *, GtkStateFlags);
 *     void (*parent_set)(GtkWidget *, GtkWidget *);
 *     void (*hierarchy_changed)(GtkWidget *, GtkWidget *);
 *     void (*style_set)(GtkWidget *, GtkStyle *);
 *     void (*direction_changed)(GtkWidget *, GtkTextDirection);
 *     void (*grab_notify)(GtkWidget *, gboolean);
 *     void (*child_notify)(GtkWidget *, GParamSpec *);
 *     gboolean (*draw)(GtkWidget *, cairo_t *);
 *     GtkSizeRequestMode (*get_request_mode)(GtkWidget *);
 *     void (*get_preferred_height)(GtkWidget *, gint *, gint *);
 *     void (*get_preferred_width_for_height)(GtkWidget *, gint, gint *, gint *);
 *     void (*get_preferred_width)(GtkWidget *, gint *, gint *);
 *     void (*get_preferred_height_for_width)(GtkWidget *, gint, gint *, gint *);
 *     gboolean (*mnemonic_activate)(GtkWidget *, gboolean);
 *     void (*grab_focus)(GtkWidget *);
 *     gboolean (*focus)(GtkWidget *, GtkDirectionType);
 *     void (*move_focus)(GtkWidget *, GtkDirectionType);
 *     gboolean (*keynav_failed)(GtkWidget *, GtkDirectionType);
 *     gboolean (*event)(GtkWidget *, GdkEvent *);
 *     gboolean (*button_press_event)(GtkWidget *, GdkEventButton *);
 *     gboolean (*button_release_event)(GtkWidget *, GdkEventButton *);
 *     gboolean (*scroll_event)(GtkWidget *, GdkEventScroll *);
 *     gboolean (*motion_notify_event)(GtkWidget *, GdkEventMotion *);
 *     gboolean (*delete_event)(GtkWidget *, GdkEventAny *);
 *     gboolean (*destroy_event)(GtkWidget *, GdkEventAny *);
 *     gboolean (*key_press_event)(GtkWidget *, GdkEventKey *);
 *     gboolean (*key_release_event)(GtkWidget *, GdkEventKey *);
 *     gboolean (*enter_notify_event)(GtkWidget *, GdkEventCrossing *);
 *     gboolean (*leave_notify_event)(GtkWidget *, GdkEventCrossing *);
 *     gboolean (*configure_event)(GtkWidget *, GdkEventConfigure *);
 *     gboolean (*focus_in_event)(GtkWidget *, GdkEventFocus *);
 *     gboolean (*focus_out_event)(GtkWidget *, GdkEventFocus *);
 *     gboolean (*map_event)(GtkWidget *, GdkEventAny *);
 *     gboolean (*unmap_event)(GtkWidget *, GdkEventAny *);
 *     gboolean (*property_notify_event)(GtkWidget *, GdkEventProperty *);
 *     gboolean (*selection_clear_event)(GtkWidget *, GdkEventSelection *);
 *     gboolean (*selection_request_event)(GtkWidget *, GdkEventSelection *);
 *     gboolean (*selection_notify_event)(GtkWidget *, GdkEventSelection *);
 *     gboolean (*proximity_in_event)(GtkWidget *, GdkEventProximity *);
 *     gboolean (*proximity_out_event)(GtkWidget *, GdkEventProximity *);
 *     gboolean (*visibility_notify_event)(GtkWidget *, GdkEventVisibility *);
 *     gboolean (*window_state_event)(GtkWidget *, GdkEventWindowState *);
 *     gboolean (*damage_event)(GtkWidget *, GdkEventExpose *);
 *     gboolean (*grab_broken_event)(GtkWidget *, GdkEventGrabBroken *);
 *     void (*selection_get)(GtkWidget *, GtkSelectionData *, guint, guint);
 *     void (*selection_received)(GtkWidget *, GtkSelectionData *, guint);
 *     void (*drag_begin)(GtkWidget *, GdkDragContext *);
 *     void (*drag_end)(GtkWidget *, GdkDragContext *);
 *     void (*drag_data_get)(GtkWidget *, GdkDragContext *, GtkSelectionData *, guint, guint);
 *     void (*drag_data_delete)(GtkWidget *, GdkDragContext *);
 *     void (*drag_leave)(GtkWidget *, GdkDragContext *, guint);
 *     gboolean (*drag_motion)(GtkWidget *, GdkDragContext *, gint, gint, guint);
 *     gboolean (*drag_drop)(GtkWidget *, GdkDragContext *, gint, gint, guint);
 *     void (*drag_data_received)(GtkWidget *, GdkDragContext *, gint, gint, GtkSelectionData *, guint, guint);
 *     gboolean (*drag_failed)(GtkWidget *, GdkDragContext *, GtkDragResult);
 *     gboolean (*popup_menu)(GtkWidget *);
 *     gboolean (*show_help)(GtkWidget *, GtkWidgetHelpType);
 *     AtkObject *(*get_accessible)(GtkWidget *);
 *     void (*screen_changed)(GtkWidget *, GdkScreen *);
 *     gboolean (*can_activate_accel)(GtkWidget *, guint);
 *     void (*composited_changed)(GtkWidget *);
 *     gboolean (*query_tooltip)(GtkWidget *, gint, gint, gboolean, GtkTooltip *);
 *     void (*compute_expand)(GtkWidget *, gboolean *, gboolean *);
 *     void (*adjust_size_request)(GtkWidget *, GtkOrientation, gint *, gint *);
 *     void (*adjust_size_allocation)(GtkWidget *, GtkOrientation, gint *, gint *, gint *, gint *);
 *     void (*style_updated)(GtkWidget *);
 *     gboolean (*touch_event)(GtkWidget *, GdkEventTouch *);
 *     void (*get_preferred_height_and_baseline_for_width)(GtkWidget *, gint, gint *, gint *, gint *, gint *);
 *     void (*adjust_baseline_request)(GtkWidget *, gint *, gint *);
 *     void (*adjust_baseline_allocation)(GtkWidget *, gint *);
 *     void (*queue_draw_region)(GtkWidget *, const cairo_region_t *);
 *     GtkWidgetClassPrivate *priv;
 *     void (*_gtk_reserved6)(void);
 *     void (*_gtk_reserved7)(void);
 * }
 * }
 */
public class _GtkWidgetClass {

    _GtkWidgetClass() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        _GObjectClass.layout().withName("parent_class"),
        app_indicator_h.C_INT.withName("activate_signal"),
        MemoryLayout.paddingLayout(4),
        app_indicator_h.C_POINTER.withName("dispatch_child_properties_changed"),
        app_indicator_h.C_POINTER.withName("destroy"),
        app_indicator_h.C_POINTER.withName("show"),
        app_indicator_h.C_POINTER.withName("show_all"),
        app_indicator_h.C_POINTER.withName("hide"),
        app_indicator_h.C_POINTER.withName("map"),
        app_indicator_h.C_POINTER.withName("unmap"),
        app_indicator_h.C_POINTER.withName("realize"),
        app_indicator_h.C_POINTER.withName("unrealize"),
        app_indicator_h.C_POINTER.withName("size_allocate"),
        app_indicator_h.C_POINTER.withName("state_changed"),
        app_indicator_h.C_POINTER.withName("state_flags_changed"),
        app_indicator_h.C_POINTER.withName("parent_set"),
        app_indicator_h.C_POINTER.withName("hierarchy_changed"),
        app_indicator_h.C_POINTER.withName("style_set"),
        app_indicator_h.C_POINTER.withName("direction_changed"),
        app_indicator_h.C_POINTER.withName("grab_notify"),
        app_indicator_h.C_POINTER.withName("child_notify"),
        app_indicator_h.C_POINTER.withName("draw"),
        app_indicator_h.C_POINTER.withName("get_request_mode"),
        app_indicator_h.C_POINTER.withName("get_preferred_height"),
        app_indicator_h.C_POINTER.withName("get_preferred_width_for_height"),
        app_indicator_h.C_POINTER.withName("get_preferred_width"),
        app_indicator_h.C_POINTER.withName("get_preferred_height_for_width"),
        app_indicator_h.C_POINTER.withName("mnemonic_activate"),
        app_indicator_h.C_POINTER.withName("grab_focus"),
        app_indicator_h.C_POINTER.withName("focus"),
        app_indicator_h.C_POINTER.withName("move_focus"),
        app_indicator_h.C_POINTER.withName("keynav_failed"),
        app_indicator_h.C_POINTER.withName("event"),
        app_indicator_h.C_POINTER.withName("button_press_event"),
        app_indicator_h.C_POINTER.withName("button_release_event"),
        app_indicator_h.C_POINTER.withName("scroll_event"),
        app_indicator_h.C_POINTER.withName("motion_notify_event"),
        app_indicator_h.C_POINTER.withName("delete_event"),
        app_indicator_h.C_POINTER.withName("destroy_event"),
        app_indicator_h.C_POINTER.withName("key_press_event"),
        app_indicator_h.C_POINTER.withName("key_release_event"),
        app_indicator_h.C_POINTER.withName("enter_notify_event"),
        app_indicator_h.C_POINTER.withName("leave_notify_event"),
        app_indicator_h.C_POINTER.withName("configure_event"),
        app_indicator_h.C_POINTER.withName("focus_in_event"),
        app_indicator_h.C_POINTER.withName("focus_out_event"),
        app_indicator_h.C_POINTER.withName("map_event"),
        app_indicator_h.C_POINTER.withName("unmap_event"),
        app_indicator_h.C_POINTER.withName("property_notify_event"),
        app_indicator_h.C_POINTER.withName("selection_clear_event"),
        app_indicator_h.C_POINTER.withName("selection_request_event"),
        app_indicator_h.C_POINTER.withName("selection_notify_event"),
        app_indicator_h.C_POINTER.withName("proximity_in_event"),
        app_indicator_h.C_POINTER.withName("proximity_out_event"),
        app_indicator_h.C_POINTER.withName("visibility_notify_event"),
        app_indicator_h.C_POINTER.withName("window_state_event"),
        app_indicator_h.C_POINTER.withName("damage_event"),
        app_indicator_h.C_POINTER.withName("grab_broken_event"),
        app_indicator_h.C_POINTER.withName("selection_get"),
        app_indicator_h.C_POINTER.withName("selection_received"),
        app_indicator_h.C_POINTER.withName("drag_begin"),
        app_indicator_h.C_POINTER.withName("drag_end"),
        app_indicator_h.C_POINTER.withName("drag_data_get"),
        app_indicator_h.C_POINTER.withName("drag_data_delete"),
        app_indicator_h.C_POINTER.withName("drag_leave"),
        app_indicator_h.C_POINTER.withName("drag_motion"),
        app_indicator_h.C_POINTER.withName("drag_drop"),
        app_indicator_h.C_POINTER.withName("drag_data_received"),
        app_indicator_h.C_POINTER.withName("drag_failed"),
        app_indicator_h.C_POINTER.withName("popup_menu"),
        app_indicator_h.C_POINTER.withName("show_help"),
        app_indicator_h.C_POINTER.withName("get_accessible"),
        app_indicator_h.C_POINTER.withName("screen_changed"),
        app_indicator_h.C_POINTER.withName("can_activate_accel"),
        app_indicator_h.C_POINTER.withName("composited_changed"),
        app_indicator_h.C_POINTER.withName("query_tooltip"),
        app_indicator_h.C_POINTER.withName("compute_expand"),
        app_indicator_h.C_POINTER.withName("adjust_size_request"),
        app_indicator_h.C_POINTER.withName("adjust_size_allocation"),
        app_indicator_h.C_POINTER.withName("style_updated"),
        app_indicator_h.C_POINTER.withName("touch_event"),
        app_indicator_h.C_POINTER.withName("get_preferred_height_and_baseline_for_width"),
        app_indicator_h.C_POINTER.withName("adjust_baseline_request"),
        app_indicator_h.C_POINTER.withName("adjust_baseline_allocation"),
        app_indicator_h.C_POINTER.withName("queue_draw_region"),
        app_indicator_h.C_POINTER.withName("priv"),
        app_indicator_h.C_POINTER.withName("_gtk_reserved6"),
        app_indicator_h.C_POINTER.withName("_gtk_reserved7")
    ).withName("_GtkWidgetClass");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final GroupLayout parent_class$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("parent_class"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GInitiallyUnownedClass parent_class
     * }
     */
    public static final GroupLayout parent_class$layout() {
        return parent_class$LAYOUT;
    }

    private static final long parent_class$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GInitiallyUnownedClass parent_class
     * }
     */
    public static final long parent_class$offset() {
        return parent_class$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GInitiallyUnownedClass parent_class
     * }
     */
    public static MemorySegment parent_class(MemorySegment struct) {
        return struct.asSlice(parent_class$OFFSET, parent_class$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GInitiallyUnownedClass parent_class
     * }
     */
    public static void parent_class(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, parent_class$OFFSET, parent_class$LAYOUT.byteSize());
    }

    private static final OfInt activate_signal$LAYOUT = (OfInt)$LAYOUT.select(groupElement("activate_signal"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * guint activate_signal
     * }
     */
    public static final OfInt activate_signal$layout() {
        return activate_signal$LAYOUT;
    }

    private static final long activate_signal$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * guint activate_signal
     * }
     */
    public static final long activate_signal$offset() {
        return activate_signal$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * guint activate_signal
     * }
     */
    public static int activate_signal(MemorySegment struct) {
        return struct.get(activate_signal$LAYOUT, activate_signal$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * guint activate_signal
     * }
     */
    public static void activate_signal(MemorySegment struct, int fieldValue) {
        struct.set(activate_signal$LAYOUT, activate_signal$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*dispatch_child_properties_changed)(GtkWidget *, guint, GParamSpec **)
     * }
     */
    public class dispatch_child_properties_changed {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(dispatch_child_properties_changed.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(dispatch_child_properties_changed.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout dispatch_child_properties_changed$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("dispatch_child_properties_changed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*dispatch_child_properties_changed)(GtkWidget *, guint, GParamSpec **)
     * }
     */
    public static final AddressLayout dispatch_child_properties_changed$layout() {
        return dispatch_child_properties_changed$LAYOUT;
    }

    private static final long dispatch_child_properties_changed$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*dispatch_child_properties_changed)(GtkWidget *, guint, GParamSpec **)
     * }
     */
    public static final long dispatch_child_properties_changed$offset() {
        return dispatch_child_properties_changed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*dispatch_child_properties_changed)(GtkWidget *, guint, GParamSpec **)
     * }
     */
    public static MemorySegment dispatch_child_properties_changed(MemorySegment struct) {
        return struct.get(dispatch_child_properties_changed$LAYOUT, dispatch_child_properties_changed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*dispatch_child_properties_changed)(GtkWidget *, guint, GParamSpec **)
     * }
     */
    public static void dispatch_child_properties_changed(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(dispatch_child_properties_changed$LAYOUT, dispatch_child_properties_changed$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*destroy)(GtkWidget *)
     * }
     */
    public class destroy {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(destroy.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(destroy.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout destroy$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("destroy"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*destroy)(GtkWidget *)
     * }
     */
    public static final AddressLayout destroy$layout() {
        return destroy$LAYOUT;
    }

    private static final long destroy$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*destroy)(GtkWidget *)
     * }
     */
    public static final long destroy$offset() {
        return destroy$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*destroy)(GtkWidget *)
     * }
     */
    public static MemorySegment destroy(MemorySegment struct) {
        return struct.get(destroy$LAYOUT, destroy$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*destroy)(GtkWidget *)
     * }
     */
    public static void destroy(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(destroy$LAYOUT, destroy$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*show)(GtkWidget *)
     * }
     */
    public class show {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(show.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(show.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout show$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("show"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*show)(GtkWidget *)
     * }
     */
    public static final AddressLayout show$layout() {
        return show$LAYOUT;
    }

    private static final long show$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*show)(GtkWidget *)
     * }
     */
    public static final long show$offset() {
        return show$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*show)(GtkWidget *)
     * }
     */
    public static MemorySegment show(MemorySegment struct) {
        return struct.get(show$LAYOUT, show$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*show)(GtkWidget *)
     * }
     */
    public static void show(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(show$LAYOUT, show$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*show_all)(GtkWidget *)
     * }
     */
    public class show_all {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(show_all.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(show_all.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout show_all$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("show_all"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*show_all)(GtkWidget *)
     * }
     */
    public static final AddressLayout show_all$layout() {
        return show_all$LAYOUT;
    }

    private static final long show_all$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*show_all)(GtkWidget *)
     * }
     */
    public static final long show_all$offset() {
        return show_all$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*show_all)(GtkWidget *)
     * }
     */
    public static MemorySegment show_all(MemorySegment struct) {
        return struct.get(show_all$LAYOUT, show_all$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*show_all)(GtkWidget *)
     * }
     */
    public static void show_all(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(show_all$LAYOUT, show_all$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*hide)(GtkWidget *)
     * }
     */
    public class hide {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(hide.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(hide.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout hide$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("hide"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*hide)(GtkWidget *)
     * }
     */
    public static final AddressLayout hide$layout() {
        return hide$LAYOUT;
    }

    private static final long hide$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*hide)(GtkWidget *)
     * }
     */
    public static final long hide$offset() {
        return hide$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*hide)(GtkWidget *)
     * }
     */
    public static MemorySegment hide(MemorySegment struct) {
        return struct.get(hide$LAYOUT, hide$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*hide)(GtkWidget *)
     * }
     */
    public static void hide(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(hide$LAYOUT, hide$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*map)(GtkWidget *)
     * }
     */
    public class map {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(map.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(map.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout map$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("map"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*map)(GtkWidget *)
     * }
     */
    public static final AddressLayout map$layout() {
        return map$LAYOUT;
    }

    private static final long map$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*map)(GtkWidget *)
     * }
     */
    public static final long map$offset() {
        return map$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*map)(GtkWidget *)
     * }
     */
    public static MemorySegment map(MemorySegment struct) {
        return struct.get(map$LAYOUT, map$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*map)(GtkWidget *)
     * }
     */
    public static void map(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(map$LAYOUT, map$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*unmap)(GtkWidget *)
     * }
     */
    public class unmap {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(unmap.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(unmap.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout unmap$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("unmap"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*unmap)(GtkWidget *)
     * }
     */
    public static final AddressLayout unmap$layout() {
        return unmap$LAYOUT;
    }

    private static final long unmap$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*unmap)(GtkWidget *)
     * }
     */
    public static final long unmap$offset() {
        return unmap$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*unmap)(GtkWidget *)
     * }
     */
    public static MemorySegment unmap(MemorySegment struct) {
        return struct.get(unmap$LAYOUT, unmap$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*unmap)(GtkWidget *)
     * }
     */
    public static void unmap(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(unmap$LAYOUT, unmap$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*realize)(GtkWidget *)
     * }
     */
    public class realize {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(realize.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(realize.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout realize$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("realize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*realize)(GtkWidget *)
     * }
     */
    public static final AddressLayout realize$layout() {
        return realize$LAYOUT;
    }

    private static final long realize$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*realize)(GtkWidget *)
     * }
     */
    public static final long realize$offset() {
        return realize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*realize)(GtkWidget *)
     * }
     */
    public static MemorySegment realize(MemorySegment struct) {
        return struct.get(realize$LAYOUT, realize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*realize)(GtkWidget *)
     * }
     */
    public static void realize(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(realize$LAYOUT, realize$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*unrealize)(GtkWidget *)
     * }
     */
    public class unrealize {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(unrealize.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(unrealize.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout unrealize$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("unrealize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*unrealize)(GtkWidget *)
     * }
     */
    public static final AddressLayout unrealize$layout() {
        return unrealize$LAYOUT;
    }

    private static final long unrealize$OFFSET = 208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*unrealize)(GtkWidget *)
     * }
     */
    public static final long unrealize$offset() {
        return unrealize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*unrealize)(GtkWidget *)
     * }
     */
    public static MemorySegment unrealize(MemorySegment struct) {
        return struct.get(unrealize$LAYOUT, unrealize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*unrealize)(GtkWidget *)
     * }
     */
    public static void unrealize(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(unrealize$LAYOUT, unrealize$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*size_allocate)(GtkWidget *, GtkAllocation *)
     * }
     */
    public class size_allocate {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(size_allocate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(size_allocate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout size_allocate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("size_allocate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*size_allocate)(GtkWidget *, GtkAllocation *)
     * }
     */
    public static final AddressLayout size_allocate$layout() {
        return size_allocate$LAYOUT;
    }

    private static final long size_allocate$OFFSET = 216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*size_allocate)(GtkWidget *, GtkAllocation *)
     * }
     */
    public static final long size_allocate$offset() {
        return size_allocate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*size_allocate)(GtkWidget *, GtkAllocation *)
     * }
     */
    public static MemorySegment size_allocate(MemorySegment struct) {
        return struct.get(size_allocate$LAYOUT, size_allocate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*size_allocate)(GtkWidget *, GtkAllocation *)
     * }
     */
    public static void size_allocate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(size_allocate$LAYOUT, size_allocate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*state_changed)(GtkWidget *, GtkStateType)
     * }
     */
    public class state_changed {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(state_changed.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(state_changed.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout state_changed$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("state_changed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*state_changed)(GtkWidget *, GtkStateType)
     * }
     */
    public static final AddressLayout state_changed$layout() {
        return state_changed$LAYOUT;
    }

    private static final long state_changed$OFFSET = 224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*state_changed)(GtkWidget *, GtkStateType)
     * }
     */
    public static final long state_changed$offset() {
        return state_changed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*state_changed)(GtkWidget *, GtkStateType)
     * }
     */
    public static MemorySegment state_changed(MemorySegment struct) {
        return struct.get(state_changed$LAYOUT, state_changed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*state_changed)(GtkWidget *, GtkStateType)
     * }
     */
    public static void state_changed(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(state_changed$LAYOUT, state_changed$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*state_flags_changed)(GtkWidget *, GtkStateFlags)
     * }
     */
    public class state_flags_changed {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(state_flags_changed.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(state_flags_changed.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout state_flags_changed$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("state_flags_changed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*state_flags_changed)(GtkWidget *, GtkStateFlags)
     * }
     */
    public static final AddressLayout state_flags_changed$layout() {
        return state_flags_changed$LAYOUT;
    }

    private static final long state_flags_changed$OFFSET = 232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*state_flags_changed)(GtkWidget *, GtkStateFlags)
     * }
     */
    public static final long state_flags_changed$offset() {
        return state_flags_changed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*state_flags_changed)(GtkWidget *, GtkStateFlags)
     * }
     */
    public static MemorySegment state_flags_changed(MemorySegment struct) {
        return struct.get(state_flags_changed$LAYOUT, state_flags_changed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*state_flags_changed)(GtkWidget *, GtkStateFlags)
     * }
     */
    public static void state_flags_changed(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(state_flags_changed$LAYOUT, state_flags_changed$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*parent_set)(GtkWidget *, GtkWidget *)
     * }
     */
    public class parent_set {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(parent_set.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(parent_set.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout parent_set$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("parent_set"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*parent_set)(GtkWidget *, GtkWidget *)
     * }
     */
    public static final AddressLayout parent_set$layout() {
        return parent_set$LAYOUT;
    }

    private static final long parent_set$OFFSET = 240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*parent_set)(GtkWidget *, GtkWidget *)
     * }
     */
    public static final long parent_set$offset() {
        return parent_set$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*parent_set)(GtkWidget *, GtkWidget *)
     * }
     */
    public static MemorySegment parent_set(MemorySegment struct) {
        return struct.get(parent_set$LAYOUT, parent_set$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*parent_set)(GtkWidget *, GtkWidget *)
     * }
     */
    public static void parent_set(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(parent_set$LAYOUT, parent_set$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*hierarchy_changed)(GtkWidget *, GtkWidget *)
     * }
     */
    public class hierarchy_changed {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(hierarchy_changed.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(hierarchy_changed.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout hierarchy_changed$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("hierarchy_changed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*hierarchy_changed)(GtkWidget *, GtkWidget *)
     * }
     */
    public static final AddressLayout hierarchy_changed$layout() {
        return hierarchy_changed$LAYOUT;
    }

    private static final long hierarchy_changed$OFFSET = 248;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*hierarchy_changed)(GtkWidget *, GtkWidget *)
     * }
     */
    public static final long hierarchy_changed$offset() {
        return hierarchy_changed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*hierarchy_changed)(GtkWidget *, GtkWidget *)
     * }
     */
    public static MemorySegment hierarchy_changed(MemorySegment struct) {
        return struct.get(hierarchy_changed$LAYOUT, hierarchy_changed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*hierarchy_changed)(GtkWidget *, GtkWidget *)
     * }
     */
    public static void hierarchy_changed(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(hierarchy_changed$LAYOUT, hierarchy_changed$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*style_set)(GtkWidget *, GtkStyle *)
     * }
     */
    public class style_set {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(style_set.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(style_set.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout style_set$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("style_set"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*style_set)(GtkWidget *, GtkStyle *)
     * }
     */
    public static final AddressLayout style_set$layout() {
        return style_set$LAYOUT;
    }

    private static final long style_set$OFFSET = 256;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*style_set)(GtkWidget *, GtkStyle *)
     * }
     */
    public static final long style_set$offset() {
        return style_set$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*style_set)(GtkWidget *, GtkStyle *)
     * }
     */
    public static MemorySegment style_set(MemorySegment struct) {
        return struct.get(style_set$LAYOUT, style_set$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*style_set)(GtkWidget *, GtkStyle *)
     * }
     */
    public static void style_set(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(style_set$LAYOUT, style_set$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*direction_changed)(GtkWidget *, GtkTextDirection)
     * }
     */
    public class direction_changed {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(direction_changed.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(direction_changed.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout direction_changed$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("direction_changed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*direction_changed)(GtkWidget *, GtkTextDirection)
     * }
     */
    public static final AddressLayout direction_changed$layout() {
        return direction_changed$LAYOUT;
    }

    private static final long direction_changed$OFFSET = 264;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*direction_changed)(GtkWidget *, GtkTextDirection)
     * }
     */
    public static final long direction_changed$offset() {
        return direction_changed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*direction_changed)(GtkWidget *, GtkTextDirection)
     * }
     */
    public static MemorySegment direction_changed(MemorySegment struct) {
        return struct.get(direction_changed$LAYOUT, direction_changed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*direction_changed)(GtkWidget *, GtkTextDirection)
     * }
     */
    public static void direction_changed(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(direction_changed$LAYOUT, direction_changed$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*grab_notify)(GtkWidget *, gboolean)
     * }
     */
    public class grab_notify {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(grab_notify.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(grab_notify.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout grab_notify$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("grab_notify"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*grab_notify)(GtkWidget *, gboolean)
     * }
     */
    public static final AddressLayout grab_notify$layout() {
        return grab_notify$LAYOUT;
    }

    private static final long grab_notify$OFFSET = 272;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*grab_notify)(GtkWidget *, gboolean)
     * }
     */
    public static final long grab_notify$offset() {
        return grab_notify$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*grab_notify)(GtkWidget *, gboolean)
     * }
     */
    public static MemorySegment grab_notify(MemorySegment struct) {
        return struct.get(grab_notify$LAYOUT, grab_notify$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*grab_notify)(GtkWidget *, gboolean)
     * }
     */
    public static void grab_notify(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(grab_notify$LAYOUT, grab_notify$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*child_notify)(GtkWidget *, GParamSpec *)
     * }
     */
    public class child_notify {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(child_notify.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(child_notify.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout child_notify$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("child_notify"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*child_notify)(GtkWidget *, GParamSpec *)
     * }
     */
    public static final AddressLayout child_notify$layout() {
        return child_notify$LAYOUT;
    }

    private static final long child_notify$OFFSET = 280;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*child_notify)(GtkWidget *, GParamSpec *)
     * }
     */
    public static final long child_notify$offset() {
        return child_notify$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*child_notify)(GtkWidget *, GParamSpec *)
     * }
     */
    public static MemorySegment child_notify(MemorySegment struct) {
        return struct.get(child_notify$LAYOUT, child_notify$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*child_notify)(GtkWidget *, GParamSpec *)
     * }
     */
    public static void child_notify(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(child_notify$LAYOUT, child_notify$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*draw)(GtkWidget *, cairo_t *)
     * }
     */
    public class draw {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(draw.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(draw.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout draw$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("draw"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*draw)(GtkWidget *, cairo_t *)
     * }
     */
    public static final AddressLayout draw$layout() {
        return draw$LAYOUT;
    }

    private static final long draw$OFFSET = 288;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*draw)(GtkWidget *, cairo_t *)
     * }
     */
    public static final long draw$offset() {
        return draw$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*draw)(GtkWidget *, cairo_t *)
     * }
     */
    public static MemorySegment draw(MemorySegment struct) {
        return struct.get(draw$LAYOUT, draw$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*draw)(GtkWidget *, cairo_t *)
     * }
     */
    public static void draw(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(draw$LAYOUT, draw$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GtkSizeRequestMode (*get_request_mode)(GtkWidget *)
     * }
     */
    public class get_request_mode {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_request_mode.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_request_mode.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_request_mode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_request_mode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GtkSizeRequestMode (*get_request_mode)(GtkWidget *)
     * }
     */
    public static final AddressLayout get_request_mode$layout() {
        return get_request_mode$LAYOUT;
    }

    private static final long get_request_mode$OFFSET = 296;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GtkSizeRequestMode (*get_request_mode)(GtkWidget *)
     * }
     */
    public static final long get_request_mode$offset() {
        return get_request_mode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GtkSizeRequestMode (*get_request_mode)(GtkWidget *)
     * }
     */
    public static MemorySegment get_request_mode(MemorySegment struct) {
        return struct.get(get_request_mode$LAYOUT, get_request_mode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GtkSizeRequestMode (*get_request_mode)(GtkWidget *)
     * }
     */
    public static void get_request_mode(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_request_mode$LAYOUT, get_request_mode$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*get_preferred_height)(GtkWidget *, gint *, gint *)
     * }
     */
    public class get_preferred_height {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_preferred_height.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_preferred_height.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_preferred_height$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_preferred_height"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*get_preferred_height)(GtkWidget *, gint *, gint *)
     * }
     */
    public static final AddressLayout get_preferred_height$layout() {
        return get_preferred_height$LAYOUT;
    }

    private static final long get_preferred_height$OFFSET = 304;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*get_preferred_height)(GtkWidget *, gint *, gint *)
     * }
     */
    public static final long get_preferred_height$offset() {
        return get_preferred_height$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*get_preferred_height)(GtkWidget *, gint *, gint *)
     * }
     */
    public static MemorySegment get_preferred_height(MemorySegment struct) {
        return struct.get(get_preferred_height$LAYOUT, get_preferred_height$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*get_preferred_height)(GtkWidget *, gint *, gint *)
     * }
     */
    public static void get_preferred_height(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_preferred_height$LAYOUT, get_preferred_height$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*get_preferred_width_for_height)(GtkWidget *, gint, gint *, gint *)
     * }
     */
    public class get_preferred_width_for_height {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_preferred_width_for_height.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_preferred_width_for_height.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_preferred_width_for_height$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_preferred_width_for_height"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*get_preferred_width_for_height)(GtkWidget *, gint, gint *, gint *)
     * }
     */
    public static final AddressLayout get_preferred_width_for_height$layout() {
        return get_preferred_width_for_height$LAYOUT;
    }

    private static final long get_preferred_width_for_height$OFFSET = 312;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*get_preferred_width_for_height)(GtkWidget *, gint, gint *, gint *)
     * }
     */
    public static final long get_preferred_width_for_height$offset() {
        return get_preferred_width_for_height$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*get_preferred_width_for_height)(GtkWidget *, gint, gint *, gint *)
     * }
     */
    public static MemorySegment get_preferred_width_for_height(MemorySegment struct) {
        return struct.get(get_preferred_width_for_height$LAYOUT, get_preferred_width_for_height$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*get_preferred_width_for_height)(GtkWidget *, gint, gint *, gint *)
     * }
     */
    public static void get_preferred_width_for_height(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_preferred_width_for_height$LAYOUT, get_preferred_width_for_height$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*get_preferred_width)(GtkWidget *, gint *, gint *)
     * }
     */
    public class get_preferred_width {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_preferred_width.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_preferred_width.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_preferred_width$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_preferred_width"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*get_preferred_width)(GtkWidget *, gint *, gint *)
     * }
     */
    public static final AddressLayout get_preferred_width$layout() {
        return get_preferred_width$LAYOUT;
    }

    private static final long get_preferred_width$OFFSET = 320;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*get_preferred_width)(GtkWidget *, gint *, gint *)
     * }
     */
    public static final long get_preferred_width$offset() {
        return get_preferred_width$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*get_preferred_width)(GtkWidget *, gint *, gint *)
     * }
     */
    public static MemorySegment get_preferred_width(MemorySegment struct) {
        return struct.get(get_preferred_width$LAYOUT, get_preferred_width$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*get_preferred_width)(GtkWidget *, gint *, gint *)
     * }
     */
    public static void get_preferred_width(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_preferred_width$LAYOUT, get_preferred_width$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*get_preferred_height_for_width)(GtkWidget *, gint, gint *, gint *)
     * }
     */
    public class get_preferred_height_for_width {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_preferred_height_for_width.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_preferred_height_for_width.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_preferred_height_for_width$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_preferred_height_for_width"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*get_preferred_height_for_width)(GtkWidget *, gint, gint *, gint *)
     * }
     */
    public static final AddressLayout get_preferred_height_for_width$layout() {
        return get_preferred_height_for_width$LAYOUT;
    }

    private static final long get_preferred_height_for_width$OFFSET = 328;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*get_preferred_height_for_width)(GtkWidget *, gint, gint *, gint *)
     * }
     */
    public static final long get_preferred_height_for_width$offset() {
        return get_preferred_height_for_width$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*get_preferred_height_for_width)(GtkWidget *, gint, gint *, gint *)
     * }
     */
    public static MemorySegment get_preferred_height_for_width(MemorySegment struct) {
        return struct.get(get_preferred_height_for_width$LAYOUT, get_preferred_height_for_width$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*get_preferred_height_for_width)(GtkWidget *, gint, gint *, gint *)
     * }
     */
    public static void get_preferred_height_for_width(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_preferred_height_for_width$LAYOUT, get_preferred_height_for_width$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*mnemonic_activate)(GtkWidget *, gboolean)
     * }
     */
    public class mnemonic_activate {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(mnemonic_activate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(mnemonic_activate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout mnemonic_activate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("mnemonic_activate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*mnemonic_activate)(GtkWidget *, gboolean)
     * }
     */
    public static final AddressLayout mnemonic_activate$layout() {
        return mnemonic_activate$LAYOUT;
    }

    private static final long mnemonic_activate$OFFSET = 336;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*mnemonic_activate)(GtkWidget *, gboolean)
     * }
     */
    public static final long mnemonic_activate$offset() {
        return mnemonic_activate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*mnemonic_activate)(GtkWidget *, gboolean)
     * }
     */
    public static MemorySegment mnemonic_activate(MemorySegment struct) {
        return struct.get(mnemonic_activate$LAYOUT, mnemonic_activate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*mnemonic_activate)(GtkWidget *, gboolean)
     * }
     */
    public static void mnemonic_activate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(mnemonic_activate$LAYOUT, mnemonic_activate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*grab_focus)(GtkWidget *)
     * }
     */
    public class grab_focus {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(grab_focus.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(grab_focus.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout grab_focus$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("grab_focus"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*grab_focus)(GtkWidget *)
     * }
     */
    public static final AddressLayout grab_focus$layout() {
        return grab_focus$LAYOUT;
    }

    private static final long grab_focus$OFFSET = 344;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*grab_focus)(GtkWidget *)
     * }
     */
    public static final long grab_focus$offset() {
        return grab_focus$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*grab_focus)(GtkWidget *)
     * }
     */
    public static MemorySegment grab_focus(MemorySegment struct) {
        return struct.get(grab_focus$LAYOUT, grab_focus$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*grab_focus)(GtkWidget *)
     * }
     */
    public static void grab_focus(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(grab_focus$LAYOUT, grab_focus$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*focus)(GtkWidget *, GtkDirectionType)
     * }
     */
    public class focus {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(focus.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(focus.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout focus$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("focus"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*focus)(GtkWidget *, GtkDirectionType)
     * }
     */
    public static final AddressLayout focus$layout() {
        return focus$LAYOUT;
    }

    private static final long focus$OFFSET = 352;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*focus)(GtkWidget *, GtkDirectionType)
     * }
     */
    public static final long focus$offset() {
        return focus$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*focus)(GtkWidget *, GtkDirectionType)
     * }
     */
    public static MemorySegment focus(MemorySegment struct) {
        return struct.get(focus$LAYOUT, focus$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*focus)(GtkWidget *, GtkDirectionType)
     * }
     */
    public static void focus(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(focus$LAYOUT, focus$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*move_focus)(GtkWidget *, GtkDirectionType)
     * }
     */
    public class move_focus {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(move_focus.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(move_focus.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout move_focus$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("move_focus"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*move_focus)(GtkWidget *, GtkDirectionType)
     * }
     */
    public static final AddressLayout move_focus$layout() {
        return move_focus$LAYOUT;
    }

    private static final long move_focus$OFFSET = 360;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*move_focus)(GtkWidget *, GtkDirectionType)
     * }
     */
    public static final long move_focus$offset() {
        return move_focus$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*move_focus)(GtkWidget *, GtkDirectionType)
     * }
     */
    public static MemorySegment move_focus(MemorySegment struct) {
        return struct.get(move_focus$LAYOUT, move_focus$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*move_focus)(GtkWidget *, GtkDirectionType)
     * }
     */
    public static void move_focus(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(move_focus$LAYOUT, move_focus$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*keynav_failed)(GtkWidget *, GtkDirectionType)
     * }
     */
    public class keynav_failed {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(keynav_failed.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(keynav_failed.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout keynav_failed$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("keynav_failed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*keynav_failed)(GtkWidget *, GtkDirectionType)
     * }
     */
    public static final AddressLayout keynav_failed$layout() {
        return keynav_failed$LAYOUT;
    }

    private static final long keynav_failed$OFFSET = 368;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*keynav_failed)(GtkWidget *, GtkDirectionType)
     * }
     */
    public static final long keynav_failed$offset() {
        return keynav_failed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*keynav_failed)(GtkWidget *, GtkDirectionType)
     * }
     */
    public static MemorySegment keynav_failed(MemorySegment struct) {
        return struct.get(keynav_failed$LAYOUT, keynav_failed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*keynav_failed)(GtkWidget *, GtkDirectionType)
     * }
     */
    public static void keynav_failed(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(keynav_failed$LAYOUT, keynav_failed$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*event)(GtkWidget *, GdkEvent *)
     * }
     */
    public class event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*event)(GtkWidget *, GdkEvent *)
     * }
     */
    public static final AddressLayout event$layout() {
        return event$LAYOUT;
    }

    private static final long event$OFFSET = 376;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*event)(GtkWidget *, GdkEvent *)
     * }
     */
    public static final long event$offset() {
        return event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*event)(GtkWidget *, GdkEvent *)
     * }
     */
    public static MemorySegment event(MemorySegment struct) {
        return struct.get(event$LAYOUT, event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*event)(GtkWidget *, GdkEvent *)
     * }
     */
    public static void event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(event$LAYOUT, event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*button_press_event)(GtkWidget *, GdkEventButton *)
     * }
     */
    public class button_press_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(button_press_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(button_press_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout button_press_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("button_press_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*button_press_event)(GtkWidget *, GdkEventButton *)
     * }
     */
    public static final AddressLayout button_press_event$layout() {
        return button_press_event$LAYOUT;
    }

    private static final long button_press_event$OFFSET = 384;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*button_press_event)(GtkWidget *, GdkEventButton *)
     * }
     */
    public static final long button_press_event$offset() {
        return button_press_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*button_press_event)(GtkWidget *, GdkEventButton *)
     * }
     */
    public static MemorySegment button_press_event(MemorySegment struct) {
        return struct.get(button_press_event$LAYOUT, button_press_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*button_press_event)(GtkWidget *, GdkEventButton *)
     * }
     */
    public static void button_press_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(button_press_event$LAYOUT, button_press_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*button_release_event)(GtkWidget *, GdkEventButton *)
     * }
     */
    public class button_release_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(button_release_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(button_release_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout button_release_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("button_release_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*button_release_event)(GtkWidget *, GdkEventButton *)
     * }
     */
    public static final AddressLayout button_release_event$layout() {
        return button_release_event$LAYOUT;
    }

    private static final long button_release_event$OFFSET = 392;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*button_release_event)(GtkWidget *, GdkEventButton *)
     * }
     */
    public static final long button_release_event$offset() {
        return button_release_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*button_release_event)(GtkWidget *, GdkEventButton *)
     * }
     */
    public static MemorySegment button_release_event(MemorySegment struct) {
        return struct.get(button_release_event$LAYOUT, button_release_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*button_release_event)(GtkWidget *, GdkEventButton *)
     * }
     */
    public static void button_release_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(button_release_event$LAYOUT, button_release_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*scroll_event)(GtkWidget *, GdkEventScroll *)
     * }
     */
    public class scroll_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(scroll_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(scroll_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout scroll_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("scroll_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*scroll_event)(GtkWidget *, GdkEventScroll *)
     * }
     */
    public static final AddressLayout scroll_event$layout() {
        return scroll_event$LAYOUT;
    }

    private static final long scroll_event$OFFSET = 400;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*scroll_event)(GtkWidget *, GdkEventScroll *)
     * }
     */
    public static final long scroll_event$offset() {
        return scroll_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*scroll_event)(GtkWidget *, GdkEventScroll *)
     * }
     */
    public static MemorySegment scroll_event(MemorySegment struct) {
        return struct.get(scroll_event$LAYOUT, scroll_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*scroll_event)(GtkWidget *, GdkEventScroll *)
     * }
     */
    public static void scroll_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(scroll_event$LAYOUT, scroll_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*motion_notify_event)(GtkWidget *, GdkEventMotion *)
     * }
     */
    public class motion_notify_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(motion_notify_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(motion_notify_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout motion_notify_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("motion_notify_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*motion_notify_event)(GtkWidget *, GdkEventMotion *)
     * }
     */
    public static final AddressLayout motion_notify_event$layout() {
        return motion_notify_event$LAYOUT;
    }

    private static final long motion_notify_event$OFFSET = 408;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*motion_notify_event)(GtkWidget *, GdkEventMotion *)
     * }
     */
    public static final long motion_notify_event$offset() {
        return motion_notify_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*motion_notify_event)(GtkWidget *, GdkEventMotion *)
     * }
     */
    public static MemorySegment motion_notify_event(MemorySegment struct) {
        return struct.get(motion_notify_event$LAYOUT, motion_notify_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*motion_notify_event)(GtkWidget *, GdkEventMotion *)
     * }
     */
    public static void motion_notify_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(motion_notify_event$LAYOUT, motion_notify_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*delete_event)(GtkWidget *, GdkEventAny *)
     * }
     */
    public class delete_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(delete_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(delete_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout delete_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("delete_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*delete_event)(GtkWidget *, GdkEventAny *)
     * }
     */
    public static final AddressLayout delete_event$layout() {
        return delete_event$LAYOUT;
    }

    private static final long delete_event$OFFSET = 416;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*delete_event)(GtkWidget *, GdkEventAny *)
     * }
     */
    public static final long delete_event$offset() {
        return delete_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*delete_event)(GtkWidget *, GdkEventAny *)
     * }
     */
    public static MemorySegment delete_event(MemorySegment struct) {
        return struct.get(delete_event$LAYOUT, delete_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*delete_event)(GtkWidget *, GdkEventAny *)
     * }
     */
    public static void delete_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(delete_event$LAYOUT, delete_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*destroy_event)(GtkWidget *, GdkEventAny *)
     * }
     */
    public class destroy_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(destroy_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(destroy_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout destroy_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("destroy_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*destroy_event)(GtkWidget *, GdkEventAny *)
     * }
     */
    public static final AddressLayout destroy_event$layout() {
        return destroy_event$LAYOUT;
    }

    private static final long destroy_event$OFFSET = 424;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*destroy_event)(GtkWidget *, GdkEventAny *)
     * }
     */
    public static final long destroy_event$offset() {
        return destroy_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*destroy_event)(GtkWidget *, GdkEventAny *)
     * }
     */
    public static MemorySegment destroy_event(MemorySegment struct) {
        return struct.get(destroy_event$LAYOUT, destroy_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*destroy_event)(GtkWidget *, GdkEventAny *)
     * }
     */
    public static void destroy_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(destroy_event$LAYOUT, destroy_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*key_press_event)(GtkWidget *, GdkEventKey *)
     * }
     */
    public class key_press_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(key_press_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(key_press_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout key_press_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("key_press_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*key_press_event)(GtkWidget *, GdkEventKey *)
     * }
     */
    public static final AddressLayout key_press_event$layout() {
        return key_press_event$LAYOUT;
    }

    private static final long key_press_event$OFFSET = 432;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*key_press_event)(GtkWidget *, GdkEventKey *)
     * }
     */
    public static final long key_press_event$offset() {
        return key_press_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*key_press_event)(GtkWidget *, GdkEventKey *)
     * }
     */
    public static MemorySegment key_press_event(MemorySegment struct) {
        return struct.get(key_press_event$LAYOUT, key_press_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*key_press_event)(GtkWidget *, GdkEventKey *)
     * }
     */
    public static void key_press_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(key_press_event$LAYOUT, key_press_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*key_release_event)(GtkWidget *, GdkEventKey *)
     * }
     */
    public class key_release_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(key_release_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(key_release_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout key_release_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("key_release_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*key_release_event)(GtkWidget *, GdkEventKey *)
     * }
     */
    public static final AddressLayout key_release_event$layout() {
        return key_release_event$LAYOUT;
    }

    private static final long key_release_event$OFFSET = 440;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*key_release_event)(GtkWidget *, GdkEventKey *)
     * }
     */
    public static final long key_release_event$offset() {
        return key_release_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*key_release_event)(GtkWidget *, GdkEventKey *)
     * }
     */
    public static MemorySegment key_release_event(MemorySegment struct) {
        return struct.get(key_release_event$LAYOUT, key_release_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*key_release_event)(GtkWidget *, GdkEventKey *)
     * }
     */
    public static void key_release_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(key_release_event$LAYOUT, key_release_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*enter_notify_event)(GtkWidget *, GdkEventCrossing *)
     * }
     */
    public class enter_notify_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(enter_notify_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(enter_notify_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout enter_notify_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("enter_notify_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*enter_notify_event)(GtkWidget *, GdkEventCrossing *)
     * }
     */
    public static final AddressLayout enter_notify_event$layout() {
        return enter_notify_event$LAYOUT;
    }

    private static final long enter_notify_event$OFFSET = 448;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*enter_notify_event)(GtkWidget *, GdkEventCrossing *)
     * }
     */
    public static final long enter_notify_event$offset() {
        return enter_notify_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*enter_notify_event)(GtkWidget *, GdkEventCrossing *)
     * }
     */
    public static MemorySegment enter_notify_event(MemorySegment struct) {
        return struct.get(enter_notify_event$LAYOUT, enter_notify_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*enter_notify_event)(GtkWidget *, GdkEventCrossing *)
     * }
     */
    public static void enter_notify_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(enter_notify_event$LAYOUT, enter_notify_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*leave_notify_event)(GtkWidget *, GdkEventCrossing *)
     * }
     */
    public class leave_notify_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(leave_notify_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(leave_notify_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout leave_notify_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("leave_notify_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*leave_notify_event)(GtkWidget *, GdkEventCrossing *)
     * }
     */
    public static final AddressLayout leave_notify_event$layout() {
        return leave_notify_event$LAYOUT;
    }

    private static final long leave_notify_event$OFFSET = 456;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*leave_notify_event)(GtkWidget *, GdkEventCrossing *)
     * }
     */
    public static final long leave_notify_event$offset() {
        return leave_notify_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*leave_notify_event)(GtkWidget *, GdkEventCrossing *)
     * }
     */
    public static MemorySegment leave_notify_event(MemorySegment struct) {
        return struct.get(leave_notify_event$LAYOUT, leave_notify_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*leave_notify_event)(GtkWidget *, GdkEventCrossing *)
     * }
     */
    public static void leave_notify_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(leave_notify_event$LAYOUT, leave_notify_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*configure_event)(GtkWidget *, GdkEventConfigure *)
     * }
     */
    public class configure_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(configure_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(configure_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout configure_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("configure_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*configure_event)(GtkWidget *, GdkEventConfigure *)
     * }
     */
    public static final AddressLayout configure_event$layout() {
        return configure_event$LAYOUT;
    }

    private static final long configure_event$OFFSET = 464;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*configure_event)(GtkWidget *, GdkEventConfigure *)
     * }
     */
    public static final long configure_event$offset() {
        return configure_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*configure_event)(GtkWidget *, GdkEventConfigure *)
     * }
     */
    public static MemorySegment configure_event(MemorySegment struct) {
        return struct.get(configure_event$LAYOUT, configure_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*configure_event)(GtkWidget *, GdkEventConfigure *)
     * }
     */
    public static void configure_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(configure_event$LAYOUT, configure_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*focus_in_event)(GtkWidget *, GdkEventFocus *)
     * }
     */
    public class focus_in_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(focus_in_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(focus_in_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout focus_in_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("focus_in_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*focus_in_event)(GtkWidget *, GdkEventFocus *)
     * }
     */
    public static final AddressLayout focus_in_event$layout() {
        return focus_in_event$LAYOUT;
    }

    private static final long focus_in_event$OFFSET = 472;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*focus_in_event)(GtkWidget *, GdkEventFocus *)
     * }
     */
    public static final long focus_in_event$offset() {
        return focus_in_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*focus_in_event)(GtkWidget *, GdkEventFocus *)
     * }
     */
    public static MemorySegment focus_in_event(MemorySegment struct) {
        return struct.get(focus_in_event$LAYOUT, focus_in_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*focus_in_event)(GtkWidget *, GdkEventFocus *)
     * }
     */
    public static void focus_in_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(focus_in_event$LAYOUT, focus_in_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*focus_out_event)(GtkWidget *, GdkEventFocus *)
     * }
     */
    public class focus_out_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(focus_out_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(focus_out_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout focus_out_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("focus_out_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*focus_out_event)(GtkWidget *, GdkEventFocus *)
     * }
     */
    public static final AddressLayout focus_out_event$layout() {
        return focus_out_event$LAYOUT;
    }

    private static final long focus_out_event$OFFSET = 480;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*focus_out_event)(GtkWidget *, GdkEventFocus *)
     * }
     */
    public static final long focus_out_event$offset() {
        return focus_out_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*focus_out_event)(GtkWidget *, GdkEventFocus *)
     * }
     */
    public static MemorySegment focus_out_event(MemorySegment struct) {
        return struct.get(focus_out_event$LAYOUT, focus_out_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*focus_out_event)(GtkWidget *, GdkEventFocus *)
     * }
     */
    public static void focus_out_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(focus_out_event$LAYOUT, focus_out_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*map_event)(GtkWidget *, GdkEventAny *)
     * }
     */
    public class map_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(map_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(map_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout map_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("map_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*map_event)(GtkWidget *, GdkEventAny *)
     * }
     */
    public static final AddressLayout map_event$layout() {
        return map_event$LAYOUT;
    }

    private static final long map_event$OFFSET = 488;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*map_event)(GtkWidget *, GdkEventAny *)
     * }
     */
    public static final long map_event$offset() {
        return map_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*map_event)(GtkWidget *, GdkEventAny *)
     * }
     */
    public static MemorySegment map_event(MemorySegment struct) {
        return struct.get(map_event$LAYOUT, map_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*map_event)(GtkWidget *, GdkEventAny *)
     * }
     */
    public static void map_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(map_event$LAYOUT, map_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*unmap_event)(GtkWidget *, GdkEventAny *)
     * }
     */
    public class unmap_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(unmap_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(unmap_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout unmap_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("unmap_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*unmap_event)(GtkWidget *, GdkEventAny *)
     * }
     */
    public static final AddressLayout unmap_event$layout() {
        return unmap_event$LAYOUT;
    }

    private static final long unmap_event$OFFSET = 496;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*unmap_event)(GtkWidget *, GdkEventAny *)
     * }
     */
    public static final long unmap_event$offset() {
        return unmap_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*unmap_event)(GtkWidget *, GdkEventAny *)
     * }
     */
    public static MemorySegment unmap_event(MemorySegment struct) {
        return struct.get(unmap_event$LAYOUT, unmap_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*unmap_event)(GtkWidget *, GdkEventAny *)
     * }
     */
    public static void unmap_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(unmap_event$LAYOUT, unmap_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*property_notify_event)(GtkWidget *, GdkEventProperty *)
     * }
     */
    public class property_notify_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(property_notify_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(property_notify_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout property_notify_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("property_notify_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*property_notify_event)(GtkWidget *, GdkEventProperty *)
     * }
     */
    public static final AddressLayout property_notify_event$layout() {
        return property_notify_event$LAYOUT;
    }

    private static final long property_notify_event$OFFSET = 504;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*property_notify_event)(GtkWidget *, GdkEventProperty *)
     * }
     */
    public static final long property_notify_event$offset() {
        return property_notify_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*property_notify_event)(GtkWidget *, GdkEventProperty *)
     * }
     */
    public static MemorySegment property_notify_event(MemorySegment struct) {
        return struct.get(property_notify_event$LAYOUT, property_notify_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*property_notify_event)(GtkWidget *, GdkEventProperty *)
     * }
     */
    public static void property_notify_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(property_notify_event$LAYOUT, property_notify_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*selection_clear_event)(GtkWidget *, GdkEventSelection *)
     * }
     */
    public class selection_clear_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(selection_clear_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(selection_clear_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout selection_clear_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("selection_clear_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*selection_clear_event)(GtkWidget *, GdkEventSelection *)
     * }
     */
    public static final AddressLayout selection_clear_event$layout() {
        return selection_clear_event$LAYOUT;
    }

    private static final long selection_clear_event$OFFSET = 512;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*selection_clear_event)(GtkWidget *, GdkEventSelection *)
     * }
     */
    public static final long selection_clear_event$offset() {
        return selection_clear_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*selection_clear_event)(GtkWidget *, GdkEventSelection *)
     * }
     */
    public static MemorySegment selection_clear_event(MemorySegment struct) {
        return struct.get(selection_clear_event$LAYOUT, selection_clear_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*selection_clear_event)(GtkWidget *, GdkEventSelection *)
     * }
     */
    public static void selection_clear_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(selection_clear_event$LAYOUT, selection_clear_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*selection_request_event)(GtkWidget *, GdkEventSelection *)
     * }
     */
    public class selection_request_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(selection_request_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(selection_request_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout selection_request_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("selection_request_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*selection_request_event)(GtkWidget *, GdkEventSelection *)
     * }
     */
    public static final AddressLayout selection_request_event$layout() {
        return selection_request_event$LAYOUT;
    }

    private static final long selection_request_event$OFFSET = 520;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*selection_request_event)(GtkWidget *, GdkEventSelection *)
     * }
     */
    public static final long selection_request_event$offset() {
        return selection_request_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*selection_request_event)(GtkWidget *, GdkEventSelection *)
     * }
     */
    public static MemorySegment selection_request_event(MemorySegment struct) {
        return struct.get(selection_request_event$LAYOUT, selection_request_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*selection_request_event)(GtkWidget *, GdkEventSelection *)
     * }
     */
    public static void selection_request_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(selection_request_event$LAYOUT, selection_request_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*selection_notify_event)(GtkWidget *, GdkEventSelection *)
     * }
     */
    public class selection_notify_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(selection_notify_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(selection_notify_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout selection_notify_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("selection_notify_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*selection_notify_event)(GtkWidget *, GdkEventSelection *)
     * }
     */
    public static final AddressLayout selection_notify_event$layout() {
        return selection_notify_event$LAYOUT;
    }

    private static final long selection_notify_event$OFFSET = 528;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*selection_notify_event)(GtkWidget *, GdkEventSelection *)
     * }
     */
    public static final long selection_notify_event$offset() {
        return selection_notify_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*selection_notify_event)(GtkWidget *, GdkEventSelection *)
     * }
     */
    public static MemorySegment selection_notify_event(MemorySegment struct) {
        return struct.get(selection_notify_event$LAYOUT, selection_notify_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*selection_notify_event)(GtkWidget *, GdkEventSelection *)
     * }
     */
    public static void selection_notify_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(selection_notify_event$LAYOUT, selection_notify_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*proximity_in_event)(GtkWidget *, GdkEventProximity *)
     * }
     */
    public class proximity_in_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(proximity_in_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(proximity_in_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout proximity_in_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("proximity_in_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*proximity_in_event)(GtkWidget *, GdkEventProximity *)
     * }
     */
    public static final AddressLayout proximity_in_event$layout() {
        return proximity_in_event$LAYOUT;
    }

    private static final long proximity_in_event$OFFSET = 536;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*proximity_in_event)(GtkWidget *, GdkEventProximity *)
     * }
     */
    public static final long proximity_in_event$offset() {
        return proximity_in_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*proximity_in_event)(GtkWidget *, GdkEventProximity *)
     * }
     */
    public static MemorySegment proximity_in_event(MemorySegment struct) {
        return struct.get(proximity_in_event$LAYOUT, proximity_in_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*proximity_in_event)(GtkWidget *, GdkEventProximity *)
     * }
     */
    public static void proximity_in_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(proximity_in_event$LAYOUT, proximity_in_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*proximity_out_event)(GtkWidget *, GdkEventProximity *)
     * }
     */
    public class proximity_out_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(proximity_out_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(proximity_out_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout proximity_out_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("proximity_out_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*proximity_out_event)(GtkWidget *, GdkEventProximity *)
     * }
     */
    public static final AddressLayout proximity_out_event$layout() {
        return proximity_out_event$LAYOUT;
    }

    private static final long proximity_out_event$OFFSET = 544;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*proximity_out_event)(GtkWidget *, GdkEventProximity *)
     * }
     */
    public static final long proximity_out_event$offset() {
        return proximity_out_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*proximity_out_event)(GtkWidget *, GdkEventProximity *)
     * }
     */
    public static MemorySegment proximity_out_event(MemorySegment struct) {
        return struct.get(proximity_out_event$LAYOUT, proximity_out_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*proximity_out_event)(GtkWidget *, GdkEventProximity *)
     * }
     */
    public static void proximity_out_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(proximity_out_event$LAYOUT, proximity_out_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*visibility_notify_event)(GtkWidget *, GdkEventVisibility *)
     * }
     */
    public class visibility_notify_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(visibility_notify_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(visibility_notify_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout visibility_notify_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("visibility_notify_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*visibility_notify_event)(GtkWidget *, GdkEventVisibility *)
     * }
     */
    public static final AddressLayout visibility_notify_event$layout() {
        return visibility_notify_event$LAYOUT;
    }

    private static final long visibility_notify_event$OFFSET = 552;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*visibility_notify_event)(GtkWidget *, GdkEventVisibility *)
     * }
     */
    public static final long visibility_notify_event$offset() {
        return visibility_notify_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*visibility_notify_event)(GtkWidget *, GdkEventVisibility *)
     * }
     */
    public static MemorySegment visibility_notify_event(MemorySegment struct) {
        return struct.get(visibility_notify_event$LAYOUT, visibility_notify_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*visibility_notify_event)(GtkWidget *, GdkEventVisibility *)
     * }
     */
    public static void visibility_notify_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(visibility_notify_event$LAYOUT, visibility_notify_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*window_state_event)(GtkWidget *, GdkEventWindowState *)
     * }
     */
    public class window_state_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(window_state_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(window_state_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout window_state_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("window_state_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*window_state_event)(GtkWidget *, GdkEventWindowState *)
     * }
     */
    public static final AddressLayout window_state_event$layout() {
        return window_state_event$LAYOUT;
    }

    private static final long window_state_event$OFFSET = 560;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*window_state_event)(GtkWidget *, GdkEventWindowState *)
     * }
     */
    public static final long window_state_event$offset() {
        return window_state_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*window_state_event)(GtkWidget *, GdkEventWindowState *)
     * }
     */
    public static MemorySegment window_state_event(MemorySegment struct) {
        return struct.get(window_state_event$LAYOUT, window_state_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*window_state_event)(GtkWidget *, GdkEventWindowState *)
     * }
     */
    public static void window_state_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(window_state_event$LAYOUT, window_state_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*damage_event)(GtkWidget *, GdkEventExpose *)
     * }
     */
    public class damage_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(damage_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(damage_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout damage_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("damage_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*damage_event)(GtkWidget *, GdkEventExpose *)
     * }
     */
    public static final AddressLayout damage_event$layout() {
        return damage_event$LAYOUT;
    }

    private static final long damage_event$OFFSET = 568;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*damage_event)(GtkWidget *, GdkEventExpose *)
     * }
     */
    public static final long damage_event$offset() {
        return damage_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*damage_event)(GtkWidget *, GdkEventExpose *)
     * }
     */
    public static MemorySegment damage_event(MemorySegment struct) {
        return struct.get(damage_event$LAYOUT, damage_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*damage_event)(GtkWidget *, GdkEventExpose *)
     * }
     */
    public static void damage_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(damage_event$LAYOUT, damage_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*grab_broken_event)(GtkWidget *, GdkEventGrabBroken *)
     * }
     */
    public class grab_broken_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(grab_broken_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(grab_broken_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout grab_broken_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("grab_broken_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*grab_broken_event)(GtkWidget *, GdkEventGrabBroken *)
     * }
     */
    public static final AddressLayout grab_broken_event$layout() {
        return grab_broken_event$LAYOUT;
    }

    private static final long grab_broken_event$OFFSET = 576;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*grab_broken_event)(GtkWidget *, GdkEventGrabBroken *)
     * }
     */
    public static final long grab_broken_event$offset() {
        return grab_broken_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*grab_broken_event)(GtkWidget *, GdkEventGrabBroken *)
     * }
     */
    public static MemorySegment grab_broken_event(MemorySegment struct) {
        return struct.get(grab_broken_event$LAYOUT, grab_broken_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*grab_broken_event)(GtkWidget *, GdkEventGrabBroken *)
     * }
     */
    public static void grab_broken_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(grab_broken_event$LAYOUT, grab_broken_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*selection_get)(GtkWidget *, GtkSelectionData *, guint, guint)
     * }
     */
    public class selection_get {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(selection_get.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(selection_get.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout selection_get$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("selection_get"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*selection_get)(GtkWidget *, GtkSelectionData *, guint, guint)
     * }
     */
    public static final AddressLayout selection_get$layout() {
        return selection_get$LAYOUT;
    }

    private static final long selection_get$OFFSET = 584;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*selection_get)(GtkWidget *, GtkSelectionData *, guint, guint)
     * }
     */
    public static final long selection_get$offset() {
        return selection_get$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*selection_get)(GtkWidget *, GtkSelectionData *, guint, guint)
     * }
     */
    public static MemorySegment selection_get(MemorySegment struct) {
        return struct.get(selection_get$LAYOUT, selection_get$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*selection_get)(GtkWidget *, GtkSelectionData *, guint, guint)
     * }
     */
    public static void selection_get(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(selection_get$LAYOUT, selection_get$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*selection_received)(GtkWidget *, GtkSelectionData *, guint)
     * }
     */
    public class selection_received {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(selection_received.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(selection_received.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout selection_received$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("selection_received"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*selection_received)(GtkWidget *, GtkSelectionData *, guint)
     * }
     */
    public static final AddressLayout selection_received$layout() {
        return selection_received$LAYOUT;
    }

    private static final long selection_received$OFFSET = 592;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*selection_received)(GtkWidget *, GtkSelectionData *, guint)
     * }
     */
    public static final long selection_received$offset() {
        return selection_received$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*selection_received)(GtkWidget *, GtkSelectionData *, guint)
     * }
     */
    public static MemorySegment selection_received(MemorySegment struct) {
        return struct.get(selection_received$LAYOUT, selection_received$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*selection_received)(GtkWidget *, GtkSelectionData *, guint)
     * }
     */
    public static void selection_received(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(selection_received$LAYOUT, selection_received$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*drag_begin)(GtkWidget *, GdkDragContext *)
     * }
     */
    public class drag_begin {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(drag_begin.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(drag_begin.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout drag_begin$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("drag_begin"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*drag_begin)(GtkWidget *, GdkDragContext *)
     * }
     */
    public static final AddressLayout drag_begin$layout() {
        return drag_begin$LAYOUT;
    }

    private static final long drag_begin$OFFSET = 600;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*drag_begin)(GtkWidget *, GdkDragContext *)
     * }
     */
    public static final long drag_begin$offset() {
        return drag_begin$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*drag_begin)(GtkWidget *, GdkDragContext *)
     * }
     */
    public static MemorySegment drag_begin(MemorySegment struct) {
        return struct.get(drag_begin$LAYOUT, drag_begin$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*drag_begin)(GtkWidget *, GdkDragContext *)
     * }
     */
    public static void drag_begin(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(drag_begin$LAYOUT, drag_begin$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*drag_end)(GtkWidget *, GdkDragContext *)
     * }
     */
    public class drag_end {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(drag_end.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(drag_end.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout drag_end$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("drag_end"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*drag_end)(GtkWidget *, GdkDragContext *)
     * }
     */
    public static final AddressLayout drag_end$layout() {
        return drag_end$LAYOUT;
    }

    private static final long drag_end$OFFSET = 608;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*drag_end)(GtkWidget *, GdkDragContext *)
     * }
     */
    public static final long drag_end$offset() {
        return drag_end$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*drag_end)(GtkWidget *, GdkDragContext *)
     * }
     */
    public static MemorySegment drag_end(MemorySegment struct) {
        return struct.get(drag_end$LAYOUT, drag_end$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*drag_end)(GtkWidget *, GdkDragContext *)
     * }
     */
    public static void drag_end(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(drag_end$LAYOUT, drag_end$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*drag_data_get)(GtkWidget *, GdkDragContext *, GtkSelectionData *, guint, guint)
     * }
     */
    public class drag_data_get {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, int _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(drag_data_get.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(drag_data_get.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, int _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout drag_data_get$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("drag_data_get"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*drag_data_get)(GtkWidget *, GdkDragContext *, GtkSelectionData *, guint, guint)
     * }
     */
    public static final AddressLayout drag_data_get$layout() {
        return drag_data_get$LAYOUT;
    }

    private static final long drag_data_get$OFFSET = 616;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*drag_data_get)(GtkWidget *, GdkDragContext *, GtkSelectionData *, guint, guint)
     * }
     */
    public static final long drag_data_get$offset() {
        return drag_data_get$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*drag_data_get)(GtkWidget *, GdkDragContext *, GtkSelectionData *, guint, guint)
     * }
     */
    public static MemorySegment drag_data_get(MemorySegment struct) {
        return struct.get(drag_data_get$LAYOUT, drag_data_get$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*drag_data_get)(GtkWidget *, GdkDragContext *, GtkSelectionData *, guint, guint)
     * }
     */
    public static void drag_data_get(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(drag_data_get$LAYOUT, drag_data_get$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*drag_data_delete)(GtkWidget *, GdkDragContext *)
     * }
     */
    public class drag_data_delete {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(drag_data_delete.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(drag_data_delete.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout drag_data_delete$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("drag_data_delete"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*drag_data_delete)(GtkWidget *, GdkDragContext *)
     * }
     */
    public static final AddressLayout drag_data_delete$layout() {
        return drag_data_delete$LAYOUT;
    }

    private static final long drag_data_delete$OFFSET = 624;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*drag_data_delete)(GtkWidget *, GdkDragContext *)
     * }
     */
    public static final long drag_data_delete$offset() {
        return drag_data_delete$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*drag_data_delete)(GtkWidget *, GdkDragContext *)
     * }
     */
    public static MemorySegment drag_data_delete(MemorySegment struct) {
        return struct.get(drag_data_delete$LAYOUT, drag_data_delete$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*drag_data_delete)(GtkWidget *, GdkDragContext *)
     * }
     */
    public static void drag_data_delete(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(drag_data_delete$LAYOUT, drag_data_delete$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*drag_leave)(GtkWidget *, GdkDragContext *, guint)
     * }
     */
    public class drag_leave {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(drag_leave.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(drag_leave.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout drag_leave$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("drag_leave"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*drag_leave)(GtkWidget *, GdkDragContext *, guint)
     * }
     */
    public static final AddressLayout drag_leave$layout() {
        return drag_leave$LAYOUT;
    }

    private static final long drag_leave$OFFSET = 632;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*drag_leave)(GtkWidget *, GdkDragContext *, guint)
     * }
     */
    public static final long drag_leave$offset() {
        return drag_leave$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*drag_leave)(GtkWidget *, GdkDragContext *, guint)
     * }
     */
    public static MemorySegment drag_leave(MemorySegment struct) {
        return struct.get(drag_leave$LAYOUT, drag_leave$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*drag_leave)(GtkWidget *, GdkDragContext *, guint)
     * }
     */
    public static void drag_leave(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(drag_leave$LAYOUT, drag_leave$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*drag_motion)(GtkWidget *, GdkDragContext *, gint, gint, guint)
     * }
     */
    public class drag_motion {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, int _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(drag_motion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(drag_motion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, int _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout drag_motion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("drag_motion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*drag_motion)(GtkWidget *, GdkDragContext *, gint, gint, guint)
     * }
     */
    public static final AddressLayout drag_motion$layout() {
        return drag_motion$LAYOUT;
    }

    private static final long drag_motion$OFFSET = 640;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*drag_motion)(GtkWidget *, GdkDragContext *, gint, gint, guint)
     * }
     */
    public static final long drag_motion$offset() {
        return drag_motion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*drag_motion)(GtkWidget *, GdkDragContext *, gint, gint, guint)
     * }
     */
    public static MemorySegment drag_motion(MemorySegment struct) {
        return struct.get(drag_motion$LAYOUT, drag_motion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*drag_motion)(GtkWidget *, GdkDragContext *, gint, gint, guint)
     * }
     */
    public static void drag_motion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(drag_motion$LAYOUT, drag_motion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*drag_drop)(GtkWidget *, GdkDragContext *, gint, gint, guint)
     * }
     */
    public class drag_drop {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, int _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(drag_drop.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(drag_drop.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, int _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout drag_drop$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("drag_drop"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*drag_drop)(GtkWidget *, GdkDragContext *, gint, gint, guint)
     * }
     */
    public static final AddressLayout drag_drop$layout() {
        return drag_drop$LAYOUT;
    }

    private static final long drag_drop$OFFSET = 648;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*drag_drop)(GtkWidget *, GdkDragContext *, gint, gint, guint)
     * }
     */
    public static final long drag_drop$offset() {
        return drag_drop$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*drag_drop)(GtkWidget *, GdkDragContext *, gint, gint, guint)
     * }
     */
    public static MemorySegment drag_drop(MemorySegment struct) {
        return struct.get(drag_drop$LAYOUT, drag_drop$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*drag_drop)(GtkWidget *, GdkDragContext *, gint, gint, guint)
     * }
     */
    public static void drag_drop(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(drag_drop$LAYOUT, drag_drop$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*drag_data_received)(GtkWidget *, GdkDragContext *, gint, gint, GtkSelectionData *, guint, guint)
     * }
     */
    public class drag_data_received {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, int _x5, int _x6);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(drag_data_received.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(drag_data_received.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, int _x5, int _x6) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout drag_data_received$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("drag_data_received"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*drag_data_received)(GtkWidget *, GdkDragContext *, gint, gint, GtkSelectionData *, guint, guint)
     * }
     */
    public static final AddressLayout drag_data_received$layout() {
        return drag_data_received$LAYOUT;
    }

    private static final long drag_data_received$OFFSET = 656;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*drag_data_received)(GtkWidget *, GdkDragContext *, gint, gint, GtkSelectionData *, guint, guint)
     * }
     */
    public static final long drag_data_received$offset() {
        return drag_data_received$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*drag_data_received)(GtkWidget *, GdkDragContext *, gint, gint, GtkSelectionData *, guint, guint)
     * }
     */
    public static MemorySegment drag_data_received(MemorySegment struct) {
        return struct.get(drag_data_received$LAYOUT, drag_data_received$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*drag_data_received)(GtkWidget *, GdkDragContext *, gint, gint, GtkSelectionData *, guint, guint)
     * }
     */
    public static void drag_data_received(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(drag_data_received$LAYOUT, drag_data_received$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*drag_failed)(GtkWidget *, GdkDragContext *, GtkDragResult)
     * }
     */
    public class drag_failed {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(drag_failed.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(drag_failed.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout drag_failed$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("drag_failed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*drag_failed)(GtkWidget *, GdkDragContext *, GtkDragResult)
     * }
     */
    public static final AddressLayout drag_failed$layout() {
        return drag_failed$LAYOUT;
    }

    private static final long drag_failed$OFFSET = 664;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*drag_failed)(GtkWidget *, GdkDragContext *, GtkDragResult)
     * }
     */
    public static final long drag_failed$offset() {
        return drag_failed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*drag_failed)(GtkWidget *, GdkDragContext *, GtkDragResult)
     * }
     */
    public static MemorySegment drag_failed(MemorySegment struct) {
        return struct.get(drag_failed$LAYOUT, drag_failed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*drag_failed)(GtkWidget *, GdkDragContext *, GtkDragResult)
     * }
     */
    public static void drag_failed(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(drag_failed$LAYOUT, drag_failed$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*popup_menu)(GtkWidget *)
     * }
     */
    public class popup_menu {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(popup_menu.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(popup_menu.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout popup_menu$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("popup_menu"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*popup_menu)(GtkWidget *)
     * }
     */
    public static final AddressLayout popup_menu$layout() {
        return popup_menu$LAYOUT;
    }

    private static final long popup_menu$OFFSET = 672;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*popup_menu)(GtkWidget *)
     * }
     */
    public static final long popup_menu$offset() {
        return popup_menu$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*popup_menu)(GtkWidget *)
     * }
     */
    public static MemorySegment popup_menu(MemorySegment struct) {
        return struct.get(popup_menu$LAYOUT, popup_menu$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*popup_menu)(GtkWidget *)
     * }
     */
    public static void popup_menu(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(popup_menu$LAYOUT, popup_menu$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*show_help)(GtkWidget *, GtkWidgetHelpType)
     * }
     */
    public class show_help {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(show_help.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(show_help.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout show_help$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("show_help"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*show_help)(GtkWidget *, GtkWidgetHelpType)
     * }
     */
    public static final AddressLayout show_help$layout() {
        return show_help$LAYOUT;
    }

    private static final long show_help$OFFSET = 680;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*show_help)(GtkWidget *, GtkWidgetHelpType)
     * }
     */
    public static final long show_help$offset() {
        return show_help$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*show_help)(GtkWidget *, GtkWidgetHelpType)
     * }
     */
    public static MemorySegment show_help(MemorySegment struct) {
        return struct.get(show_help$LAYOUT, show_help$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*show_help)(GtkWidget *, GtkWidgetHelpType)
     * }
     */
    public static void show_help(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(show_help$LAYOUT, show_help$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * AtkObject *(*get_accessible)(GtkWidget *)
     * }
     */
    public class get_accessible {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_accessible.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_accessible.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_accessible$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_accessible"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AtkObject *(*get_accessible)(GtkWidget *)
     * }
     */
    public static final AddressLayout get_accessible$layout() {
        return get_accessible$LAYOUT;
    }

    private static final long get_accessible$OFFSET = 688;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AtkObject *(*get_accessible)(GtkWidget *)
     * }
     */
    public static final long get_accessible$offset() {
        return get_accessible$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AtkObject *(*get_accessible)(GtkWidget *)
     * }
     */
    public static MemorySegment get_accessible(MemorySegment struct) {
        return struct.get(get_accessible$LAYOUT, get_accessible$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AtkObject *(*get_accessible)(GtkWidget *)
     * }
     */
    public static void get_accessible(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_accessible$LAYOUT, get_accessible$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*screen_changed)(GtkWidget *, GdkScreen *)
     * }
     */
    public class screen_changed {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(screen_changed.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(screen_changed.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout screen_changed$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("screen_changed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*screen_changed)(GtkWidget *, GdkScreen *)
     * }
     */
    public static final AddressLayout screen_changed$layout() {
        return screen_changed$LAYOUT;
    }

    private static final long screen_changed$OFFSET = 696;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*screen_changed)(GtkWidget *, GdkScreen *)
     * }
     */
    public static final long screen_changed$offset() {
        return screen_changed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*screen_changed)(GtkWidget *, GdkScreen *)
     * }
     */
    public static MemorySegment screen_changed(MemorySegment struct) {
        return struct.get(screen_changed$LAYOUT, screen_changed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*screen_changed)(GtkWidget *, GdkScreen *)
     * }
     */
    public static void screen_changed(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(screen_changed$LAYOUT, screen_changed$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*can_activate_accel)(GtkWidget *, guint)
     * }
     */
    public class can_activate_accel {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(can_activate_accel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(can_activate_accel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout can_activate_accel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("can_activate_accel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*can_activate_accel)(GtkWidget *, guint)
     * }
     */
    public static final AddressLayout can_activate_accel$layout() {
        return can_activate_accel$LAYOUT;
    }

    private static final long can_activate_accel$OFFSET = 704;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*can_activate_accel)(GtkWidget *, guint)
     * }
     */
    public static final long can_activate_accel$offset() {
        return can_activate_accel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*can_activate_accel)(GtkWidget *, guint)
     * }
     */
    public static MemorySegment can_activate_accel(MemorySegment struct) {
        return struct.get(can_activate_accel$LAYOUT, can_activate_accel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*can_activate_accel)(GtkWidget *, guint)
     * }
     */
    public static void can_activate_accel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(can_activate_accel$LAYOUT, can_activate_accel$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*composited_changed)(GtkWidget *)
     * }
     */
    public class composited_changed {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(composited_changed.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(composited_changed.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout composited_changed$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("composited_changed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*composited_changed)(GtkWidget *)
     * }
     */
    public static final AddressLayout composited_changed$layout() {
        return composited_changed$LAYOUT;
    }

    private static final long composited_changed$OFFSET = 712;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*composited_changed)(GtkWidget *)
     * }
     */
    public static final long composited_changed$offset() {
        return composited_changed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*composited_changed)(GtkWidget *)
     * }
     */
    public static MemorySegment composited_changed(MemorySegment struct) {
        return struct.get(composited_changed$LAYOUT, composited_changed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*composited_changed)(GtkWidget *)
     * }
     */
    public static void composited_changed(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(composited_changed$LAYOUT, composited_changed$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*query_tooltip)(GtkWidget *, gint, gint, gboolean, GtkTooltip *)
     * }
     */
    public class query_tooltip {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(query_tooltip.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(query_tooltip.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout query_tooltip$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("query_tooltip"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*query_tooltip)(GtkWidget *, gint, gint, gboolean, GtkTooltip *)
     * }
     */
    public static final AddressLayout query_tooltip$layout() {
        return query_tooltip$LAYOUT;
    }

    private static final long query_tooltip$OFFSET = 720;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*query_tooltip)(GtkWidget *, gint, gint, gboolean, GtkTooltip *)
     * }
     */
    public static final long query_tooltip$offset() {
        return query_tooltip$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*query_tooltip)(GtkWidget *, gint, gint, gboolean, GtkTooltip *)
     * }
     */
    public static MemorySegment query_tooltip(MemorySegment struct) {
        return struct.get(query_tooltip$LAYOUT, query_tooltip$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*query_tooltip)(GtkWidget *, gint, gint, gboolean, GtkTooltip *)
     * }
     */
    public static void query_tooltip(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(query_tooltip$LAYOUT, query_tooltip$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*compute_expand)(GtkWidget *, gboolean *, gboolean *)
     * }
     */
    public class compute_expand {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(compute_expand.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(compute_expand.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout compute_expand$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("compute_expand"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*compute_expand)(GtkWidget *, gboolean *, gboolean *)
     * }
     */
    public static final AddressLayout compute_expand$layout() {
        return compute_expand$LAYOUT;
    }

    private static final long compute_expand$OFFSET = 728;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*compute_expand)(GtkWidget *, gboolean *, gboolean *)
     * }
     */
    public static final long compute_expand$offset() {
        return compute_expand$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*compute_expand)(GtkWidget *, gboolean *, gboolean *)
     * }
     */
    public static MemorySegment compute_expand(MemorySegment struct) {
        return struct.get(compute_expand$LAYOUT, compute_expand$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*compute_expand)(GtkWidget *, gboolean *, gboolean *)
     * }
     */
    public static void compute_expand(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(compute_expand$LAYOUT, compute_expand$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*adjust_size_request)(GtkWidget *, GtkOrientation, gint *, gint *)
     * }
     */
    public class adjust_size_request {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(adjust_size_request.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(adjust_size_request.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout adjust_size_request$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("adjust_size_request"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*adjust_size_request)(GtkWidget *, GtkOrientation, gint *, gint *)
     * }
     */
    public static final AddressLayout adjust_size_request$layout() {
        return adjust_size_request$LAYOUT;
    }

    private static final long adjust_size_request$OFFSET = 736;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*adjust_size_request)(GtkWidget *, GtkOrientation, gint *, gint *)
     * }
     */
    public static final long adjust_size_request$offset() {
        return adjust_size_request$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*adjust_size_request)(GtkWidget *, GtkOrientation, gint *, gint *)
     * }
     */
    public static MemorySegment adjust_size_request(MemorySegment struct) {
        return struct.get(adjust_size_request$LAYOUT, adjust_size_request$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*adjust_size_request)(GtkWidget *, GtkOrientation, gint *, gint *)
     * }
     */
    public static void adjust_size_request(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(adjust_size_request$LAYOUT, adjust_size_request$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*adjust_size_allocation)(GtkWidget *, GtkOrientation, gint *, gint *, gint *, gint *)
     * }
     */
    public class adjust_size_allocation {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(adjust_size_allocation.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(adjust_size_allocation.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout adjust_size_allocation$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("adjust_size_allocation"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*adjust_size_allocation)(GtkWidget *, GtkOrientation, gint *, gint *, gint *, gint *)
     * }
     */
    public static final AddressLayout adjust_size_allocation$layout() {
        return adjust_size_allocation$LAYOUT;
    }

    private static final long adjust_size_allocation$OFFSET = 744;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*adjust_size_allocation)(GtkWidget *, GtkOrientation, gint *, gint *, gint *, gint *)
     * }
     */
    public static final long adjust_size_allocation$offset() {
        return adjust_size_allocation$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*adjust_size_allocation)(GtkWidget *, GtkOrientation, gint *, gint *, gint *, gint *)
     * }
     */
    public static MemorySegment adjust_size_allocation(MemorySegment struct) {
        return struct.get(adjust_size_allocation$LAYOUT, adjust_size_allocation$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*adjust_size_allocation)(GtkWidget *, GtkOrientation, gint *, gint *, gint *, gint *)
     * }
     */
    public static void adjust_size_allocation(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(adjust_size_allocation$LAYOUT, adjust_size_allocation$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*style_updated)(GtkWidget *)
     * }
     */
    public class style_updated {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(style_updated.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(style_updated.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout style_updated$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("style_updated"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*style_updated)(GtkWidget *)
     * }
     */
    public static final AddressLayout style_updated$layout() {
        return style_updated$LAYOUT;
    }

    private static final long style_updated$OFFSET = 752;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*style_updated)(GtkWidget *)
     * }
     */
    public static final long style_updated$offset() {
        return style_updated$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*style_updated)(GtkWidget *)
     * }
     */
    public static MemorySegment style_updated(MemorySegment struct) {
        return struct.get(style_updated$LAYOUT, style_updated$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*style_updated)(GtkWidget *)
     * }
     */
    public static void style_updated(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(style_updated$LAYOUT, style_updated$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*touch_event)(GtkWidget *, GdkEventTouch *)
     * }
     */
    public class touch_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(touch_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(touch_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout touch_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("touch_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*touch_event)(GtkWidget *, GdkEventTouch *)
     * }
     */
    public static final AddressLayout touch_event$layout() {
        return touch_event$LAYOUT;
    }

    private static final long touch_event$OFFSET = 760;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*touch_event)(GtkWidget *, GdkEventTouch *)
     * }
     */
    public static final long touch_event$offset() {
        return touch_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*touch_event)(GtkWidget *, GdkEventTouch *)
     * }
     */
    public static MemorySegment touch_event(MemorySegment struct) {
        return struct.get(touch_event$LAYOUT, touch_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*touch_event)(GtkWidget *, GdkEventTouch *)
     * }
     */
    public static void touch_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(touch_event$LAYOUT, touch_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*get_preferred_height_and_baseline_for_width)(GtkWidget *, gint, gint *, gint *, gint *, gint *)
     * }
     */
    public class get_preferred_height_and_baseline_for_width {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_preferred_height_and_baseline_for_width.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_preferred_height_and_baseline_for_width.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_preferred_height_and_baseline_for_width$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_preferred_height_and_baseline_for_width"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*get_preferred_height_and_baseline_for_width)(GtkWidget *, gint, gint *, gint *, gint *, gint *)
     * }
     */
    public static final AddressLayout get_preferred_height_and_baseline_for_width$layout() {
        return get_preferred_height_and_baseline_for_width$LAYOUT;
    }

    private static final long get_preferred_height_and_baseline_for_width$OFFSET = 768;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*get_preferred_height_and_baseline_for_width)(GtkWidget *, gint, gint *, gint *, gint *, gint *)
     * }
     */
    public static final long get_preferred_height_and_baseline_for_width$offset() {
        return get_preferred_height_and_baseline_for_width$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*get_preferred_height_and_baseline_for_width)(GtkWidget *, gint, gint *, gint *, gint *, gint *)
     * }
     */
    public static MemorySegment get_preferred_height_and_baseline_for_width(MemorySegment struct) {
        return struct.get(get_preferred_height_and_baseline_for_width$LAYOUT, get_preferred_height_and_baseline_for_width$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*get_preferred_height_and_baseline_for_width)(GtkWidget *, gint, gint *, gint *, gint *, gint *)
     * }
     */
    public static void get_preferred_height_and_baseline_for_width(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_preferred_height_and_baseline_for_width$LAYOUT, get_preferred_height_and_baseline_for_width$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*adjust_baseline_request)(GtkWidget *, gint *, gint *)
     * }
     */
    public class adjust_baseline_request {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(adjust_baseline_request.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(adjust_baseline_request.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout adjust_baseline_request$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("adjust_baseline_request"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*adjust_baseline_request)(GtkWidget *, gint *, gint *)
     * }
     */
    public static final AddressLayout adjust_baseline_request$layout() {
        return adjust_baseline_request$LAYOUT;
    }

    private static final long adjust_baseline_request$OFFSET = 776;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*adjust_baseline_request)(GtkWidget *, gint *, gint *)
     * }
     */
    public static final long adjust_baseline_request$offset() {
        return adjust_baseline_request$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*adjust_baseline_request)(GtkWidget *, gint *, gint *)
     * }
     */
    public static MemorySegment adjust_baseline_request(MemorySegment struct) {
        return struct.get(adjust_baseline_request$LAYOUT, adjust_baseline_request$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*adjust_baseline_request)(GtkWidget *, gint *, gint *)
     * }
     */
    public static void adjust_baseline_request(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(adjust_baseline_request$LAYOUT, adjust_baseline_request$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*adjust_baseline_allocation)(GtkWidget *, gint *)
     * }
     */
    public class adjust_baseline_allocation {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(adjust_baseline_allocation.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(adjust_baseline_allocation.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout adjust_baseline_allocation$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("adjust_baseline_allocation"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*adjust_baseline_allocation)(GtkWidget *, gint *)
     * }
     */
    public static final AddressLayout adjust_baseline_allocation$layout() {
        return adjust_baseline_allocation$LAYOUT;
    }

    private static final long adjust_baseline_allocation$OFFSET = 784;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*adjust_baseline_allocation)(GtkWidget *, gint *)
     * }
     */
    public static final long adjust_baseline_allocation$offset() {
        return adjust_baseline_allocation$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*adjust_baseline_allocation)(GtkWidget *, gint *)
     * }
     */
    public static MemorySegment adjust_baseline_allocation(MemorySegment struct) {
        return struct.get(adjust_baseline_allocation$LAYOUT, adjust_baseline_allocation$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*adjust_baseline_allocation)(GtkWidget *, gint *)
     * }
     */
    public static void adjust_baseline_allocation(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(adjust_baseline_allocation$LAYOUT, adjust_baseline_allocation$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*queue_draw_region)(GtkWidget *, const cairo_region_t *)
     * }
     */
    public class queue_draw_region {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(queue_draw_region.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(queue_draw_region.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout queue_draw_region$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("queue_draw_region"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*queue_draw_region)(GtkWidget *, const cairo_region_t *)
     * }
     */
    public static final AddressLayout queue_draw_region$layout() {
        return queue_draw_region$LAYOUT;
    }

    private static final long queue_draw_region$OFFSET = 792;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*queue_draw_region)(GtkWidget *, const cairo_region_t *)
     * }
     */
    public static final long queue_draw_region$offset() {
        return queue_draw_region$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*queue_draw_region)(GtkWidget *, const cairo_region_t *)
     * }
     */
    public static MemorySegment queue_draw_region(MemorySegment struct) {
        return struct.get(queue_draw_region$LAYOUT, queue_draw_region$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*queue_draw_region)(GtkWidget *, const cairo_region_t *)
     * }
     */
    public static void queue_draw_region(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(queue_draw_region$LAYOUT, queue_draw_region$OFFSET, fieldValue);
    }

    private static final AddressLayout priv$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("priv"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GtkWidgetClassPrivate *priv
     * }
     */
    public static final AddressLayout priv$layout() {
        return priv$LAYOUT;
    }

    private static final long priv$OFFSET = 800;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GtkWidgetClassPrivate *priv
     * }
     */
    public static final long priv$offset() {
        return priv$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GtkWidgetClassPrivate *priv
     * }
     */
    public static MemorySegment priv(MemorySegment struct) {
        return struct.get(priv$LAYOUT, priv$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GtkWidgetClassPrivate *priv
     * }
     */
    public static void priv(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(priv$LAYOUT, priv$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*_gtk_reserved6)(void)
     * }
     */
    public class _gtk_reserved6 {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid();

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(_gtk_reserved6.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_gtk_reserved6.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr) {
            try {
                 DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _gtk_reserved6$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_gtk_reserved6"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*_gtk_reserved6)(void)
     * }
     */
    public static final AddressLayout _gtk_reserved6$layout() {
        return _gtk_reserved6$LAYOUT;
    }

    private static final long _gtk_reserved6$OFFSET = 808;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*_gtk_reserved6)(void)
     * }
     */
    public static final long _gtk_reserved6$offset() {
        return _gtk_reserved6$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*_gtk_reserved6)(void)
     * }
     */
    public static MemorySegment _gtk_reserved6(MemorySegment struct) {
        return struct.get(_gtk_reserved6$LAYOUT, _gtk_reserved6$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*_gtk_reserved6)(void)
     * }
     */
    public static void _gtk_reserved6(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_gtk_reserved6$LAYOUT, _gtk_reserved6$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*_gtk_reserved7)(void)
     * }
     */
    public class _gtk_reserved7 {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid();

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(_gtk_reserved7.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_gtk_reserved7.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr) {
            try {
                 DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _gtk_reserved7$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_gtk_reserved7"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*_gtk_reserved7)(void)
     * }
     */
    public static final AddressLayout _gtk_reserved7$layout() {
        return _gtk_reserved7$LAYOUT;
    }

    private static final long _gtk_reserved7$OFFSET = 816;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*_gtk_reserved7)(void)
     * }
     */
    public static final long _gtk_reserved7$offset() {
        return _gtk_reserved7$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*_gtk_reserved7)(void)
     * }
     */
    public static MemorySegment _gtk_reserved7(MemorySegment struct) {
        return struct.get(_gtk_reserved7$LAYOUT, _gtk_reserved7$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*_gtk_reserved7)(void)
     * }
     */
    public static void _gtk_reserved7(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_gtk_reserved7$LAYOUT, _gtk_reserved7$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

