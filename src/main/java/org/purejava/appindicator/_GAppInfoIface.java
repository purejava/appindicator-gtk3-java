// Generated by jextract

package org.purejava.appindicator;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct _GAppInfoIface {
 *     GTypeInterface g_iface;
 *     GAppInfo *(*dup)(GAppInfo *);
 *     gboolean (*equal)(GAppInfo *, GAppInfo *);
 *     const char *(*get_id)(GAppInfo *);
 *     const char *(*get_name)(GAppInfo *);
 *     const char *(*get_description)(GAppInfo *);
 *     const char *(*get_executable)(GAppInfo *);
 *     GIcon *(*get_icon)(GAppInfo *);
 *     gboolean (*launch)(GAppInfo *, GList *, GAppLaunchContext *, GError **);
 *     gboolean (*supports_uris)(GAppInfo *);
 *     gboolean (*supports_files)(GAppInfo *);
 *     gboolean (*launch_uris)(GAppInfo *, GList *, GAppLaunchContext *, GError **);
 *     gboolean (*should_show)(GAppInfo *);
 *     gboolean (*set_as_default_for_type)(GAppInfo *, const char *, GError **);
 *     gboolean (*set_as_default_for_extension)(GAppInfo *, const char *, GError **);
 *     gboolean (*add_supports_type)(GAppInfo *, const char *, GError **);
 *     gboolean (*can_remove_supports_type)(GAppInfo *);
 *     gboolean (*remove_supports_type)(GAppInfo *, const char *, GError **);
 *     gboolean (*can_delete)(GAppInfo *);
 *     gboolean (*do_delete)(GAppInfo *);
 *     const char *(*get_commandline)(GAppInfo *);
 *     const char *(*get_display_name)(GAppInfo *);
 *     gboolean (*set_as_last_used_for_type)(GAppInfo *, const char *, GError **);
 *     const char **(*get_supported_types)(GAppInfo *);
 *     void (*launch_uris_async)(GAppInfo *, GList *, GAppLaunchContext *, GCancellable *, GAsyncReadyCallback, gpointer);
 *     gboolean (*launch_uris_finish)(GAppInfo *, GAsyncResult *, GError **);
 * }
 * }
 */
public class _GAppInfoIface {

    _GAppInfoIface() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        _GTypeInterface.layout().withName("g_iface"),
        app_indicator_h.C_POINTER.withName("dup"),
        app_indicator_h.C_POINTER.withName("equal"),
        app_indicator_h.C_POINTER.withName("get_id"),
        app_indicator_h.C_POINTER.withName("get_name"),
        app_indicator_h.C_POINTER.withName("get_description"),
        app_indicator_h.C_POINTER.withName("get_executable"),
        app_indicator_h.C_POINTER.withName("get_icon"),
        app_indicator_h.C_POINTER.withName("launch"),
        app_indicator_h.C_POINTER.withName("supports_uris"),
        app_indicator_h.C_POINTER.withName("supports_files"),
        app_indicator_h.C_POINTER.withName("launch_uris"),
        app_indicator_h.C_POINTER.withName("should_show"),
        app_indicator_h.C_POINTER.withName("set_as_default_for_type"),
        app_indicator_h.C_POINTER.withName("set_as_default_for_extension"),
        app_indicator_h.C_POINTER.withName("add_supports_type"),
        app_indicator_h.C_POINTER.withName("can_remove_supports_type"),
        app_indicator_h.C_POINTER.withName("remove_supports_type"),
        app_indicator_h.C_POINTER.withName("can_delete"),
        app_indicator_h.C_POINTER.withName("do_delete"),
        app_indicator_h.C_POINTER.withName("get_commandline"),
        app_indicator_h.C_POINTER.withName("get_display_name"),
        app_indicator_h.C_POINTER.withName("set_as_last_used_for_type"),
        app_indicator_h.C_POINTER.withName("get_supported_types"),
        app_indicator_h.C_POINTER.withName("launch_uris_async"),
        app_indicator_h.C_POINTER.withName("launch_uris_finish")
    ).withName("_GAppInfoIface");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final GroupLayout g_iface$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("g_iface"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GTypeInterface g_iface
     * }
     */
    public static final GroupLayout g_iface$layout() {
        return g_iface$LAYOUT;
    }

    private static final long g_iface$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GTypeInterface g_iface
     * }
     */
    public static final long g_iface$offset() {
        return g_iface$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GTypeInterface g_iface
     * }
     */
    public static MemorySegment g_iface(MemorySegment struct) {
        return struct.asSlice(g_iface$OFFSET, g_iface$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GTypeInterface g_iface
     * }
     */
    public static void g_iface(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, g_iface$OFFSET, g_iface$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * GAppInfo *(*dup)(GAppInfo *)
     * }
     */
    public class dup {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(dup.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(dup.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout dup$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("dup"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GAppInfo *(*dup)(GAppInfo *)
     * }
     */
    public static final AddressLayout dup$layout() {
        return dup$LAYOUT;
    }

    private static final long dup$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GAppInfo *(*dup)(GAppInfo *)
     * }
     */
    public static final long dup$offset() {
        return dup$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GAppInfo *(*dup)(GAppInfo *)
     * }
     */
    public static MemorySegment dup(MemorySegment struct) {
        return struct.get(dup$LAYOUT, dup$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GAppInfo *(*dup)(GAppInfo *)
     * }
     */
    public static void dup(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(dup$LAYOUT, dup$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*equal)(GAppInfo *, GAppInfo *)
     * }
     */
    public class equal {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(equal.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(equal.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout equal$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("equal"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*equal)(GAppInfo *, GAppInfo *)
     * }
     */
    public static final AddressLayout equal$layout() {
        return equal$LAYOUT;
    }

    private static final long equal$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*equal)(GAppInfo *, GAppInfo *)
     * }
     */
    public static final long equal$offset() {
        return equal$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*equal)(GAppInfo *, GAppInfo *)
     * }
     */
    public static MemorySegment equal(MemorySegment struct) {
        return struct.get(equal$LAYOUT, equal$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*equal)(GAppInfo *, GAppInfo *)
     * }
     */
    public static void equal(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(equal$LAYOUT, equal$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const char *(*get_id)(GAppInfo *)
     * }
     */
    public class get_id {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_id.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_id.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_id$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_id"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *(*get_id)(GAppInfo *)
     * }
     */
    public static final AddressLayout get_id$layout() {
        return get_id$LAYOUT;
    }

    private static final long get_id$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *(*get_id)(GAppInfo *)
     * }
     */
    public static final long get_id$offset() {
        return get_id$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *(*get_id)(GAppInfo *)
     * }
     */
    public static MemorySegment get_id(MemorySegment struct) {
        return struct.get(get_id$LAYOUT, get_id$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *(*get_id)(GAppInfo *)
     * }
     */
    public static void get_id(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_id$LAYOUT, get_id$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const char *(*get_name)(GAppInfo *)
     * }
     */
    public class get_name {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_name.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_name.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_name$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_name"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *(*get_name)(GAppInfo *)
     * }
     */
    public static final AddressLayout get_name$layout() {
        return get_name$LAYOUT;
    }

    private static final long get_name$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *(*get_name)(GAppInfo *)
     * }
     */
    public static final long get_name$offset() {
        return get_name$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *(*get_name)(GAppInfo *)
     * }
     */
    public static MemorySegment get_name(MemorySegment struct) {
        return struct.get(get_name$LAYOUT, get_name$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *(*get_name)(GAppInfo *)
     * }
     */
    public static void get_name(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_name$LAYOUT, get_name$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const char *(*get_description)(GAppInfo *)
     * }
     */
    public class get_description {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_description.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_description.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_description$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_description"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *(*get_description)(GAppInfo *)
     * }
     */
    public static final AddressLayout get_description$layout() {
        return get_description$LAYOUT;
    }

    private static final long get_description$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *(*get_description)(GAppInfo *)
     * }
     */
    public static final long get_description$offset() {
        return get_description$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *(*get_description)(GAppInfo *)
     * }
     */
    public static MemorySegment get_description(MemorySegment struct) {
        return struct.get(get_description$LAYOUT, get_description$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *(*get_description)(GAppInfo *)
     * }
     */
    public static void get_description(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_description$LAYOUT, get_description$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const char *(*get_executable)(GAppInfo *)
     * }
     */
    public class get_executable {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_executable.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_executable.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_executable$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_executable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *(*get_executable)(GAppInfo *)
     * }
     */
    public static final AddressLayout get_executable$layout() {
        return get_executable$LAYOUT;
    }

    private static final long get_executable$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *(*get_executable)(GAppInfo *)
     * }
     */
    public static final long get_executable$offset() {
        return get_executable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *(*get_executable)(GAppInfo *)
     * }
     */
    public static MemorySegment get_executable(MemorySegment struct) {
        return struct.get(get_executable$LAYOUT, get_executable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *(*get_executable)(GAppInfo *)
     * }
     */
    public static void get_executable(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_executable$LAYOUT, get_executable$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GIcon *(*get_icon)(GAppInfo *)
     * }
     */
    public class get_icon {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_icon.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_icon.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_icon$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_icon"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GIcon *(*get_icon)(GAppInfo *)
     * }
     */
    public static final AddressLayout get_icon$layout() {
        return get_icon$LAYOUT;
    }

    private static final long get_icon$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GIcon *(*get_icon)(GAppInfo *)
     * }
     */
    public static final long get_icon$offset() {
        return get_icon$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GIcon *(*get_icon)(GAppInfo *)
     * }
     */
    public static MemorySegment get_icon(MemorySegment struct) {
        return struct.get(get_icon$LAYOUT, get_icon$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GIcon *(*get_icon)(GAppInfo *)
     * }
     */
    public static void get_icon(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_icon$LAYOUT, get_icon$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*launch)(GAppInfo *, GList *, GAppLaunchContext *, GError **)
     * }
     */
    public class launch {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(launch.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(launch.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout launch$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("launch"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*launch)(GAppInfo *, GList *, GAppLaunchContext *, GError **)
     * }
     */
    public static final AddressLayout launch$layout() {
        return launch$LAYOUT;
    }

    private static final long launch$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*launch)(GAppInfo *, GList *, GAppLaunchContext *, GError **)
     * }
     */
    public static final long launch$offset() {
        return launch$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*launch)(GAppInfo *, GList *, GAppLaunchContext *, GError **)
     * }
     */
    public static MemorySegment launch(MemorySegment struct) {
        return struct.get(launch$LAYOUT, launch$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*launch)(GAppInfo *, GList *, GAppLaunchContext *, GError **)
     * }
     */
    public static void launch(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(launch$LAYOUT, launch$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*supports_uris)(GAppInfo *)
     * }
     */
    public class supports_uris {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(supports_uris.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(supports_uris.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout supports_uris$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("supports_uris"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*supports_uris)(GAppInfo *)
     * }
     */
    public static final AddressLayout supports_uris$layout() {
        return supports_uris$LAYOUT;
    }

    private static final long supports_uris$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*supports_uris)(GAppInfo *)
     * }
     */
    public static final long supports_uris$offset() {
        return supports_uris$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*supports_uris)(GAppInfo *)
     * }
     */
    public static MemorySegment supports_uris(MemorySegment struct) {
        return struct.get(supports_uris$LAYOUT, supports_uris$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*supports_uris)(GAppInfo *)
     * }
     */
    public static void supports_uris(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(supports_uris$LAYOUT, supports_uris$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*supports_files)(GAppInfo *)
     * }
     */
    public class supports_files {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(supports_files.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(supports_files.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout supports_files$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("supports_files"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*supports_files)(GAppInfo *)
     * }
     */
    public static final AddressLayout supports_files$layout() {
        return supports_files$LAYOUT;
    }

    private static final long supports_files$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*supports_files)(GAppInfo *)
     * }
     */
    public static final long supports_files$offset() {
        return supports_files$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*supports_files)(GAppInfo *)
     * }
     */
    public static MemorySegment supports_files(MemorySegment struct) {
        return struct.get(supports_files$LAYOUT, supports_files$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*supports_files)(GAppInfo *)
     * }
     */
    public static void supports_files(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(supports_files$LAYOUT, supports_files$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*launch_uris)(GAppInfo *, GList *, GAppLaunchContext *, GError **)
     * }
     */
    public class launch_uris {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(launch_uris.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(launch_uris.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout launch_uris$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("launch_uris"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*launch_uris)(GAppInfo *, GList *, GAppLaunchContext *, GError **)
     * }
     */
    public static final AddressLayout launch_uris$layout() {
        return launch_uris$LAYOUT;
    }

    private static final long launch_uris$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*launch_uris)(GAppInfo *, GList *, GAppLaunchContext *, GError **)
     * }
     */
    public static final long launch_uris$offset() {
        return launch_uris$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*launch_uris)(GAppInfo *, GList *, GAppLaunchContext *, GError **)
     * }
     */
    public static MemorySegment launch_uris(MemorySegment struct) {
        return struct.get(launch_uris$LAYOUT, launch_uris$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*launch_uris)(GAppInfo *, GList *, GAppLaunchContext *, GError **)
     * }
     */
    public static void launch_uris(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(launch_uris$LAYOUT, launch_uris$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*should_show)(GAppInfo *)
     * }
     */
    public class should_show {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(should_show.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(should_show.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout should_show$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("should_show"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*should_show)(GAppInfo *)
     * }
     */
    public static final AddressLayout should_show$layout() {
        return should_show$LAYOUT;
    }

    private static final long should_show$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*should_show)(GAppInfo *)
     * }
     */
    public static final long should_show$offset() {
        return should_show$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*should_show)(GAppInfo *)
     * }
     */
    public static MemorySegment should_show(MemorySegment struct) {
        return struct.get(should_show$LAYOUT, should_show$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*should_show)(GAppInfo *)
     * }
     */
    public static void should_show(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(should_show$LAYOUT, should_show$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*set_as_default_for_type)(GAppInfo *, const char *, GError **)
     * }
     */
    public class set_as_default_for_type {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(set_as_default_for_type.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(set_as_default_for_type.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_as_default_for_type$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_as_default_for_type"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*set_as_default_for_type)(GAppInfo *, const char *, GError **)
     * }
     */
    public static final AddressLayout set_as_default_for_type$layout() {
        return set_as_default_for_type$LAYOUT;
    }

    private static final long set_as_default_for_type$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*set_as_default_for_type)(GAppInfo *, const char *, GError **)
     * }
     */
    public static final long set_as_default_for_type$offset() {
        return set_as_default_for_type$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*set_as_default_for_type)(GAppInfo *, const char *, GError **)
     * }
     */
    public static MemorySegment set_as_default_for_type(MemorySegment struct) {
        return struct.get(set_as_default_for_type$LAYOUT, set_as_default_for_type$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*set_as_default_for_type)(GAppInfo *, const char *, GError **)
     * }
     */
    public static void set_as_default_for_type(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_as_default_for_type$LAYOUT, set_as_default_for_type$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*set_as_default_for_extension)(GAppInfo *, const char *, GError **)
     * }
     */
    public class set_as_default_for_extension {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(set_as_default_for_extension.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(set_as_default_for_extension.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_as_default_for_extension$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_as_default_for_extension"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*set_as_default_for_extension)(GAppInfo *, const char *, GError **)
     * }
     */
    public static final AddressLayout set_as_default_for_extension$layout() {
        return set_as_default_for_extension$LAYOUT;
    }

    private static final long set_as_default_for_extension$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*set_as_default_for_extension)(GAppInfo *, const char *, GError **)
     * }
     */
    public static final long set_as_default_for_extension$offset() {
        return set_as_default_for_extension$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*set_as_default_for_extension)(GAppInfo *, const char *, GError **)
     * }
     */
    public static MemorySegment set_as_default_for_extension(MemorySegment struct) {
        return struct.get(set_as_default_for_extension$LAYOUT, set_as_default_for_extension$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*set_as_default_for_extension)(GAppInfo *, const char *, GError **)
     * }
     */
    public static void set_as_default_for_extension(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_as_default_for_extension$LAYOUT, set_as_default_for_extension$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*add_supports_type)(GAppInfo *, const char *, GError **)
     * }
     */
    public class add_supports_type {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(add_supports_type.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(add_supports_type.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout add_supports_type$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("add_supports_type"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*add_supports_type)(GAppInfo *, const char *, GError **)
     * }
     */
    public static final AddressLayout add_supports_type$layout() {
        return add_supports_type$LAYOUT;
    }

    private static final long add_supports_type$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*add_supports_type)(GAppInfo *, const char *, GError **)
     * }
     */
    public static final long add_supports_type$offset() {
        return add_supports_type$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*add_supports_type)(GAppInfo *, const char *, GError **)
     * }
     */
    public static MemorySegment add_supports_type(MemorySegment struct) {
        return struct.get(add_supports_type$LAYOUT, add_supports_type$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*add_supports_type)(GAppInfo *, const char *, GError **)
     * }
     */
    public static void add_supports_type(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(add_supports_type$LAYOUT, add_supports_type$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*can_remove_supports_type)(GAppInfo *)
     * }
     */
    public class can_remove_supports_type {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(can_remove_supports_type.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(can_remove_supports_type.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout can_remove_supports_type$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("can_remove_supports_type"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*can_remove_supports_type)(GAppInfo *)
     * }
     */
    public static final AddressLayout can_remove_supports_type$layout() {
        return can_remove_supports_type$LAYOUT;
    }

    private static final long can_remove_supports_type$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*can_remove_supports_type)(GAppInfo *)
     * }
     */
    public static final long can_remove_supports_type$offset() {
        return can_remove_supports_type$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*can_remove_supports_type)(GAppInfo *)
     * }
     */
    public static MemorySegment can_remove_supports_type(MemorySegment struct) {
        return struct.get(can_remove_supports_type$LAYOUT, can_remove_supports_type$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*can_remove_supports_type)(GAppInfo *)
     * }
     */
    public static void can_remove_supports_type(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(can_remove_supports_type$LAYOUT, can_remove_supports_type$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*remove_supports_type)(GAppInfo *, const char *, GError **)
     * }
     */
    public class remove_supports_type {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(remove_supports_type.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(remove_supports_type.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout remove_supports_type$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("remove_supports_type"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*remove_supports_type)(GAppInfo *, const char *, GError **)
     * }
     */
    public static final AddressLayout remove_supports_type$layout() {
        return remove_supports_type$LAYOUT;
    }

    private static final long remove_supports_type$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*remove_supports_type)(GAppInfo *, const char *, GError **)
     * }
     */
    public static final long remove_supports_type$offset() {
        return remove_supports_type$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*remove_supports_type)(GAppInfo *, const char *, GError **)
     * }
     */
    public static MemorySegment remove_supports_type(MemorySegment struct) {
        return struct.get(remove_supports_type$LAYOUT, remove_supports_type$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*remove_supports_type)(GAppInfo *, const char *, GError **)
     * }
     */
    public static void remove_supports_type(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(remove_supports_type$LAYOUT, remove_supports_type$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*can_delete)(GAppInfo *)
     * }
     */
    public class can_delete {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(can_delete.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(can_delete.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout can_delete$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("can_delete"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*can_delete)(GAppInfo *)
     * }
     */
    public static final AddressLayout can_delete$layout() {
        return can_delete$LAYOUT;
    }

    private static final long can_delete$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*can_delete)(GAppInfo *)
     * }
     */
    public static final long can_delete$offset() {
        return can_delete$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*can_delete)(GAppInfo *)
     * }
     */
    public static MemorySegment can_delete(MemorySegment struct) {
        return struct.get(can_delete$LAYOUT, can_delete$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*can_delete)(GAppInfo *)
     * }
     */
    public static void can_delete(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(can_delete$LAYOUT, can_delete$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*do_delete)(GAppInfo *)
     * }
     */
    public class do_delete {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(do_delete.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(do_delete.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout do_delete$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("do_delete"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*do_delete)(GAppInfo *)
     * }
     */
    public static final AddressLayout do_delete$layout() {
        return do_delete$LAYOUT;
    }

    private static final long do_delete$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*do_delete)(GAppInfo *)
     * }
     */
    public static final long do_delete$offset() {
        return do_delete$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*do_delete)(GAppInfo *)
     * }
     */
    public static MemorySegment do_delete(MemorySegment struct) {
        return struct.get(do_delete$LAYOUT, do_delete$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*do_delete)(GAppInfo *)
     * }
     */
    public static void do_delete(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(do_delete$LAYOUT, do_delete$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const char *(*get_commandline)(GAppInfo *)
     * }
     */
    public class get_commandline {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_commandline.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_commandline.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_commandline$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_commandline"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *(*get_commandline)(GAppInfo *)
     * }
     */
    public static final AddressLayout get_commandline$layout() {
        return get_commandline$LAYOUT;
    }

    private static final long get_commandline$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *(*get_commandline)(GAppInfo *)
     * }
     */
    public static final long get_commandline$offset() {
        return get_commandline$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *(*get_commandline)(GAppInfo *)
     * }
     */
    public static MemorySegment get_commandline(MemorySegment struct) {
        return struct.get(get_commandline$LAYOUT, get_commandline$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *(*get_commandline)(GAppInfo *)
     * }
     */
    public static void get_commandline(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_commandline$LAYOUT, get_commandline$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const char *(*get_display_name)(GAppInfo *)
     * }
     */
    public class get_display_name {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_display_name.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_display_name.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_display_name$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_display_name"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *(*get_display_name)(GAppInfo *)
     * }
     */
    public static final AddressLayout get_display_name$layout() {
        return get_display_name$LAYOUT;
    }

    private static final long get_display_name$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *(*get_display_name)(GAppInfo *)
     * }
     */
    public static final long get_display_name$offset() {
        return get_display_name$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *(*get_display_name)(GAppInfo *)
     * }
     */
    public static MemorySegment get_display_name(MemorySegment struct) {
        return struct.get(get_display_name$LAYOUT, get_display_name$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *(*get_display_name)(GAppInfo *)
     * }
     */
    public static void get_display_name(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_display_name$LAYOUT, get_display_name$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*set_as_last_used_for_type)(GAppInfo *, const char *, GError **)
     * }
     */
    public class set_as_last_used_for_type {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(set_as_last_used_for_type.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(set_as_last_used_for_type.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_as_last_used_for_type$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_as_last_used_for_type"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*set_as_last_used_for_type)(GAppInfo *, const char *, GError **)
     * }
     */
    public static final AddressLayout set_as_last_used_for_type$layout() {
        return set_as_last_used_for_type$LAYOUT;
    }

    private static final long set_as_last_used_for_type$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*set_as_last_used_for_type)(GAppInfo *, const char *, GError **)
     * }
     */
    public static final long set_as_last_used_for_type$offset() {
        return set_as_last_used_for_type$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*set_as_last_used_for_type)(GAppInfo *, const char *, GError **)
     * }
     */
    public static MemorySegment set_as_last_used_for_type(MemorySegment struct) {
        return struct.get(set_as_last_used_for_type$LAYOUT, set_as_last_used_for_type$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*set_as_last_used_for_type)(GAppInfo *, const char *, GError **)
     * }
     */
    public static void set_as_last_used_for_type(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_as_last_used_for_type$LAYOUT, set_as_last_used_for_type$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const char **(*get_supported_types)(GAppInfo *)
     * }
     */
    public class get_supported_types {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_supported_types.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_supported_types.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_supported_types$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_supported_types"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char **(*get_supported_types)(GAppInfo *)
     * }
     */
    public static final AddressLayout get_supported_types$layout() {
        return get_supported_types$LAYOUT;
    }

    private static final long get_supported_types$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char **(*get_supported_types)(GAppInfo *)
     * }
     */
    public static final long get_supported_types$offset() {
        return get_supported_types$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char **(*get_supported_types)(GAppInfo *)
     * }
     */
    public static MemorySegment get_supported_types(MemorySegment struct) {
        return struct.get(get_supported_types$LAYOUT, get_supported_types$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char **(*get_supported_types)(GAppInfo *)
     * }
     */
    public static void get_supported_types(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_supported_types$LAYOUT, get_supported_types$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*launch_uris_async)(GAppInfo *, GList *, GAppLaunchContext *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class launch_uris_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(launch_uris_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(launch_uris_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout launch_uris_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("launch_uris_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*launch_uris_async)(GAppInfo *, GList *, GAppLaunchContext *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout launch_uris_async$layout() {
        return launch_uris_async$LAYOUT;
    }

    private static final long launch_uris_async$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*launch_uris_async)(GAppInfo *, GList *, GAppLaunchContext *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long launch_uris_async$offset() {
        return launch_uris_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*launch_uris_async)(GAppInfo *, GList *, GAppLaunchContext *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment launch_uris_async(MemorySegment struct) {
        return struct.get(launch_uris_async$LAYOUT, launch_uris_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*launch_uris_async)(GAppInfo *, GList *, GAppLaunchContext *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void launch_uris_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(launch_uris_async$LAYOUT, launch_uris_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*launch_uris_finish)(GAppInfo *, GAsyncResult *, GError **)
     * }
     */
    public class launch_uris_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(launch_uris_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(launch_uris_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout launch_uris_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("launch_uris_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*launch_uris_finish)(GAppInfo *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout launch_uris_finish$layout() {
        return launch_uris_finish$LAYOUT;
    }

    private static final long launch_uris_finish$OFFSET = 208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*launch_uris_finish)(GAppInfo *, GAsyncResult *, GError **)
     * }
     */
    public static final long launch_uris_finish$offset() {
        return launch_uris_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*launch_uris_finish)(GAppInfo *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment launch_uris_finish(MemorySegment struct) {
        return struct.get(launch_uris_finish$LAYOUT, launch_uris_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*launch_uris_finish)(GAppInfo *, GAsyncResult *, GError **)
     * }
     */
    public static void launch_uris_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(launch_uris_finish$LAYOUT, launch_uris_finish$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

