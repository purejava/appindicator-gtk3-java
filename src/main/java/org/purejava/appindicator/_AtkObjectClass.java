// Generated by jextract

package org.purejava.appindicator;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct _AtkObjectClass {
 *     GObjectClass parent;
 *     const gchar *(*get_name)(AtkObject *);
 *     const gchar *(*get_description)(AtkObject *);
 *     AtkObject *(*get_parent)(AtkObject *);
 *     gint (*get_n_children)(AtkObject *);
 *     AtkObject *(*ref_child)(AtkObject *, gint);
 *     gint (*get_index_in_parent)(AtkObject *);
 *     AtkRelationSet *(*ref_relation_set)(AtkObject *);
 *     AtkRole (*get_role)(AtkObject *);
 *     AtkLayer (*get_layer)(AtkObject *);
 *     gint (*get_mdi_zorder)(AtkObject *);
 *     AtkStateSet *(*ref_state_set)(AtkObject *);
 *     void (*set_name)(AtkObject *, const gchar *);
 *     void (*set_description)(AtkObject *, const gchar *);
 *     void (*set_parent)(AtkObject *, AtkObject *);
 *     void (*set_role)(AtkObject *, AtkRole);
 *     guint (*connect_property_change_handler)(AtkObject *, AtkPropertyChangeHandler *);
 *     void (*remove_property_change_handler)(AtkObject *, guint);
 *     void (*initialize)(AtkObject *, gpointer);
 *     void (*children_changed)(AtkObject *, guint, gpointer);
 *     void (*focus_event)(AtkObject *, gboolean);
 *     void (*property_change)(AtkObject *, AtkPropertyValues *);
 *     void (*state_change)(AtkObject *, const gchar *, gboolean);
 *     void (*visible_data_changed)(AtkObject *);
 *     void (*active_descendant_changed)(AtkObject *, gpointer *);
 *     AtkAttributeSet *(*get_attributes)(AtkObject *);
 *     const gchar *(*get_object_locale)(AtkObject *);
 *     AtkFunction pad1;
 * }
 * }
 */
public class _AtkObjectClass {

    _AtkObjectClass() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        _GObjectClass.layout().withName("parent"),
        app_indicator_h.C_POINTER.withName("get_name"),
        app_indicator_h.C_POINTER.withName("get_description"),
        app_indicator_h.C_POINTER.withName("get_parent"),
        app_indicator_h.C_POINTER.withName("get_n_children"),
        app_indicator_h.C_POINTER.withName("ref_child"),
        app_indicator_h.C_POINTER.withName("get_index_in_parent"),
        app_indicator_h.C_POINTER.withName("ref_relation_set"),
        app_indicator_h.C_POINTER.withName("get_role"),
        app_indicator_h.C_POINTER.withName("get_layer"),
        app_indicator_h.C_POINTER.withName("get_mdi_zorder"),
        app_indicator_h.C_POINTER.withName("ref_state_set"),
        app_indicator_h.C_POINTER.withName("set_name"),
        app_indicator_h.C_POINTER.withName("set_description"),
        app_indicator_h.C_POINTER.withName("set_parent"),
        app_indicator_h.C_POINTER.withName("set_role"),
        app_indicator_h.C_POINTER.withName("connect_property_change_handler"),
        app_indicator_h.C_POINTER.withName("remove_property_change_handler"),
        app_indicator_h.C_POINTER.withName("initialize"),
        app_indicator_h.C_POINTER.withName("children_changed"),
        app_indicator_h.C_POINTER.withName("focus_event"),
        app_indicator_h.C_POINTER.withName("property_change"),
        app_indicator_h.C_POINTER.withName("state_change"),
        app_indicator_h.C_POINTER.withName("visible_data_changed"),
        app_indicator_h.C_POINTER.withName("active_descendant_changed"),
        app_indicator_h.C_POINTER.withName("get_attributes"),
        app_indicator_h.C_POINTER.withName("get_object_locale"),
        app_indicator_h.C_POINTER.withName("pad1")
    ).withName("_AtkObjectClass");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final GroupLayout parent$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("parent"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GObjectClass parent
     * }
     */
    public static final GroupLayout parent$layout() {
        return parent$LAYOUT;
    }

    private static final long parent$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GObjectClass parent
     * }
     */
    public static final long parent$offset() {
        return parent$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GObjectClass parent
     * }
     */
    public static MemorySegment parent(MemorySegment struct) {
        return struct.asSlice(parent$OFFSET, parent$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GObjectClass parent
     * }
     */
    public static void parent(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, parent$OFFSET, parent$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * const gchar *(*get_name)(AtkObject *)
     * }
     */
    public class get_name {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_name.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_name.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_name$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_name"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const gchar *(*get_name)(AtkObject *)
     * }
     */
    public static final AddressLayout get_name$layout() {
        return get_name$LAYOUT;
    }

    private static final long get_name$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const gchar *(*get_name)(AtkObject *)
     * }
     */
    public static final long get_name$offset() {
        return get_name$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const gchar *(*get_name)(AtkObject *)
     * }
     */
    public static MemorySegment get_name(MemorySegment struct) {
        return struct.get(get_name$LAYOUT, get_name$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const gchar *(*get_name)(AtkObject *)
     * }
     */
    public static void get_name(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_name$LAYOUT, get_name$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const gchar *(*get_description)(AtkObject *)
     * }
     */
    public class get_description {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_description.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_description.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_description$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_description"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const gchar *(*get_description)(AtkObject *)
     * }
     */
    public static final AddressLayout get_description$layout() {
        return get_description$LAYOUT;
    }

    private static final long get_description$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const gchar *(*get_description)(AtkObject *)
     * }
     */
    public static final long get_description$offset() {
        return get_description$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const gchar *(*get_description)(AtkObject *)
     * }
     */
    public static MemorySegment get_description(MemorySegment struct) {
        return struct.get(get_description$LAYOUT, get_description$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const gchar *(*get_description)(AtkObject *)
     * }
     */
    public static void get_description(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_description$LAYOUT, get_description$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * AtkObject *(*get_parent)(AtkObject *)
     * }
     */
    public class get_parent {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_parent.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_parent.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_parent$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_parent"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AtkObject *(*get_parent)(AtkObject *)
     * }
     */
    public static final AddressLayout get_parent$layout() {
        return get_parent$LAYOUT;
    }

    private static final long get_parent$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AtkObject *(*get_parent)(AtkObject *)
     * }
     */
    public static final long get_parent$offset() {
        return get_parent$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AtkObject *(*get_parent)(AtkObject *)
     * }
     */
    public static MemorySegment get_parent(MemorySegment struct) {
        return struct.get(get_parent$LAYOUT, get_parent$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AtkObject *(*get_parent)(AtkObject *)
     * }
     */
    public static void get_parent(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_parent$LAYOUT, get_parent$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gint (*get_n_children)(AtkObject *)
     * }
     */
    public class get_n_children {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_n_children.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_n_children.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_n_children$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_n_children"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gint (*get_n_children)(AtkObject *)
     * }
     */
    public static final AddressLayout get_n_children$layout() {
        return get_n_children$LAYOUT;
    }

    private static final long get_n_children$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gint (*get_n_children)(AtkObject *)
     * }
     */
    public static final long get_n_children$offset() {
        return get_n_children$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gint (*get_n_children)(AtkObject *)
     * }
     */
    public static MemorySegment get_n_children(MemorySegment struct) {
        return struct.get(get_n_children$LAYOUT, get_n_children$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gint (*get_n_children)(AtkObject *)
     * }
     */
    public static void get_n_children(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_n_children$LAYOUT, get_n_children$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * AtkObject *(*ref_child)(AtkObject *, gint)
     * }
     */
    public class ref_child {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(ref_child.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ref_child.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ref_child$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ref_child"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AtkObject *(*ref_child)(AtkObject *, gint)
     * }
     */
    public static final AddressLayout ref_child$layout() {
        return ref_child$LAYOUT;
    }

    private static final long ref_child$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AtkObject *(*ref_child)(AtkObject *, gint)
     * }
     */
    public static final long ref_child$offset() {
        return ref_child$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AtkObject *(*ref_child)(AtkObject *, gint)
     * }
     */
    public static MemorySegment ref_child(MemorySegment struct) {
        return struct.get(ref_child$LAYOUT, ref_child$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AtkObject *(*ref_child)(AtkObject *, gint)
     * }
     */
    public static void ref_child(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ref_child$LAYOUT, ref_child$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gint (*get_index_in_parent)(AtkObject *)
     * }
     */
    public class get_index_in_parent {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_index_in_parent.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_index_in_parent.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_index_in_parent$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_index_in_parent"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gint (*get_index_in_parent)(AtkObject *)
     * }
     */
    public static final AddressLayout get_index_in_parent$layout() {
        return get_index_in_parent$LAYOUT;
    }

    private static final long get_index_in_parent$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gint (*get_index_in_parent)(AtkObject *)
     * }
     */
    public static final long get_index_in_parent$offset() {
        return get_index_in_parent$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gint (*get_index_in_parent)(AtkObject *)
     * }
     */
    public static MemorySegment get_index_in_parent(MemorySegment struct) {
        return struct.get(get_index_in_parent$LAYOUT, get_index_in_parent$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gint (*get_index_in_parent)(AtkObject *)
     * }
     */
    public static void get_index_in_parent(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_index_in_parent$LAYOUT, get_index_in_parent$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * AtkRelationSet *(*ref_relation_set)(AtkObject *)
     * }
     */
    public class ref_relation_set {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(ref_relation_set.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ref_relation_set.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ref_relation_set$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ref_relation_set"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AtkRelationSet *(*ref_relation_set)(AtkObject *)
     * }
     */
    public static final AddressLayout ref_relation_set$layout() {
        return ref_relation_set$LAYOUT;
    }

    private static final long ref_relation_set$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AtkRelationSet *(*ref_relation_set)(AtkObject *)
     * }
     */
    public static final long ref_relation_set$offset() {
        return ref_relation_set$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AtkRelationSet *(*ref_relation_set)(AtkObject *)
     * }
     */
    public static MemorySegment ref_relation_set(MemorySegment struct) {
        return struct.get(ref_relation_set$LAYOUT, ref_relation_set$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AtkRelationSet *(*ref_relation_set)(AtkObject *)
     * }
     */
    public static void ref_relation_set(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ref_relation_set$LAYOUT, ref_relation_set$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * AtkRole (*get_role)(AtkObject *)
     * }
     */
    public class get_role {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_role.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_role.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_role$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_role"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AtkRole (*get_role)(AtkObject *)
     * }
     */
    public static final AddressLayout get_role$layout() {
        return get_role$LAYOUT;
    }

    private static final long get_role$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AtkRole (*get_role)(AtkObject *)
     * }
     */
    public static final long get_role$offset() {
        return get_role$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AtkRole (*get_role)(AtkObject *)
     * }
     */
    public static MemorySegment get_role(MemorySegment struct) {
        return struct.get(get_role$LAYOUT, get_role$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AtkRole (*get_role)(AtkObject *)
     * }
     */
    public static void get_role(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_role$LAYOUT, get_role$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * AtkLayer (*get_layer)(AtkObject *)
     * }
     */
    public class get_layer {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_layer.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_layer.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_layer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_layer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AtkLayer (*get_layer)(AtkObject *)
     * }
     */
    public static final AddressLayout get_layer$layout() {
        return get_layer$LAYOUT;
    }

    private static final long get_layer$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AtkLayer (*get_layer)(AtkObject *)
     * }
     */
    public static final long get_layer$offset() {
        return get_layer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AtkLayer (*get_layer)(AtkObject *)
     * }
     */
    public static MemorySegment get_layer(MemorySegment struct) {
        return struct.get(get_layer$LAYOUT, get_layer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AtkLayer (*get_layer)(AtkObject *)
     * }
     */
    public static void get_layer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_layer$LAYOUT, get_layer$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gint (*get_mdi_zorder)(AtkObject *)
     * }
     */
    public class get_mdi_zorder {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_mdi_zorder.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_mdi_zorder.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_mdi_zorder$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_mdi_zorder"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gint (*get_mdi_zorder)(AtkObject *)
     * }
     */
    public static final AddressLayout get_mdi_zorder$layout() {
        return get_mdi_zorder$LAYOUT;
    }

    private static final long get_mdi_zorder$OFFSET = 208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gint (*get_mdi_zorder)(AtkObject *)
     * }
     */
    public static final long get_mdi_zorder$offset() {
        return get_mdi_zorder$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gint (*get_mdi_zorder)(AtkObject *)
     * }
     */
    public static MemorySegment get_mdi_zorder(MemorySegment struct) {
        return struct.get(get_mdi_zorder$LAYOUT, get_mdi_zorder$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gint (*get_mdi_zorder)(AtkObject *)
     * }
     */
    public static void get_mdi_zorder(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_mdi_zorder$LAYOUT, get_mdi_zorder$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * AtkStateSet *(*ref_state_set)(AtkObject *)
     * }
     */
    public class ref_state_set {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(ref_state_set.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ref_state_set.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ref_state_set$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ref_state_set"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AtkStateSet *(*ref_state_set)(AtkObject *)
     * }
     */
    public static final AddressLayout ref_state_set$layout() {
        return ref_state_set$LAYOUT;
    }

    private static final long ref_state_set$OFFSET = 216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AtkStateSet *(*ref_state_set)(AtkObject *)
     * }
     */
    public static final long ref_state_set$offset() {
        return ref_state_set$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AtkStateSet *(*ref_state_set)(AtkObject *)
     * }
     */
    public static MemorySegment ref_state_set(MemorySegment struct) {
        return struct.get(ref_state_set$LAYOUT, ref_state_set$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AtkStateSet *(*ref_state_set)(AtkObject *)
     * }
     */
    public static void ref_state_set(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ref_state_set$LAYOUT, ref_state_set$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*set_name)(AtkObject *, const gchar *)
     * }
     */
    public class set_name {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(set_name.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(set_name.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_name$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_name"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*set_name)(AtkObject *, const gchar *)
     * }
     */
    public static final AddressLayout set_name$layout() {
        return set_name$LAYOUT;
    }

    private static final long set_name$OFFSET = 224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*set_name)(AtkObject *, const gchar *)
     * }
     */
    public static final long set_name$offset() {
        return set_name$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*set_name)(AtkObject *, const gchar *)
     * }
     */
    public static MemorySegment set_name(MemorySegment struct) {
        return struct.get(set_name$LAYOUT, set_name$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*set_name)(AtkObject *, const gchar *)
     * }
     */
    public static void set_name(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_name$LAYOUT, set_name$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*set_description)(AtkObject *, const gchar *)
     * }
     */
    public class set_description {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(set_description.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(set_description.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_description$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_description"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*set_description)(AtkObject *, const gchar *)
     * }
     */
    public static final AddressLayout set_description$layout() {
        return set_description$LAYOUT;
    }

    private static final long set_description$OFFSET = 232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*set_description)(AtkObject *, const gchar *)
     * }
     */
    public static final long set_description$offset() {
        return set_description$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*set_description)(AtkObject *, const gchar *)
     * }
     */
    public static MemorySegment set_description(MemorySegment struct) {
        return struct.get(set_description$LAYOUT, set_description$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*set_description)(AtkObject *, const gchar *)
     * }
     */
    public static void set_description(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_description$LAYOUT, set_description$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*set_parent)(AtkObject *, AtkObject *)
     * }
     */
    public class set_parent {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(set_parent.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(set_parent.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_parent$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_parent"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*set_parent)(AtkObject *, AtkObject *)
     * }
     */
    public static final AddressLayout set_parent$layout() {
        return set_parent$LAYOUT;
    }

    private static final long set_parent$OFFSET = 240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*set_parent)(AtkObject *, AtkObject *)
     * }
     */
    public static final long set_parent$offset() {
        return set_parent$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*set_parent)(AtkObject *, AtkObject *)
     * }
     */
    public static MemorySegment set_parent(MemorySegment struct) {
        return struct.get(set_parent$LAYOUT, set_parent$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*set_parent)(AtkObject *, AtkObject *)
     * }
     */
    public static void set_parent(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_parent$LAYOUT, set_parent$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*set_role)(AtkObject *, AtkRole)
     * }
     */
    public class set_role {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(set_role.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(set_role.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_role$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_role"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*set_role)(AtkObject *, AtkRole)
     * }
     */
    public static final AddressLayout set_role$layout() {
        return set_role$LAYOUT;
    }

    private static final long set_role$OFFSET = 248;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*set_role)(AtkObject *, AtkRole)
     * }
     */
    public static final long set_role$offset() {
        return set_role$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*set_role)(AtkObject *, AtkRole)
     * }
     */
    public static MemorySegment set_role(MemorySegment struct) {
        return struct.get(set_role$LAYOUT, set_role$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*set_role)(AtkObject *, AtkRole)
     * }
     */
    public static void set_role(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_role$LAYOUT, set_role$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * guint (*connect_property_change_handler)(AtkObject *, AtkPropertyChangeHandler *)
     * }
     */
    public class connect_property_change_handler {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(connect_property_change_handler.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(connect_property_change_handler.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout connect_property_change_handler$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("connect_property_change_handler"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * guint (*connect_property_change_handler)(AtkObject *, AtkPropertyChangeHandler *)
     * }
     */
    public static final AddressLayout connect_property_change_handler$layout() {
        return connect_property_change_handler$LAYOUT;
    }

    private static final long connect_property_change_handler$OFFSET = 256;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * guint (*connect_property_change_handler)(AtkObject *, AtkPropertyChangeHandler *)
     * }
     */
    public static final long connect_property_change_handler$offset() {
        return connect_property_change_handler$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * guint (*connect_property_change_handler)(AtkObject *, AtkPropertyChangeHandler *)
     * }
     */
    public static MemorySegment connect_property_change_handler(MemorySegment struct) {
        return struct.get(connect_property_change_handler$LAYOUT, connect_property_change_handler$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * guint (*connect_property_change_handler)(AtkObject *, AtkPropertyChangeHandler *)
     * }
     */
    public static void connect_property_change_handler(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(connect_property_change_handler$LAYOUT, connect_property_change_handler$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*remove_property_change_handler)(AtkObject *, guint)
     * }
     */
    public class remove_property_change_handler {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(remove_property_change_handler.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(remove_property_change_handler.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout remove_property_change_handler$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("remove_property_change_handler"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*remove_property_change_handler)(AtkObject *, guint)
     * }
     */
    public static final AddressLayout remove_property_change_handler$layout() {
        return remove_property_change_handler$LAYOUT;
    }

    private static final long remove_property_change_handler$OFFSET = 264;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*remove_property_change_handler)(AtkObject *, guint)
     * }
     */
    public static final long remove_property_change_handler$offset() {
        return remove_property_change_handler$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*remove_property_change_handler)(AtkObject *, guint)
     * }
     */
    public static MemorySegment remove_property_change_handler(MemorySegment struct) {
        return struct.get(remove_property_change_handler$LAYOUT, remove_property_change_handler$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*remove_property_change_handler)(AtkObject *, guint)
     * }
     */
    public static void remove_property_change_handler(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(remove_property_change_handler$LAYOUT, remove_property_change_handler$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*initialize)(AtkObject *, gpointer)
     * }
     */
    public class initialize {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(initialize.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(initialize.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout initialize$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("initialize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*initialize)(AtkObject *, gpointer)
     * }
     */
    public static final AddressLayout initialize$layout() {
        return initialize$LAYOUT;
    }

    private static final long initialize$OFFSET = 272;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*initialize)(AtkObject *, gpointer)
     * }
     */
    public static final long initialize$offset() {
        return initialize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*initialize)(AtkObject *, gpointer)
     * }
     */
    public static MemorySegment initialize(MemorySegment struct) {
        return struct.get(initialize$LAYOUT, initialize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*initialize)(AtkObject *, gpointer)
     * }
     */
    public static void initialize(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(initialize$LAYOUT, initialize$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*children_changed)(AtkObject *, guint, gpointer)
     * }
     */
    public class children_changed {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(children_changed.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(children_changed.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout children_changed$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("children_changed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*children_changed)(AtkObject *, guint, gpointer)
     * }
     */
    public static final AddressLayout children_changed$layout() {
        return children_changed$LAYOUT;
    }

    private static final long children_changed$OFFSET = 280;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*children_changed)(AtkObject *, guint, gpointer)
     * }
     */
    public static final long children_changed$offset() {
        return children_changed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*children_changed)(AtkObject *, guint, gpointer)
     * }
     */
    public static MemorySegment children_changed(MemorySegment struct) {
        return struct.get(children_changed$LAYOUT, children_changed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*children_changed)(AtkObject *, guint, gpointer)
     * }
     */
    public static void children_changed(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(children_changed$LAYOUT, children_changed$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*focus_event)(AtkObject *, gboolean)
     * }
     */
    public class focus_event {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(focus_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(focus_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout focus_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("focus_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*focus_event)(AtkObject *, gboolean)
     * }
     */
    public static final AddressLayout focus_event$layout() {
        return focus_event$LAYOUT;
    }

    private static final long focus_event$OFFSET = 288;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*focus_event)(AtkObject *, gboolean)
     * }
     */
    public static final long focus_event$offset() {
        return focus_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*focus_event)(AtkObject *, gboolean)
     * }
     */
    public static MemorySegment focus_event(MemorySegment struct) {
        return struct.get(focus_event$LAYOUT, focus_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*focus_event)(AtkObject *, gboolean)
     * }
     */
    public static void focus_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(focus_event$LAYOUT, focus_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*property_change)(AtkObject *, AtkPropertyValues *)
     * }
     */
    public class property_change {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(property_change.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(property_change.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout property_change$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("property_change"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*property_change)(AtkObject *, AtkPropertyValues *)
     * }
     */
    public static final AddressLayout property_change$layout() {
        return property_change$LAYOUT;
    }

    private static final long property_change$OFFSET = 296;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*property_change)(AtkObject *, AtkPropertyValues *)
     * }
     */
    public static final long property_change$offset() {
        return property_change$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*property_change)(AtkObject *, AtkPropertyValues *)
     * }
     */
    public static MemorySegment property_change(MemorySegment struct) {
        return struct.get(property_change$LAYOUT, property_change$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*property_change)(AtkObject *, AtkPropertyValues *)
     * }
     */
    public static void property_change(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(property_change$LAYOUT, property_change$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*state_change)(AtkObject *, const gchar *, gboolean)
     * }
     */
    public class state_change {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(state_change.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(state_change.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout state_change$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("state_change"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*state_change)(AtkObject *, const gchar *, gboolean)
     * }
     */
    public static final AddressLayout state_change$layout() {
        return state_change$LAYOUT;
    }

    private static final long state_change$OFFSET = 304;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*state_change)(AtkObject *, const gchar *, gboolean)
     * }
     */
    public static final long state_change$offset() {
        return state_change$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*state_change)(AtkObject *, const gchar *, gboolean)
     * }
     */
    public static MemorySegment state_change(MemorySegment struct) {
        return struct.get(state_change$LAYOUT, state_change$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*state_change)(AtkObject *, const gchar *, gboolean)
     * }
     */
    public static void state_change(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(state_change$LAYOUT, state_change$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*visible_data_changed)(AtkObject *)
     * }
     */
    public class visible_data_changed {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(visible_data_changed.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(visible_data_changed.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout visible_data_changed$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("visible_data_changed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*visible_data_changed)(AtkObject *)
     * }
     */
    public static final AddressLayout visible_data_changed$layout() {
        return visible_data_changed$LAYOUT;
    }

    private static final long visible_data_changed$OFFSET = 312;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*visible_data_changed)(AtkObject *)
     * }
     */
    public static final long visible_data_changed$offset() {
        return visible_data_changed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*visible_data_changed)(AtkObject *)
     * }
     */
    public static MemorySegment visible_data_changed(MemorySegment struct) {
        return struct.get(visible_data_changed$LAYOUT, visible_data_changed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*visible_data_changed)(AtkObject *)
     * }
     */
    public static void visible_data_changed(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(visible_data_changed$LAYOUT, visible_data_changed$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*active_descendant_changed)(AtkObject *, gpointer *)
     * }
     */
    public class active_descendant_changed {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(active_descendant_changed.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(active_descendant_changed.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout active_descendant_changed$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("active_descendant_changed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*active_descendant_changed)(AtkObject *, gpointer *)
     * }
     */
    public static final AddressLayout active_descendant_changed$layout() {
        return active_descendant_changed$LAYOUT;
    }

    private static final long active_descendant_changed$OFFSET = 320;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*active_descendant_changed)(AtkObject *, gpointer *)
     * }
     */
    public static final long active_descendant_changed$offset() {
        return active_descendant_changed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*active_descendant_changed)(AtkObject *, gpointer *)
     * }
     */
    public static MemorySegment active_descendant_changed(MemorySegment struct) {
        return struct.get(active_descendant_changed$LAYOUT, active_descendant_changed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*active_descendant_changed)(AtkObject *, gpointer *)
     * }
     */
    public static void active_descendant_changed(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(active_descendant_changed$LAYOUT, active_descendant_changed$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * AtkAttributeSet *(*get_attributes)(AtkObject *)
     * }
     */
    public class get_attributes {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_attributes.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_attributes.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_attributes$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_attributes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AtkAttributeSet *(*get_attributes)(AtkObject *)
     * }
     */
    public static final AddressLayout get_attributes$layout() {
        return get_attributes$LAYOUT;
    }

    private static final long get_attributes$OFFSET = 328;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AtkAttributeSet *(*get_attributes)(AtkObject *)
     * }
     */
    public static final long get_attributes$offset() {
        return get_attributes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AtkAttributeSet *(*get_attributes)(AtkObject *)
     * }
     */
    public static MemorySegment get_attributes(MemorySegment struct) {
        return struct.get(get_attributes$LAYOUT, get_attributes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AtkAttributeSet *(*get_attributes)(AtkObject *)
     * }
     */
    public static void get_attributes(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_attributes$LAYOUT, get_attributes$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const gchar *(*get_object_locale)(AtkObject *)
     * }
     */
    public class get_object_locale {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_object_locale.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_object_locale.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_object_locale$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_object_locale"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const gchar *(*get_object_locale)(AtkObject *)
     * }
     */
    public static final AddressLayout get_object_locale$layout() {
        return get_object_locale$LAYOUT;
    }

    private static final long get_object_locale$OFFSET = 336;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const gchar *(*get_object_locale)(AtkObject *)
     * }
     */
    public static final long get_object_locale$offset() {
        return get_object_locale$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const gchar *(*get_object_locale)(AtkObject *)
     * }
     */
    public static MemorySegment get_object_locale(MemorySegment struct) {
        return struct.get(get_object_locale$LAYOUT, get_object_locale$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const gchar *(*get_object_locale)(AtkObject *)
     * }
     */
    public static void get_object_locale(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_object_locale$LAYOUT, get_object_locale$OFFSET, fieldValue);
    }

    private static final AddressLayout pad1$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pad1"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AtkFunction pad1
     * }
     */
    public static final AddressLayout pad1$layout() {
        return pad1$LAYOUT;
    }

    private static final long pad1$OFFSET = 344;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AtkFunction pad1
     * }
     */
    public static final long pad1$offset() {
        return pad1$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AtkFunction pad1
     * }
     */
    public static MemorySegment pad1(MemorySegment struct) {
        return struct.get(pad1$LAYOUT, pad1$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AtkFunction pad1
     * }
     */
    public static void pad1(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(pad1$LAYOUT, pad1$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

