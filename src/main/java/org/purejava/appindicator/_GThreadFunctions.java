// Generated by jextract

package org.purejava.appindicator;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct _GThreadFunctions {
 *     GMutex *(*mutex_new)(void);
 *     void (*mutex_lock)(GMutex *);
 *     gboolean (*mutex_trylock)(GMutex *);
 *     void (*mutex_unlock)(GMutex *);
 *     void (*mutex_free)(GMutex *);
 *     GCond *(*cond_new)(void);
 *     void (*cond_signal)(GCond *);
 *     void (*cond_broadcast)(GCond *);
 *     void (*cond_wait)(GCond *, GMutex *);
 *     gboolean (*cond_timed_wait)(GCond *, GMutex *, GTimeVal *);
 *     void (*cond_free)(GCond *);
 *     GPrivate *(*private_new)(GDestroyNotify);
 *     gpointer (*private_get)(GPrivate *);
 *     void (*private_set)(GPrivate *, gpointer);
 *     void (*thread_create)(GThreadFunc, gpointer, gulong, gboolean, gboolean, GThreadPriority, gpointer, GError **);
 *     void (*thread_yield)(void);
 *     void (*thread_join)(gpointer);
 *     void (*thread_exit)(void);
 *     void (*thread_set_priority)(gpointer, GThreadPriority);
 *     void (*thread_self)(gpointer);
 *     gboolean (*thread_equal)(gpointer, gpointer);
 * }
 * }
 */
public class _GThreadFunctions {

    _GThreadFunctions() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        app_indicator_h.C_POINTER.withName("mutex_new"),
        app_indicator_h.C_POINTER.withName("mutex_lock"),
        app_indicator_h.C_POINTER.withName("mutex_trylock"),
        app_indicator_h.C_POINTER.withName("mutex_unlock"),
        app_indicator_h.C_POINTER.withName("mutex_free"),
        app_indicator_h.C_POINTER.withName("cond_new"),
        app_indicator_h.C_POINTER.withName("cond_signal"),
        app_indicator_h.C_POINTER.withName("cond_broadcast"),
        app_indicator_h.C_POINTER.withName("cond_wait"),
        app_indicator_h.C_POINTER.withName("cond_timed_wait"),
        app_indicator_h.C_POINTER.withName("cond_free"),
        app_indicator_h.C_POINTER.withName("private_new"),
        app_indicator_h.C_POINTER.withName("private_get"),
        app_indicator_h.C_POINTER.withName("private_set"),
        app_indicator_h.C_POINTER.withName("thread_create"),
        app_indicator_h.C_POINTER.withName("thread_yield"),
        app_indicator_h.C_POINTER.withName("thread_join"),
        app_indicator_h.C_POINTER.withName("thread_exit"),
        app_indicator_h.C_POINTER.withName("thread_set_priority"),
        app_indicator_h.C_POINTER.withName("thread_self"),
        app_indicator_h.C_POINTER.withName("thread_equal")
    ).withName("_GThreadFunctions");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * GMutex *(*mutex_new)(void)
     * }
     */
    public class mutex_new {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(mutex_new.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(mutex_new.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout mutex_new$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("mutex_new"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GMutex *(*mutex_new)(void)
     * }
     */
    public static final AddressLayout mutex_new$layout() {
        return mutex_new$LAYOUT;
    }

    private static final long mutex_new$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GMutex *(*mutex_new)(void)
     * }
     */
    public static final long mutex_new$offset() {
        return mutex_new$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GMutex *(*mutex_new)(void)
     * }
     */
    public static MemorySegment mutex_new(MemorySegment struct) {
        return struct.get(mutex_new$LAYOUT, mutex_new$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GMutex *(*mutex_new)(void)
     * }
     */
    public static void mutex_new(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(mutex_new$LAYOUT, mutex_new$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*mutex_lock)(GMutex *)
     * }
     */
    public class mutex_lock {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(mutex_lock.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(mutex_lock.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout mutex_lock$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("mutex_lock"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*mutex_lock)(GMutex *)
     * }
     */
    public static final AddressLayout mutex_lock$layout() {
        return mutex_lock$LAYOUT;
    }

    private static final long mutex_lock$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*mutex_lock)(GMutex *)
     * }
     */
    public static final long mutex_lock$offset() {
        return mutex_lock$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*mutex_lock)(GMutex *)
     * }
     */
    public static MemorySegment mutex_lock(MemorySegment struct) {
        return struct.get(mutex_lock$LAYOUT, mutex_lock$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*mutex_lock)(GMutex *)
     * }
     */
    public static void mutex_lock(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(mutex_lock$LAYOUT, mutex_lock$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*mutex_trylock)(GMutex *)
     * }
     */
    public class mutex_trylock {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(mutex_trylock.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(mutex_trylock.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout mutex_trylock$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("mutex_trylock"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*mutex_trylock)(GMutex *)
     * }
     */
    public static final AddressLayout mutex_trylock$layout() {
        return mutex_trylock$LAYOUT;
    }

    private static final long mutex_trylock$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*mutex_trylock)(GMutex *)
     * }
     */
    public static final long mutex_trylock$offset() {
        return mutex_trylock$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*mutex_trylock)(GMutex *)
     * }
     */
    public static MemorySegment mutex_trylock(MemorySegment struct) {
        return struct.get(mutex_trylock$LAYOUT, mutex_trylock$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*mutex_trylock)(GMutex *)
     * }
     */
    public static void mutex_trylock(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(mutex_trylock$LAYOUT, mutex_trylock$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*mutex_unlock)(GMutex *)
     * }
     */
    public class mutex_unlock {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(mutex_unlock.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(mutex_unlock.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout mutex_unlock$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("mutex_unlock"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*mutex_unlock)(GMutex *)
     * }
     */
    public static final AddressLayout mutex_unlock$layout() {
        return mutex_unlock$LAYOUT;
    }

    private static final long mutex_unlock$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*mutex_unlock)(GMutex *)
     * }
     */
    public static final long mutex_unlock$offset() {
        return mutex_unlock$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*mutex_unlock)(GMutex *)
     * }
     */
    public static MemorySegment mutex_unlock(MemorySegment struct) {
        return struct.get(mutex_unlock$LAYOUT, mutex_unlock$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*mutex_unlock)(GMutex *)
     * }
     */
    public static void mutex_unlock(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(mutex_unlock$LAYOUT, mutex_unlock$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*mutex_free)(GMutex *)
     * }
     */
    public class mutex_free {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(mutex_free.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(mutex_free.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout mutex_free$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("mutex_free"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*mutex_free)(GMutex *)
     * }
     */
    public static final AddressLayout mutex_free$layout() {
        return mutex_free$LAYOUT;
    }

    private static final long mutex_free$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*mutex_free)(GMutex *)
     * }
     */
    public static final long mutex_free$offset() {
        return mutex_free$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*mutex_free)(GMutex *)
     * }
     */
    public static MemorySegment mutex_free(MemorySegment struct) {
        return struct.get(mutex_free$LAYOUT, mutex_free$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*mutex_free)(GMutex *)
     * }
     */
    public static void mutex_free(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(mutex_free$LAYOUT, mutex_free$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GCond *(*cond_new)(void)
     * }
     */
    public class cond_new {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(cond_new.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(cond_new.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout cond_new$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("cond_new"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GCond *(*cond_new)(void)
     * }
     */
    public static final AddressLayout cond_new$layout() {
        return cond_new$LAYOUT;
    }

    private static final long cond_new$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GCond *(*cond_new)(void)
     * }
     */
    public static final long cond_new$offset() {
        return cond_new$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GCond *(*cond_new)(void)
     * }
     */
    public static MemorySegment cond_new(MemorySegment struct) {
        return struct.get(cond_new$LAYOUT, cond_new$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GCond *(*cond_new)(void)
     * }
     */
    public static void cond_new(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(cond_new$LAYOUT, cond_new$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*cond_signal)(GCond *)
     * }
     */
    public class cond_signal {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(cond_signal.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(cond_signal.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout cond_signal$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("cond_signal"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*cond_signal)(GCond *)
     * }
     */
    public static final AddressLayout cond_signal$layout() {
        return cond_signal$LAYOUT;
    }

    private static final long cond_signal$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*cond_signal)(GCond *)
     * }
     */
    public static final long cond_signal$offset() {
        return cond_signal$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*cond_signal)(GCond *)
     * }
     */
    public static MemorySegment cond_signal(MemorySegment struct) {
        return struct.get(cond_signal$LAYOUT, cond_signal$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*cond_signal)(GCond *)
     * }
     */
    public static void cond_signal(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(cond_signal$LAYOUT, cond_signal$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*cond_broadcast)(GCond *)
     * }
     */
    public class cond_broadcast {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(cond_broadcast.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(cond_broadcast.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout cond_broadcast$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("cond_broadcast"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*cond_broadcast)(GCond *)
     * }
     */
    public static final AddressLayout cond_broadcast$layout() {
        return cond_broadcast$LAYOUT;
    }

    private static final long cond_broadcast$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*cond_broadcast)(GCond *)
     * }
     */
    public static final long cond_broadcast$offset() {
        return cond_broadcast$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*cond_broadcast)(GCond *)
     * }
     */
    public static MemorySegment cond_broadcast(MemorySegment struct) {
        return struct.get(cond_broadcast$LAYOUT, cond_broadcast$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*cond_broadcast)(GCond *)
     * }
     */
    public static void cond_broadcast(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(cond_broadcast$LAYOUT, cond_broadcast$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*cond_wait)(GCond *, GMutex *)
     * }
     */
    public class cond_wait {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(cond_wait.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(cond_wait.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout cond_wait$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("cond_wait"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*cond_wait)(GCond *, GMutex *)
     * }
     */
    public static final AddressLayout cond_wait$layout() {
        return cond_wait$LAYOUT;
    }

    private static final long cond_wait$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*cond_wait)(GCond *, GMutex *)
     * }
     */
    public static final long cond_wait$offset() {
        return cond_wait$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*cond_wait)(GCond *, GMutex *)
     * }
     */
    public static MemorySegment cond_wait(MemorySegment struct) {
        return struct.get(cond_wait$LAYOUT, cond_wait$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*cond_wait)(GCond *, GMutex *)
     * }
     */
    public static void cond_wait(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(cond_wait$LAYOUT, cond_wait$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*cond_timed_wait)(GCond *, GMutex *, GTimeVal *)
     * }
     */
    public class cond_timed_wait {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(cond_timed_wait.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(cond_timed_wait.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout cond_timed_wait$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("cond_timed_wait"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*cond_timed_wait)(GCond *, GMutex *, GTimeVal *)
     * }
     */
    public static final AddressLayout cond_timed_wait$layout() {
        return cond_timed_wait$LAYOUT;
    }

    private static final long cond_timed_wait$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*cond_timed_wait)(GCond *, GMutex *, GTimeVal *)
     * }
     */
    public static final long cond_timed_wait$offset() {
        return cond_timed_wait$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*cond_timed_wait)(GCond *, GMutex *, GTimeVal *)
     * }
     */
    public static MemorySegment cond_timed_wait(MemorySegment struct) {
        return struct.get(cond_timed_wait$LAYOUT, cond_timed_wait$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*cond_timed_wait)(GCond *, GMutex *, GTimeVal *)
     * }
     */
    public static void cond_timed_wait(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(cond_timed_wait$LAYOUT, cond_timed_wait$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*cond_free)(GCond *)
     * }
     */
    public class cond_free {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(cond_free.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(cond_free.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout cond_free$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("cond_free"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*cond_free)(GCond *)
     * }
     */
    public static final AddressLayout cond_free$layout() {
        return cond_free$LAYOUT;
    }

    private static final long cond_free$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*cond_free)(GCond *)
     * }
     */
    public static final long cond_free$offset() {
        return cond_free$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*cond_free)(GCond *)
     * }
     */
    public static MemorySegment cond_free(MemorySegment struct) {
        return struct.get(cond_free$LAYOUT, cond_free$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*cond_free)(GCond *)
     * }
     */
    public static void cond_free(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(cond_free$LAYOUT, cond_free$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GPrivate *(*private_new)(GDestroyNotify)
     * }
     */
    public class private_new {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(private_new.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(private_new.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout private_new$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("private_new"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GPrivate *(*private_new)(GDestroyNotify)
     * }
     */
    public static final AddressLayout private_new$layout() {
        return private_new$LAYOUT;
    }

    private static final long private_new$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GPrivate *(*private_new)(GDestroyNotify)
     * }
     */
    public static final long private_new$offset() {
        return private_new$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GPrivate *(*private_new)(GDestroyNotify)
     * }
     */
    public static MemorySegment private_new(MemorySegment struct) {
        return struct.get(private_new$LAYOUT, private_new$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GPrivate *(*private_new)(GDestroyNotify)
     * }
     */
    public static void private_new(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(private_new$LAYOUT, private_new$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gpointer (*private_get)(GPrivate *)
     * }
     */
    public class private_get {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(private_get.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(private_get.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout private_get$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("private_get"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gpointer (*private_get)(GPrivate *)
     * }
     */
    public static final AddressLayout private_get$layout() {
        return private_get$LAYOUT;
    }

    private static final long private_get$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gpointer (*private_get)(GPrivate *)
     * }
     */
    public static final long private_get$offset() {
        return private_get$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gpointer (*private_get)(GPrivate *)
     * }
     */
    public static MemorySegment private_get(MemorySegment struct) {
        return struct.get(private_get$LAYOUT, private_get$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gpointer (*private_get)(GPrivate *)
     * }
     */
    public static void private_get(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(private_get$LAYOUT, private_get$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*private_set)(GPrivate *, gpointer)
     * }
     */
    public class private_set {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(private_set.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(private_set.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout private_set$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("private_set"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*private_set)(GPrivate *, gpointer)
     * }
     */
    public static final AddressLayout private_set$layout() {
        return private_set$LAYOUT;
    }

    private static final long private_set$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*private_set)(GPrivate *, gpointer)
     * }
     */
    public static final long private_set$offset() {
        return private_set$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*private_set)(GPrivate *, gpointer)
     * }
     */
    public static MemorySegment private_set(MemorySegment struct) {
        return struct.get(private_set$LAYOUT, private_set$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*private_set)(GPrivate *, gpointer)
     * }
     */
    public static void private_set(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(private_set$LAYOUT, private_set$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*thread_create)(GThreadFunc, gpointer, gulong, gboolean, gboolean, GThreadPriority, gpointer, GError **)
     * }
     */
    public class thread_create {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, int _x4, int _x5, MemorySegment _x6, MemorySegment _x7);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_LONG,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(thread_create.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(thread_create.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, int _x4, int _x5, MemorySegment _x6, MemorySegment _x7) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout thread_create$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("thread_create"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*thread_create)(GThreadFunc, gpointer, gulong, gboolean, gboolean, GThreadPriority, gpointer, GError **)
     * }
     */
    public static final AddressLayout thread_create$layout() {
        return thread_create$LAYOUT;
    }

    private static final long thread_create$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*thread_create)(GThreadFunc, gpointer, gulong, gboolean, gboolean, GThreadPriority, gpointer, GError **)
     * }
     */
    public static final long thread_create$offset() {
        return thread_create$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*thread_create)(GThreadFunc, gpointer, gulong, gboolean, gboolean, GThreadPriority, gpointer, GError **)
     * }
     */
    public static MemorySegment thread_create(MemorySegment struct) {
        return struct.get(thread_create$LAYOUT, thread_create$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*thread_create)(GThreadFunc, gpointer, gulong, gboolean, gboolean, GThreadPriority, gpointer, GError **)
     * }
     */
    public static void thread_create(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(thread_create$LAYOUT, thread_create$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*thread_yield)(void)
     * }
     */
    public class thread_yield {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid();

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(thread_yield.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(thread_yield.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr) {
            try {
                 DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout thread_yield$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("thread_yield"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*thread_yield)(void)
     * }
     */
    public static final AddressLayout thread_yield$layout() {
        return thread_yield$LAYOUT;
    }

    private static final long thread_yield$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*thread_yield)(void)
     * }
     */
    public static final long thread_yield$offset() {
        return thread_yield$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*thread_yield)(void)
     * }
     */
    public static MemorySegment thread_yield(MemorySegment struct) {
        return struct.get(thread_yield$LAYOUT, thread_yield$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*thread_yield)(void)
     * }
     */
    public static void thread_yield(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(thread_yield$LAYOUT, thread_yield$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*thread_join)(gpointer)
     * }
     */
    public class thread_join {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(thread_join.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(thread_join.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout thread_join$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("thread_join"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*thread_join)(gpointer)
     * }
     */
    public static final AddressLayout thread_join$layout() {
        return thread_join$LAYOUT;
    }

    private static final long thread_join$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*thread_join)(gpointer)
     * }
     */
    public static final long thread_join$offset() {
        return thread_join$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*thread_join)(gpointer)
     * }
     */
    public static MemorySegment thread_join(MemorySegment struct) {
        return struct.get(thread_join$LAYOUT, thread_join$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*thread_join)(gpointer)
     * }
     */
    public static void thread_join(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(thread_join$LAYOUT, thread_join$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*thread_exit)(void)
     * }
     */
    public class thread_exit {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid();

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(thread_exit.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(thread_exit.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr) {
            try {
                 DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout thread_exit$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("thread_exit"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*thread_exit)(void)
     * }
     */
    public static final AddressLayout thread_exit$layout() {
        return thread_exit$LAYOUT;
    }

    private static final long thread_exit$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*thread_exit)(void)
     * }
     */
    public static final long thread_exit$offset() {
        return thread_exit$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*thread_exit)(void)
     * }
     */
    public static MemorySegment thread_exit(MemorySegment struct) {
        return struct.get(thread_exit$LAYOUT, thread_exit$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*thread_exit)(void)
     * }
     */
    public static void thread_exit(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(thread_exit$LAYOUT, thread_exit$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*thread_set_priority)(gpointer, GThreadPriority)
     * }
     */
    public class thread_set_priority {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(thread_set_priority.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(thread_set_priority.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout thread_set_priority$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("thread_set_priority"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*thread_set_priority)(gpointer, GThreadPriority)
     * }
     */
    public static final AddressLayout thread_set_priority$layout() {
        return thread_set_priority$LAYOUT;
    }

    private static final long thread_set_priority$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*thread_set_priority)(gpointer, GThreadPriority)
     * }
     */
    public static final long thread_set_priority$offset() {
        return thread_set_priority$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*thread_set_priority)(gpointer, GThreadPriority)
     * }
     */
    public static MemorySegment thread_set_priority(MemorySegment struct) {
        return struct.get(thread_set_priority$LAYOUT, thread_set_priority$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*thread_set_priority)(gpointer, GThreadPriority)
     * }
     */
    public static void thread_set_priority(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(thread_set_priority$LAYOUT, thread_set_priority$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*thread_self)(gpointer)
     * }
     */
    public class thread_self {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(thread_self.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(thread_self.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout thread_self$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("thread_self"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*thread_self)(gpointer)
     * }
     */
    public static final AddressLayout thread_self$layout() {
        return thread_self$LAYOUT;
    }

    private static final long thread_self$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*thread_self)(gpointer)
     * }
     */
    public static final long thread_self$offset() {
        return thread_self$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*thread_self)(gpointer)
     * }
     */
    public static MemorySegment thread_self(MemorySegment struct) {
        return struct.get(thread_self$LAYOUT, thread_self$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*thread_self)(gpointer)
     * }
     */
    public static void thread_self(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(thread_self$LAYOUT, thread_self$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*thread_equal)(gpointer, gpointer)
     * }
     */
    public class thread_equal {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(thread_equal.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(thread_equal.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout thread_equal$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("thread_equal"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*thread_equal)(gpointer, gpointer)
     * }
     */
    public static final AddressLayout thread_equal$layout() {
        return thread_equal$LAYOUT;
    }

    private static final long thread_equal$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*thread_equal)(gpointer, gpointer)
     * }
     */
    public static final long thread_equal$offset() {
        return thread_equal$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*thread_equal)(gpointer, gpointer)
     * }
     */
    public static MemorySegment thread_equal(MemorySegment struct) {
        return struct.get(thread_equal$LAYOUT, thread_equal$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*thread_equal)(gpointer, gpointer)
     * }
     */
    public static void thread_equal(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(thread_equal$LAYOUT, thread_equal$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

