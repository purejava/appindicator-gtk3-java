// Generated by jextract

package org.purejava.appindicator;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct _AtkTextIface {
 *     GTypeInterface parent;
 *     gchar *(*get_text)(AtkText *, gint, gint);
 *     gchar *(*get_text_after_offset)(AtkText *, gint, AtkTextBoundary, gint *, gint *);
 *     gchar *(*get_text_at_offset)(AtkText *, gint, AtkTextBoundary, gint *, gint *);
 *     gunichar (*get_character_at_offset)(AtkText *, gint);
 *     gchar *(*get_text_before_offset)(AtkText *, gint, AtkTextBoundary, gint *, gint *);
 *     gint (*get_caret_offset)(AtkText *);
 *     AtkAttributeSet *(*get_run_attributes)(AtkText *, gint, gint *, gint *);
 *     AtkAttributeSet *(*get_default_attributes)(AtkText *);
 *     void (*get_character_extents)(AtkText *, gint, gint *, gint *, gint *, gint *, AtkCoordType);
 *     gint (*get_character_count)(AtkText *);
 *     gint (*get_offset_at_point)(AtkText *, gint, gint, AtkCoordType);
 *     gint (*get_n_selections)(AtkText *);
 *     gchar *(*get_selection)(AtkText *, gint, gint *, gint *);
 *     gboolean (*add_selection)(AtkText *, gint, gint);
 *     gboolean (*remove_selection)(AtkText *, gint);
 *     gboolean (*set_selection)(AtkText *, gint, gint, gint);
 *     gboolean (*set_caret_offset)(AtkText *, gint);
 *     void (*text_changed)(AtkText *, gint, gint);
 *     void (*text_caret_moved)(AtkText *, gint);
 *     void (*text_selection_changed)(AtkText *);
 *     void (*text_attributes_changed)(AtkText *);
 *     void (*get_range_extents)(AtkText *, gint, gint, AtkCoordType, AtkTextRectangle *);
 *     AtkTextRange **(*get_bounded_ranges)(AtkText *, AtkTextRectangle *, AtkCoordType, AtkTextClipType, AtkTextClipType);
 *     gchar *(*get_string_at_offset)(AtkText *, gint, AtkTextGranularity, gint *, gint *);
 *     gboolean (*scroll_substring_to)(AtkText *, gint, gint, AtkScrollType);
 *     gboolean (*scroll_substring_to_point)(AtkText *, gint, gint, AtkCoordType, gint, gint);
 * }
 * }
 */
public class _AtkTextIface {

    _AtkTextIface() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        _GTypeInterface.layout().withName("parent"),
        app_indicator_h.C_POINTER.withName("get_text"),
        app_indicator_h.C_POINTER.withName("get_text_after_offset"),
        app_indicator_h.C_POINTER.withName("get_text_at_offset"),
        app_indicator_h.C_POINTER.withName("get_character_at_offset"),
        app_indicator_h.C_POINTER.withName("get_text_before_offset"),
        app_indicator_h.C_POINTER.withName("get_caret_offset"),
        app_indicator_h.C_POINTER.withName("get_run_attributes"),
        app_indicator_h.C_POINTER.withName("get_default_attributes"),
        app_indicator_h.C_POINTER.withName("get_character_extents"),
        app_indicator_h.C_POINTER.withName("get_character_count"),
        app_indicator_h.C_POINTER.withName("get_offset_at_point"),
        app_indicator_h.C_POINTER.withName("get_n_selections"),
        app_indicator_h.C_POINTER.withName("get_selection"),
        app_indicator_h.C_POINTER.withName("add_selection"),
        app_indicator_h.C_POINTER.withName("remove_selection"),
        app_indicator_h.C_POINTER.withName("set_selection"),
        app_indicator_h.C_POINTER.withName("set_caret_offset"),
        app_indicator_h.C_POINTER.withName("text_changed"),
        app_indicator_h.C_POINTER.withName("text_caret_moved"),
        app_indicator_h.C_POINTER.withName("text_selection_changed"),
        app_indicator_h.C_POINTER.withName("text_attributes_changed"),
        app_indicator_h.C_POINTER.withName("get_range_extents"),
        app_indicator_h.C_POINTER.withName("get_bounded_ranges"),
        app_indicator_h.C_POINTER.withName("get_string_at_offset"),
        app_indicator_h.C_POINTER.withName("scroll_substring_to"),
        app_indicator_h.C_POINTER.withName("scroll_substring_to_point")
    ).withName("_AtkTextIface");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final GroupLayout parent$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("parent"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GTypeInterface parent
     * }
     */
    public static final GroupLayout parent$layout() {
        return parent$LAYOUT;
    }

    private static final long parent$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GTypeInterface parent
     * }
     */
    public static final long parent$offset() {
        return parent$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GTypeInterface parent
     * }
     */
    public static MemorySegment parent(MemorySegment struct) {
        return struct.asSlice(parent$OFFSET, parent$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GTypeInterface parent
     * }
     */
    public static void parent(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, parent$OFFSET, parent$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * gchar *(*get_text)(AtkText *, gint, gint)
     * }
     */
    public class get_text {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_text.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_text.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_text$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_text"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gchar *(*get_text)(AtkText *, gint, gint)
     * }
     */
    public static final AddressLayout get_text$layout() {
        return get_text$LAYOUT;
    }

    private static final long get_text$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gchar *(*get_text)(AtkText *, gint, gint)
     * }
     */
    public static final long get_text$offset() {
        return get_text$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gchar *(*get_text)(AtkText *, gint, gint)
     * }
     */
    public static MemorySegment get_text(MemorySegment struct) {
        return struct.get(get_text$LAYOUT, get_text$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gchar *(*get_text)(AtkText *, gint, gint)
     * }
     */
    public static void get_text(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_text$LAYOUT, get_text$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gchar *(*get_text_after_offset)(AtkText *, gint, AtkTextBoundary, gint *, gint *)
     * }
     */
    public class get_text_after_offset {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_text_after_offset.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_text_after_offset.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_text_after_offset$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_text_after_offset"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gchar *(*get_text_after_offset)(AtkText *, gint, AtkTextBoundary, gint *, gint *)
     * }
     */
    public static final AddressLayout get_text_after_offset$layout() {
        return get_text_after_offset$LAYOUT;
    }

    private static final long get_text_after_offset$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gchar *(*get_text_after_offset)(AtkText *, gint, AtkTextBoundary, gint *, gint *)
     * }
     */
    public static final long get_text_after_offset$offset() {
        return get_text_after_offset$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gchar *(*get_text_after_offset)(AtkText *, gint, AtkTextBoundary, gint *, gint *)
     * }
     */
    public static MemorySegment get_text_after_offset(MemorySegment struct) {
        return struct.get(get_text_after_offset$LAYOUT, get_text_after_offset$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gchar *(*get_text_after_offset)(AtkText *, gint, AtkTextBoundary, gint *, gint *)
     * }
     */
    public static void get_text_after_offset(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_text_after_offset$LAYOUT, get_text_after_offset$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gchar *(*get_text_at_offset)(AtkText *, gint, AtkTextBoundary, gint *, gint *)
     * }
     */
    public class get_text_at_offset {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_text_at_offset.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_text_at_offset.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_text_at_offset$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_text_at_offset"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gchar *(*get_text_at_offset)(AtkText *, gint, AtkTextBoundary, gint *, gint *)
     * }
     */
    public static final AddressLayout get_text_at_offset$layout() {
        return get_text_at_offset$LAYOUT;
    }

    private static final long get_text_at_offset$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gchar *(*get_text_at_offset)(AtkText *, gint, AtkTextBoundary, gint *, gint *)
     * }
     */
    public static final long get_text_at_offset$offset() {
        return get_text_at_offset$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gchar *(*get_text_at_offset)(AtkText *, gint, AtkTextBoundary, gint *, gint *)
     * }
     */
    public static MemorySegment get_text_at_offset(MemorySegment struct) {
        return struct.get(get_text_at_offset$LAYOUT, get_text_at_offset$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gchar *(*get_text_at_offset)(AtkText *, gint, AtkTextBoundary, gint *, gint *)
     * }
     */
    public static void get_text_at_offset(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_text_at_offset$LAYOUT, get_text_at_offset$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gunichar (*get_character_at_offset)(AtkText *, gint)
     * }
     */
    public class get_character_at_offset {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_character_at_offset.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_character_at_offset.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_character_at_offset$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_character_at_offset"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gunichar (*get_character_at_offset)(AtkText *, gint)
     * }
     */
    public static final AddressLayout get_character_at_offset$layout() {
        return get_character_at_offset$LAYOUT;
    }

    private static final long get_character_at_offset$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gunichar (*get_character_at_offset)(AtkText *, gint)
     * }
     */
    public static final long get_character_at_offset$offset() {
        return get_character_at_offset$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gunichar (*get_character_at_offset)(AtkText *, gint)
     * }
     */
    public static MemorySegment get_character_at_offset(MemorySegment struct) {
        return struct.get(get_character_at_offset$LAYOUT, get_character_at_offset$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gunichar (*get_character_at_offset)(AtkText *, gint)
     * }
     */
    public static void get_character_at_offset(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_character_at_offset$LAYOUT, get_character_at_offset$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gchar *(*get_text_before_offset)(AtkText *, gint, AtkTextBoundary, gint *, gint *)
     * }
     */
    public class get_text_before_offset {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_text_before_offset.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_text_before_offset.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_text_before_offset$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_text_before_offset"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gchar *(*get_text_before_offset)(AtkText *, gint, AtkTextBoundary, gint *, gint *)
     * }
     */
    public static final AddressLayout get_text_before_offset$layout() {
        return get_text_before_offset$LAYOUT;
    }

    private static final long get_text_before_offset$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gchar *(*get_text_before_offset)(AtkText *, gint, AtkTextBoundary, gint *, gint *)
     * }
     */
    public static final long get_text_before_offset$offset() {
        return get_text_before_offset$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gchar *(*get_text_before_offset)(AtkText *, gint, AtkTextBoundary, gint *, gint *)
     * }
     */
    public static MemorySegment get_text_before_offset(MemorySegment struct) {
        return struct.get(get_text_before_offset$LAYOUT, get_text_before_offset$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gchar *(*get_text_before_offset)(AtkText *, gint, AtkTextBoundary, gint *, gint *)
     * }
     */
    public static void get_text_before_offset(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_text_before_offset$LAYOUT, get_text_before_offset$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gint (*get_caret_offset)(AtkText *)
     * }
     */
    public class get_caret_offset {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_caret_offset.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_caret_offset.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_caret_offset$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_caret_offset"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gint (*get_caret_offset)(AtkText *)
     * }
     */
    public static final AddressLayout get_caret_offset$layout() {
        return get_caret_offset$LAYOUT;
    }

    private static final long get_caret_offset$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gint (*get_caret_offset)(AtkText *)
     * }
     */
    public static final long get_caret_offset$offset() {
        return get_caret_offset$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gint (*get_caret_offset)(AtkText *)
     * }
     */
    public static MemorySegment get_caret_offset(MemorySegment struct) {
        return struct.get(get_caret_offset$LAYOUT, get_caret_offset$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gint (*get_caret_offset)(AtkText *)
     * }
     */
    public static void get_caret_offset(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_caret_offset$LAYOUT, get_caret_offset$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * AtkAttributeSet *(*get_run_attributes)(AtkText *, gint, gint *, gint *)
     * }
     */
    public class get_run_attributes {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_run_attributes.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_run_attributes.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_run_attributes$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_run_attributes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AtkAttributeSet *(*get_run_attributes)(AtkText *, gint, gint *, gint *)
     * }
     */
    public static final AddressLayout get_run_attributes$layout() {
        return get_run_attributes$LAYOUT;
    }

    private static final long get_run_attributes$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AtkAttributeSet *(*get_run_attributes)(AtkText *, gint, gint *, gint *)
     * }
     */
    public static final long get_run_attributes$offset() {
        return get_run_attributes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AtkAttributeSet *(*get_run_attributes)(AtkText *, gint, gint *, gint *)
     * }
     */
    public static MemorySegment get_run_attributes(MemorySegment struct) {
        return struct.get(get_run_attributes$LAYOUT, get_run_attributes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AtkAttributeSet *(*get_run_attributes)(AtkText *, gint, gint *, gint *)
     * }
     */
    public static void get_run_attributes(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_run_attributes$LAYOUT, get_run_attributes$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * AtkAttributeSet *(*get_default_attributes)(AtkText *)
     * }
     */
    public class get_default_attributes {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_default_attributes.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_default_attributes.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_default_attributes$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_default_attributes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AtkAttributeSet *(*get_default_attributes)(AtkText *)
     * }
     */
    public static final AddressLayout get_default_attributes$layout() {
        return get_default_attributes$LAYOUT;
    }

    private static final long get_default_attributes$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AtkAttributeSet *(*get_default_attributes)(AtkText *)
     * }
     */
    public static final long get_default_attributes$offset() {
        return get_default_attributes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AtkAttributeSet *(*get_default_attributes)(AtkText *)
     * }
     */
    public static MemorySegment get_default_attributes(MemorySegment struct) {
        return struct.get(get_default_attributes$LAYOUT, get_default_attributes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AtkAttributeSet *(*get_default_attributes)(AtkText *)
     * }
     */
    public static void get_default_attributes(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_default_attributes$LAYOUT, get_default_attributes$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*get_character_extents)(AtkText *, gint, gint *, gint *, gint *, gint *, AtkCoordType)
     * }
     */
    public class get_character_extents {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, int _x6);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_character_extents.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_character_extents.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, int _x6) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_character_extents$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_character_extents"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*get_character_extents)(AtkText *, gint, gint *, gint *, gint *, gint *, AtkCoordType)
     * }
     */
    public static final AddressLayout get_character_extents$layout() {
        return get_character_extents$LAYOUT;
    }

    private static final long get_character_extents$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*get_character_extents)(AtkText *, gint, gint *, gint *, gint *, gint *, AtkCoordType)
     * }
     */
    public static final long get_character_extents$offset() {
        return get_character_extents$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*get_character_extents)(AtkText *, gint, gint *, gint *, gint *, gint *, AtkCoordType)
     * }
     */
    public static MemorySegment get_character_extents(MemorySegment struct) {
        return struct.get(get_character_extents$LAYOUT, get_character_extents$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*get_character_extents)(AtkText *, gint, gint *, gint *, gint *, gint *, AtkCoordType)
     * }
     */
    public static void get_character_extents(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_character_extents$LAYOUT, get_character_extents$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gint (*get_character_count)(AtkText *)
     * }
     */
    public class get_character_count {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_character_count.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_character_count.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_character_count$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_character_count"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gint (*get_character_count)(AtkText *)
     * }
     */
    public static final AddressLayout get_character_count$layout() {
        return get_character_count$LAYOUT;
    }

    private static final long get_character_count$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gint (*get_character_count)(AtkText *)
     * }
     */
    public static final long get_character_count$offset() {
        return get_character_count$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gint (*get_character_count)(AtkText *)
     * }
     */
    public static MemorySegment get_character_count(MemorySegment struct) {
        return struct.get(get_character_count$LAYOUT, get_character_count$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gint (*get_character_count)(AtkText *)
     * }
     */
    public static void get_character_count(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_character_count$LAYOUT, get_character_count$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gint (*get_offset_at_point)(AtkText *, gint, gint, AtkCoordType)
     * }
     */
    public class get_offset_at_point {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_offset_at_point.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_offset_at_point.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, int _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_offset_at_point$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_offset_at_point"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gint (*get_offset_at_point)(AtkText *, gint, gint, AtkCoordType)
     * }
     */
    public static final AddressLayout get_offset_at_point$layout() {
        return get_offset_at_point$LAYOUT;
    }

    private static final long get_offset_at_point$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gint (*get_offset_at_point)(AtkText *, gint, gint, AtkCoordType)
     * }
     */
    public static final long get_offset_at_point$offset() {
        return get_offset_at_point$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gint (*get_offset_at_point)(AtkText *, gint, gint, AtkCoordType)
     * }
     */
    public static MemorySegment get_offset_at_point(MemorySegment struct) {
        return struct.get(get_offset_at_point$LAYOUT, get_offset_at_point$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gint (*get_offset_at_point)(AtkText *, gint, gint, AtkCoordType)
     * }
     */
    public static void get_offset_at_point(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_offset_at_point$LAYOUT, get_offset_at_point$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gint (*get_n_selections)(AtkText *)
     * }
     */
    public class get_n_selections {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_n_selections.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_n_selections.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_n_selections$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_n_selections"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gint (*get_n_selections)(AtkText *)
     * }
     */
    public static final AddressLayout get_n_selections$layout() {
        return get_n_selections$LAYOUT;
    }

    private static final long get_n_selections$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gint (*get_n_selections)(AtkText *)
     * }
     */
    public static final long get_n_selections$offset() {
        return get_n_selections$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gint (*get_n_selections)(AtkText *)
     * }
     */
    public static MemorySegment get_n_selections(MemorySegment struct) {
        return struct.get(get_n_selections$LAYOUT, get_n_selections$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gint (*get_n_selections)(AtkText *)
     * }
     */
    public static void get_n_selections(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_n_selections$LAYOUT, get_n_selections$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gchar *(*get_selection)(AtkText *, gint, gint *, gint *)
     * }
     */
    public class get_selection {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_selection.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_selection.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_selection$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_selection"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gchar *(*get_selection)(AtkText *, gint, gint *, gint *)
     * }
     */
    public static final AddressLayout get_selection$layout() {
        return get_selection$LAYOUT;
    }

    private static final long get_selection$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gchar *(*get_selection)(AtkText *, gint, gint *, gint *)
     * }
     */
    public static final long get_selection$offset() {
        return get_selection$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gchar *(*get_selection)(AtkText *, gint, gint *, gint *)
     * }
     */
    public static MemorySegment get_selection(MemorySegment struct) {
        return struct.get(get_selection$LAYOUT, get_selection$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gchar *(*get_selection)(AtkText *, gint, gint *, gint *)
     * }
     */
    public static void get_selection(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_selection$LAYOUT, get_selection$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*add_selection)(AtkText *, gint, gint)
     * }
     */
    public class add_selection {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(add_selection.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(add_selection.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout add_selection$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("add_selection"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*add_selection)(AtkText *, gint, gint)
     * }
     */
    public static final AddressLayout add_selection$layout() {
        return add_selection$LAYOUT;
    }

    private static final long add_selection$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*add_selection)(AtkText *, gint, gint)
     * }
     */
    public static final long add_selection$offset() {
        return add_selection$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*add_selection)(AtkText *, gint, gint)
     * }
     */
    public static MemorySegment add_selection(MemorySegment struct) {
        return struct.get(add_selection$LAYOUT, add_selection$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*add_selection)(AtkText *, gint, gint)
     * }
     */
    public static void add_selection(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(add_selection$LAYOUT, add_selection$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*remove_selection)(AtkText *, gint)
     * }
     */
    public class remove_selection {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(remove_selection.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(remove_selection.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout remove_selection$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("remove_selection"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*remove_selection)(AtkText *, gint)
     * }
     */
    public static final AddressLayout remove_selection$layout() {
        return remove_selection$LAYOUT;
    }

    private static final long remove_selection$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*remove_selection)(AtkText *, gint)
     * }
     */
    public static final long remove_selection$offset() {
        return remove_selection$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*remove_selection)(AtkText *, gint)
     * }
     */
    public static MemorySegment remove_selection(MemorySegment struct) {
        return struct.get(remove_selection$LAYOUT, remove_selection$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*remove_selection)(AtkText *, gint)
     * }
     */
    public static void remove_selection(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(remove_selection$LAYOUT, remove_selection$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*set_selection)(AtkText *, gint, gint, gint)
     * }
     */
    public class set_selection {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(set_selection.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(set_selection.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, int _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_selection$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_selection"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*set_selection)(AtkText *, gint, gint, gint)
     * }
     */
    public static final AddressLayout set_selection$layout() {
        return set_selection$LAYOUT;
    }

    private static final long set_selection$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*set_selection)(AtkText *, gint, gint, gint)
     * }
     */
    public static final long set_selection$offset() {
        return set_selection$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*set_selection)(AtkText *, gint, gint, gint)
     * }
     */
    public static MemorySegment set_selection(MemorySegment struct) {
        return struct.get(set_selection$LAYOUT, set_selection$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*set_selection)(AtkText *, gint, gint, gint)
     * }
     */
    public static void set_selection(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_selection$LAYOUT, set_selection$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*set_caret_offset)(AtkText *, gint)
     * }
     */
    public class set_caret_offset {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(set_caret_offset.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(set_caret_offset.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_caret_offset$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_caret_offset"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*set_caret_offset)(AtkText *, gint)
     * }
     */
    public static final AddressLayout set_caret_offset$layout() {
        return set_caret_offset$LAYOUT;
    }

    private static final long set_caret_offset$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*set_caret_offset)(AtkText *, gint)
     * }
     */
    public static final long set_caret_offset$offset() {
        return set_caret_offset$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*set_caret_offset)(AtkText *, gint)
     * }
     */
    public static MemorySegment set_caret_offset(MemorySegment struct) {
        return struct.get(set_caret_offset$LAYOUT, set_caret_offset$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*set_caret_offset)(AtkText *, gint)
     * }
     */
    public static void set_caret_offset(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_caret_offset$LAYOUT, set_caret_offset$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*text_changed)(AtkText *, gint, gint)
     * }
     */
    public class text_changed {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(text_changed.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(text_changed.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout text_changed$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("text_changed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*text_changed)(AtkText *, gint, gint)
     * }
     */
    public static final AddressLayout text_changed$layout() {
        return text_changed$LAYOUT;
    }

    private static final long text_changed$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*text_changed)(AtkText *, gint, gint)
     * }
     */
    public static final long text_changed$offset() {
        return text_changed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*text_changed)(AtkText *, gint, gint)
     * }
     */
    public static MemorySegment text_changed(MemorySegment struct) {
        return struct.get(text_changed$LAYOUT, text_changed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*text_changed)(AtkText *, gint, gint)
     * }
     */
    public static void text_changed(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(text_changed$LAYOUT, text_changed$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*text_caret_moved)(AtkText *, gint)
     * }
     */
    public class text_caret_moved {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(text_caret_moved.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(text_caret_moved.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout text_caret_moved$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("text_caret_moved"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*text_caret_moved)(AtkText *, gint)
     * }
     */
    public static final AddressLayout text_caret_moved$layout() {
        return text_caret_moved$LAYOUT;
    }

    private static final long text_caret_moved$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*text_caret_moved)(AtkText *, gint)
     * }
     */
    public static final long text_caret_moved$offset() {
        return text_caret_moved$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*text_caret_moved)(AtkText *, gint)
     * }
     */
    public static MemorySegment text_caret_moved(MemorySegment struct) {
        return struct.get(text_caret_moved$LAYOUT, text_caret_moved$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*text_caret_moved)(AtkText *, gint)
     * }
     */
    public static void text_caret_moved(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(text_caret_moved$LAYOUT, text_caret_moved$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*text_selection_changed)(AtkText *)
     * }
     */
    public class text_selection_changed {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(text_selection_changed.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(text_selection_changed.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout text_selection_changed$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("text_selection_changed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*text_selection_changed)(AtkText *)
     * }
     */
    public static final AddressLayout text_selection_changed$layout() {
        return text_selection_changed$LAYOUT;
    }

    private static final long text_selection_changed$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*text_selection_changed)(AtkText *)
     * }
     */
    public static final long text_selection_changed$offset() {
        return text_selection_changed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*text_selection_changed)(AtkText *)
     * }
     */
    public static MemorySegment text_selection_changed(MemorySegment struct) {
        return struct.get(text_selection_changed$LAYOUT, text_selection_changed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*text_selection_changed)(AtkText *)
     * }
     */
    public static void text_selection_changed(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(text_selection_changed$LAYOUT, text_selection_changed$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*text_attributes_changed)(AtkText *)
     * }
     */
    public class text_attributes_changed {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(text_attributes_changed.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(text_attributes_changed.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout text_attributes_changed$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("text_attributes_changed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*text_attributes_changed)(AtkText *)
     * }
     */
    public static final AddressLayout text_attributes_changed$layout() {
        return text_attributes_changed$LAYOUT;
    }

    private static final long text_attributes_changed$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*text_attributes_changed)(AtkText *)
     * }
     */
    public static final long text_attributes_changed$offset() {
        return text_attributes_changed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*text_attributes_changed)(AtkText *)
     * }
     */
    public static MemorySegment text_attributes_changed(MemorySegment struct) {
        return struct.get(text_attributes_changed$LAYOUT, text_attributes_changed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*text_attributes_changed)(AtkText *)
     * }
     */
    public static void text_attributes_changed(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(text_attributes_changed$LAYOUT, text_attributes_changed$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*get_range_extents)(AtkText *, gint, gint, AtkCoordType, AtkTextRectangle *)
     * }
     */
    public class get_range_extents {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_range_extents.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_range_extents.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_range_extents$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_range_extents"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*get_range_extents)(AtkText *, gint, gint, AtkCoordType, AtkTextRectangle *)
     * }
     */
    public static final AddressLayout get_range_extents$layout() {
        return get_range_extents$LAYOUT;
    }

    private static final long get_range_extents$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*get_range_extents)(AtkText *, gint, gint, AtkCoordType, AtkTextRectangle *)
     * }
     */
    public static final long get_range_extents$offset() {
        return get_range_extents$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*get_range_extents)(AtkText *, gint, gint, AtkCoordType, AtkTextRectangle *)
     * }
     */
    public static MemorySegment get_range_extents(MemorySegment struct) {
        return struct.get(get_range_extents$LAYOUT, get_range_extents$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*get_range_extents)(AtkText *, gint, gint, AtkCoordType, AtkTextRectangle *)
     * }
     */
    public static void get_range_extents(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_range_extents$LAYOUT, get_range_extents$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * AtkTextRange **(*get_bounded_ranges)(AtkText *, AtkTextRectangle *, AtkCoordType, AtkTextClipType, AtkTextClipType)
     * }
     */
    public class get_bounded_ranges {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, int _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_bounded_ranges.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_bounded_ranges.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, int _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_bounded_ranges$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_bounded_ranges"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AtkTextRange **(*get_bounded_ranges)(AtkText *, AtkTextRectangle *, AtkCoordType, AtkTextClipType, AtkTextClipType)
     * }
     */
    public static final AddressLayout get_bounded_ranges$layout() {
        return get_bounded_ranges$LAYOUT;
    }

    private static final long get_bounded_ranges$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AtkTextRange **(*get_bounded_ranges)(AtkText *, AtkTextRectangle *, AtkCoordType, AtkTextClipType, AtkTextClipType)
     * }
     */
    public static final long get_bounded_ranges$offset() {
        return get_bounded_ranges$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AtkTextRange **(*get_bounded_ranges)(AtkText *, AtkTextRectangle *, AtkCoordType, AtkTextClipType, AtkTextClipType)
     * }
     */
    public static MemorySegment get_bounded_ranges(MemorySegment struct) {
        return struct.get(get_bounded_ranges$LAYOUT, get_bounded_ranges$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AtkTextRange **(*get_bounded_ranges)(AtkText *, AtkTextRectangle *, AtkCoordType, AtkTextClipType, AtkTextClipType)
     * }
     */
    public static void get_bounded_ranges(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_bounded_ranges$LAYOUT, get_bounded_ranges$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gchar *(*get_string_at_offset)(AtkText *, gint, AtkTextGranularity, gint *, gint *)
     * }
     */
    public class get_string_at_offset {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_string_at_offset.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_string_at_offset.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_string_at_offset$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_string_at_offset"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gchar *(*get_string_at_offset)(AtkText *, gint, AtkTextGranularity, gint *, gint *)
     * }
     */
    public static final AddressLayout get_string_at_offset$layout() {
        return get_string_at_offset$LAYOUT;
    }

    private static final long get_string_at_offset$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gchar *(*get_string_at_offset)(AtkText *, gint, AtkTextGranularity, gint *, gint *)
     * }
     */
    public static final long get_string_at_offset$offset() {
        return get_string_at_offset$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gchar *(*get_string_at_offset)(AtkText *, gint, AtkTextGranularity, gint *, gint *)
     * }
     */
    public static MemorySegment get_string_at_offset(MemorySegment struct) {
        return struct.get(get_string_at_offset$LAYOUT, get_string_at_offset$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gchar *(*get_string_at_offset)(AtkText *, gint, AtkTextGranularity, gint *, gint *)
     * }
     */
    public static void get_string_at_offset(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_string_at_offset$LAYOUT, get_string_at_offset$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*scroll_substring_to)(AtkText *, gint, gint, AtkScrollType)
     * }
     */
    public class scroll_substring_to {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(scroll_substring_to.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(scroll_substring_to.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, int _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout scroll_substring_to$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("scroll_substring_to"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*scroll_substring_to)(AtkText *, gint, gint, AtkScrollType)
     * }
     */
    public static final AddressLayout scroll_substring_to$layout() {
        return scroll_substring_to$LAYOUT;
    }

    private static final long scroll_substring_to$OFFSET = 208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*scroll_substring_to)(AtkText *, gint, gint, AtkScrollType)
     * }
     */
    public static final long scroll_substring_to$offset() {
        return scroll_substring_to$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*scroll_substring_to)(AtkText *, gint, gint, AtkScrollType)
     * }
     */
    public static MemorySegment scroll_substring_to(MemorySegment struct) {
        return struct.get(scroll_substring_to$LAYOUT, scroll_substring_to$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*scroll_substring_to)(AtkText *, gint, gint, AtkScrollType)
     * }
     */
    public static void scroll_substring_to(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(scroll_substring_to$LAYOUT, scroll_substring_to$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*scroll_substring_to_point)(AtkText *, gint, gint, AtkCoordType, gint, gint)
     * }
     */
    public class scroll_substring_to_point {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, int _x3, int _x4, int _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(scroll_substring_to_point.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(scroll_substring_to_point.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, int _x3, int _x4, int _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout scroll_substring_to_point$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("scroll_substring_to_point"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*scroll_substring_to_point)(AtkText *, gint, gint, AtkCoordType, gint, gint)
     * }
     */
    public static final AddressLayout scroll_substring_to_point$layout() {
        return scroll_substring_to_point$LAYOUT;
    }

    private static final long scroll_substring_to_point$OFFSET = 216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*scroll_substring_to_point)(AtkText *, gint, gint, AtkCoordType, gint, gint)
     * }
     */
    public static final long scroll_substring_to_point$offset() {
        return scroll_substring_to_point$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*scroll_substring_to_point)(AtkText *, gint, gint, AtkCoordType, gint, gint)
     * }
     */
    public static MemorySegment scroll_substring_to_point(MemorySegment struct) {
        return struct.get(scroll_substring_to_point$LAYOUT, scroll_substring_to_point$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*scroll_substring_to_point)(AtkText *, gint, gint, AtkCoordType, gint, gint)
     * }
     */
    public static void scroll_substring_to_point(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(scroll_substring_to_point$LAYOUT, scroll_substring_to_point$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

