// Generated by jextract

package org.purejava.appindicator;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct _GFileIface {
 *     GTypeInterface g_iface;
 *     GFile *(*dup)(GFile *);
 *     guint (*hash)(GFile *);
 *     gboolean (*equal)(GFile *, GFile *);
 *     gboolean (*is_native)(GFile *);
 *     gboolean (*has_uri_scheme)(GFile *, const char *);
 *     char *(*get_uri_scheme)(GFile *);
 *     char *(*get_basename)(GFile *);
 *     char *(*get_path)(GFile *);
 *     char *(*get_uri)(GFile *);
 *     char *(*get_parse_name)(GFile *);
 *     GFile *(*get_parent)(GFile *);
 *     gboolean (*prefix_matches)(GFile *, GFile *);
 *     char *(*get_relative_path)(GFile *, GFile *);
 *     GFile *(*resolve_relative_path)(GFile *, const char *);
 *     GFile *(*get_child_for_display_name)(GFile *, const char *, GError **);
 *     GFileEnumerator *(*enumerate_children)(GFile *, const char *, GFileQueryInfoFlags, GCancellable *, GError **);
 *     void (*enumerate_children_async)(GFile *, const char *, GFileQueryInfoFlags, int, GCancellable *, GAsyncReadyCallback, gpointer);
 *     GFileEnumerator *(*enumerate_children_finish)(GFile *, GAsyncResult *, GError **);
 *     GFileInfo *(*query_info)(GFile *, const char *, GFileQueryInfoFlags, GCancellable *, GError **);
 *     void (*query_info_async)(GFile *, const char *, GFileQueryInfoFlags, int, GCancellable *, GAsyncReadyCallback, gpointer);
 *     GFileInfo *(*query_info_finish)(GFile *, GAsyncResult *, GError **);
 *     GFileInfo *(*query_filesystem_info)(GFile *, const char *, GCancellable *, GError **);
 *     void (*query_filesystem_info_async)(GFile *, const char *, int, GCancellable *, GAsyncReadyCallback, gpointer);
 *     GFileInfo *(*query_filesystem_info_finish)(GFile *, GAsyncResult *, GError **);
 *     GMount *(*find_enclosing_mount)(GFile *, GCancellable *, GError **);
 *     void (*find_enclosing_mount_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer);
 *     GMount *(*find_enclosing_mount_finish)(GFile *, GAsyncResult *, GError **);
 *     GFile *(*set_display_name)(GFile *, const char *, GCancellable *, GError **);
 *     void (*set_display_name_async)(GFile *, const char *, int, GCancellable *, GAsyncReadyCallback, gpointer);
 *     GFile *(*set_display_name_finish)(GFile *, GAsyncResult *, GError **);
 *     GFileAttributeInfoList *(*query_settable_attributes)(GFile *, GCancellable *, GError **);
 *     void (*_query_settable_attributes_async)(void);
 *     void (*_query_settable_attributes_finish)(void);
 *     GFileAttributeInfoList *(*query_writable_namespaces)(GFile *, GCancellable *, GError **);
 *     void (*_query_writable_namespaces_async)(void);
 *     void (*_query_writable_namespaces_finish)(void);
 *     gboolean (*set_attribute)(GFile *, const char *, GFileAttributeType, gpointer, GFileQueryInfoFlags, GCancellable *, GError **);
 *     gboolean (*set_attributes_from_info)(GFile *, GFileInfo *, GFileQueryInfoFlags, GCancellable *, GError **);
 *     void (*set_attributes_async)(GFile *, GFileInfo *, GFileQueryInfoFlags, int, GCancellable *, GAsyncReadyCallback, gpointer);
 *     gboolean (*set_attributes_finish)(GFile *, GAsyncResult *, GFileInfo **, GError **);
 *     GFileInputStream *(*read_fn)(GFile *, GCancellable *, GError **);
 *     void (*read_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer);
 *     GFileInputStream *(*read_finish)(GFile *, GAsyncResult *, GError **);
 *     GFileOutputStream *(*append_to)(GFile *, GFileCreateFlags, GCancellable *, GError **);
 *     void (*append_to_async)(GFile *, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer);
 *     GFileOutputStream *(*append_to_finish)(GFile *, GAsyncResult *, GError **);
 *     GFileOutputStream *(*create)(GFile *, GFileCreateFlags, GCancellable *, GError **);
 *     void (*create_async)(GFile *, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer);
 *     GFileOutputStream *(*create_finish)(GFile *, GAsyncResult *, GError **);
 *     GFileOutputStream *(*replace)(GFile *, const char *, gboolean, GFileCreateFlags, GCancellable *, GError **);
 *     void (*replace_async)(GFile *, const char *, gboolean, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer);
 *     GFileOutputStream *(*replace_finish)(GFile *, GAsyncResult *, GError **);
 *     gboolean (*delete_file)(GFile *, GCancellable *, GError **);
 *     void (*delete_file_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer);
 *     gboolean (*delete_file_finish)(GFile *, GAsyncResult *, GError **);
 *     gboolean (*trash)(GFile *, GCancellable *, GError **);
 *     void (*trash_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer);
 *     gboolean (*trash_finish)(GFile *, GAsyncResult *, GError **);
 *     gboolean (*make_directory)(GFile *, GCancellable *, GError **);
 *     void (*make_directory_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer);
 *     gboolean (*make_directory_finish)(GFile *, GAsyncResult *, GError **);
 *     gboolean (*make_symbolic_link)(GFile *, const char *, GCancellable *, GError **);
 *     void (*make_symbolic_link_async)(GFile *, const char *, int, GCancellable *, GAsyncReadyCallback, gpointer);
 *     gboolean (*make_symbolic_link_finish)(GFile *, GAsyncResult *, GError **);
 *     gboolean (*copy)(GFile *, GFile *, GFileCopyFlags, GCancellable *, GFileProgressCallback, gpointer, GError **);
 *     void (*copy_async)(GFile *, GFile *, GFileCopyFlags, int, GCancellable *, GFileProgressCallback, gpointer, GAsyncReadyCallback, gpointer);
 *     gboolean (*copy_finish)(GFile *, GAsyncResult *, GError **);
 *     gboolean (*move)(GFile *, GFile *, GFileCopyFlags, GCancellable *, GFileProgressCallback, gpointer, GError **);
 *     void (*move_async)(GFile *, GFile *, GFileCopyFlags, int, GCancellable *, GFileProgressCallback, gpointer, GAsyncReadyCallback, gpointer);
 *     gboolean (*move_finish)(GFile *, GAsyncResult *, GError **);
 *     void (*mount_mountable)(GFile *, GMountMountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer);
 *     GFile *(*mount_mountable_finish)(GFile *, GAsyncResult *, GError **);
 *     void (*unmount_mountable)(GFile *, GMountUnmountFlags, GCancellable *, GAsyncReadyCallback, gpointer);
 *     gboolean (*unmount_mountable_finish)(GFile *, GAsyncResult *, GError **);
 *     void (*eject_mountable)(GFile *, GMountUnmountFlags, GCancellable *, GAsyncReadyCallback, gpointer);
 *     gboolean (*eject_mountable_finish)(GFile *, GAsyncResult *, GError **);
 *     void (*mount_enclosing_volume)(GFile *, GMountMountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer);
 *     gboolean (*mount_enclosing_volume_finish)(GFile *, GAsyncResult *, GError **);
 *     GFileMonitor *(*monitor_dir)(GFile *, GFileMonitorFlags, GCancellable *, GError **);
 *     GFileMonitor *(*monitor_file)(GFile *, GFileMonitorFlags, GCancellable *, GError **);
 *     GFileIOStream *(*open_readwrite)(GFile *, GCancellable *, GError **);
 *     void (*open_readwrite_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer);
 *     GFileIOStream *(*open_readwrite_finish)(GFile *, GAsyncResult *, GError **);
 *     GFileIOStream *(*create_readwrite)(GFile *, GFileCreateFlags, GCancellable *, GError **);
 *     void (*create_readwrite_async)(GFile *, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer);
 *     GFileIOStream *(*create_readwrite_finish)(GFile *, GAsyncResult *, GError **);
 *     GFileIOStream *(*replace_readwrite)(GFile *, const char *, gboolean, GFileCreateFlags, GCancellable *, GError **);
 *     void (*replace_readwrite_async)(GFile *, const char *, gboolean, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer);
 *     GFileIOStream *(*replace_readwrite_finish)(GFile *, GAsyncResult *, GError **);
 *     void (*start_mountable)(GFile *, GDriveStartFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer);
 *     gboolean (*start_mountable_finish)(GFile *, GAsyncResult *, GError **);
 *     void (*stop_mountable)(GFile *, GMountUnmountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer);
 *     gboolean (*stop_mountable_finish)(GFile *, GAsyncResult *, GError **);
 *     gboolean supports_thread_contexts;
 *     void (*unmount_mountable_with_operation)(GFile *, GMountUnmountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer);
 *     gboolean (*unmount_mountable_with_operation_finish)(GFile *, GAsyncResult *, GError **);
 *     void (*eject_mountable_with_operation)(GFile *, GMountUnmountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer);
 *     gboolean (*eject_mountable_with_operation_finish)(GFile *, GAsyncResult *, GError **);
 *     void (*poll_mountable)(GFile *, GCancellable *, GAsyncReadyCallback, gpointer);
 *     gboolean (*poll_mountable_finish)(GFile *, GAsyncResult *, GError **);
 *     gboolean (*measure_disk_usage)(GFile *, GFileMeasureFlags, GCancellable *, GFileMeasureProgressCallback, gpointer, guint64 *, guint64 *, guint64 *, GError **);
 *     void (*measure_disk_usage_async)(GFile *, GFileMeasureFlags, gint, GCancellable *, GFileMeasureProgressCallback, gpointer, GAsyncReadyCallback, gpointer);
 *     gboolean (*measure_disk_usage_finish)(GFile *, GAsyncResult *, guint64 *, guint64 *, guint64 *, GError **);
 * }
 * }
 */
public class _GFileIface {

    _GFileIface() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        _GTypeInterface.layout().withName("g_iface"),
        app_indicator_h.C_POINTER.withName("dup"),
        app_indicator_h.C_POINTER.withName("hash"),
        app_indicator_h.C_POINTER.withName("equal"),
        app_indicator_h.C_POINTER.withName("is_native"),
        app_indicator_h.C_POINTER.withName("has_uri_scheme"),
        app_indicator_h.C_POINTER.withName("get_uri_scheme"),
        app_indicator_h.C_POINTER.withName("get_basename"),
        app_indicator_h.C_POINTER.withName("get_path"),
        app_indicator_h.C_POINTER.withName("get_uri"),
        app_indicator_h.C_POINTER.withName("get_parse_name"),
        app_indicator_h.C_POINTER.withName("get_parent"),
        app_indicator_h.C_POINTER.withName("prefix_matches"),
        app_indicator_h.C_POINTER.withName("get_relative_path"),
        app_indicator_h.C_POINTER.withName("resolve_relative_path"),
        app_indicator_h.C_POINTER.withName("get_child_for_display_name"),
        app_indicator_h.C_POINTER.withName("enumerate_children"),
        app_indicator_h.C_POINTER.withName("enumerate_children_async"),
        app_indicator_h.C_POINTER.withName("enumerate_children_finish"),
        app_indicator_h.C_POINTER.withName("query_info"),
        app_indicator_h.C_POINTER.withName("query_info_async"),
        app_indicator_h.C_POINTER.withName("query_info_finish"),
        app_indicator_h.C_POINTER.withName("query_filesystem_info"),
        app_indicator_h.C_POINTER.withName("query_filesystem_info_async"),
        app_indicator_h.C_POINTER.withName("query_filesystem_info_finish"),
        app_indicator_h.C_POINTER.withName("find_enclosing_mount"),
        app_indicator_h.C_POINTER.withName("find_enclosing_mount_async"),
        app_indicator_h.C_POINTER.withName("find_enclosing_mount_finish"),
        app_indicator_h.C_POINTER.withName("set_display_name"),
        app_indicator_h.C_POINTER.withName("set_display_name_async"),
        app_indicator_h.C_POINTER.withName("set_display_name_finish"),
        app_indicator_h.C_POINTER.withName("query_settable_attributes"),
        app_indicator_h.C_POINTER.withName("_query_settable_attributes_async"),
        app_indicator_h.C_POINTER.withName("_query_settable_attributes_finish"),
        app_indicator_h.C_POINTER.withName("query_writable_namespaces"),
        app_indicator_h.C_POINTER.withName("_query_writable_namespaces_async"),
        app_indicator_h.C_POINTER.withName("_query_writable_namespaces_finish"),
        app_indicator_h.C_POINTER.withName("set_attribute"),
        app_indicator_h.C_POINTER.withName("set_attributes_from_info"),
        app_indicator_h.C_POINTER.withName("set_attributes_async"),
        app_indicator_h.C_POINTER.withName("set_attributes_finish"),
        app_indicator_h.C_POINTER.withName("read_fn"),
        app_indicator_h.C_POINTER.withName("read_async"),
        app_indicator_h.C_POINTER.withName("read_finish"),
        app_indicator_h.C_POINTER.withName("append_to"),
        app_indicator_h.C_POINTER.withName("append_to_async"),
        app_indicator_h.C_POINTER.withName("append_to_finish"),
        app_indicator_h.C_POINTER.withName("create"),
        app_indicator_h.C_POINTER.withName("create_async"),
        app_indicator_h.C_POINTER.withName("create_finish"),
        app_indicator_h.C_POINTER.withName("replace"),
        app_indicator_h.C_POINTER.withName("replace_async"),
        app_indicator_h.C_POINTER.withName("replace_finish"),
        app_indicator_h.C_POINTER.withName("delete_file"),
        app_indicator_h.C_POINTER.withName("delete_file_async"),
        app_indicator_h.C_POINTER.withName("delete_file_finish"),
        app_indicator_h.C_POINTER.withName("trash"),
        app_indicator_h.C_POINTER.withName("trash_async"),
        app_indicator_h.C_POINTER.withName("trash_finish"),
        app_indicator_h.C_POINTER.withName("make_directory"),
        app_indicator_h.C_POINTER.withName("make_directory_async"),
        app_indicator_h.C_POINTER.withName("make_directory_finish"),
        app_indicator_h.C_POINTER.withName("make_symbolic_link"),
        app_indicator_h.C_POINTER.withName("make_symbolic_link_async"),
        app_indicator_h.C_POINTER.withName("make_symbolic_link_finish"),
        app_indicator_h.C_POINTER.withName("copy"),
        app_indicator_h.C_POINTER.withName("copy_async"),
        app_indicator_h.C_POINTER.withName("copy_finish"),
        app_indicator_h.C_POINTER.withName("move"),
        app_indicator_h.C_POINTER.withName("move_async"),
        app_indicator_h.C_POINTER.withName("move_finish"),
        app_indicator_h.C_POINTER.withName("mount_mountable"),
        app_indicator_h.C_POINTER.withName("mount_mountable_finish"),
        app_indicator_h.C_POINTER.withName("unmount_mountable"),
        app_indicator_h.C_POINTER.withName("unmount_mountable_finish"),
        app_indicator_h.C_POINTER.withName("eject_mountable"),
        app_indicator_h.C_POINTER.withName("eject_mountable_finish"),
        app_indicator_h.C_POINTER.withName("mount_enclosing_volume"),
        app_indicator_h.C_POINTER.withName("mount_enclosing_volume_finish"),
        app_indicator_h.C_POINTER.withName("monitor_dir"),
        app_indicator_h.C_POINTER.withName("monitor_file"),
        app_indicator_h.C_POINTER.withName("open_readwrite"),
        app_indicator_h.C_POINTER.withName("open_readwrite_async"),
        app_indicator_h.C_POINTER.withName("open_readwrite_finish"),
        app_indicator_h.C_POINTER.withName("create_readwrite"),
        app_indicator_h.C_POINTER.withName("create_readwrite_async"),
        app_indicator_h.C_POINTER.withName("create_readwrite_finish"),
        app_indicator_h.C_POINTER.withName("replace_readwrite"),
        app_indicator_h.C_POINTER.withName("replace_readwrite_async"),
        app_indicator_h.C_POINTER.withName("replace_readwrite_finish"),
        app_indicator_h.C_POINTER.withName("start_mountable"),
        app_indicator_h.C_POINTER.withName("start_mountable_finish"),
        app_indicator_h.C_POINTER.withName("stop_mountable"),
        app_indicator_h.C_POINTER.withName("stop_mountable_finish"),
        app_indicator_h.C_INT.withName("supports_thread_contexts"),
        MemoryLayout.paddingLayout(4),
        app_indicator_h.C_POINTER.withName("unmount_mountable_with_operation"),
        app_indicator_h.C_POINTER.withName("unmount_mountable_with_operation_finish"),
        app_indicator_h.C_POINTER.withName("eject_mountable_with_operation"),
        app_indicator_h.C_POINTER.withName("eject_mountable_with_operation_finish"),
        app_indicator_h.C_POINTER.withName("poll_mountable"),
        app_indicator_h.C_POINTER.withName("poll_mountable_finish"),
        app_indicator_h.C_POINTER.withName("measure_disk_usage"),
        app_indicator_h.C_POINTER.withName("measure_disk_usage_async"),
        app_indicator_h.C_POINTER.withName("measure_disk_usage_finish")
    ).withName("_GFileIface");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final GroupLayout g_iface$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("g_iface"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GTypeInterface g_iface
     * }
     */
    public static final GroupLayout g_iface$layout() {
        return g_iface$LAYOUT;
    }

    private static final long g_iface$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GTypeInterface g_iface
     * }
     */
    public static final long g_iface$offset() {
        return g_iface$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GTypeInterface g_iface
     * }
     */
    public static MemorySegment g_iface(MemorySegment struct) {
        return struct.asSlice(g_iface$OFFSET, g_iface$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GTypeInterface g_iface
     * }
     */
    public static void g_iface(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, g_iface$OFFSET, g_iface$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * GFile *(*dup)(GFile *)
     * }
     */
    public class dup {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(dup.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(dup.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout dup$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("dup"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFile *(*dup)(GFile *)
     * }
     */
    public static final AddressLayout dup$layout() {
        return dup$LAYOUT;
    }

    private static final long dup$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFile *(*dup)(GFile *)
     * }
     */
    public static final long dup$offset() {
        return dup$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFile *(*dup)(GFile *)
     * }
     */
    public static MemorySegment dup(MemorySegment struct) {
        return struct.get(dup$LAYOUT, dup$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFile *(*dup)(GFile *)
     * }
     */
    public static void dup(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(dup$LAYOUT, dup$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * guint (*hash)(GFile *)
     * }
     */
    public class hash {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(hash.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(hash.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout hash$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("hash"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * guint (*hash)(GFile *)
     * }
     */
    public static final AddressLayout hash$layout() {
        return hash$LAYOUT;
    }

    private static final long hash$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * guint (*hash)(GFile *)
     * }
     */
    public static final long hash$offset() {
        return hash$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * guint (*hash)(GFile *)
     * }
     */
    public static MemorySegment hash(MemorySegment struct) {
        return struct.get(hash$LAYOUT, hash$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * guint (*hash)(GFile *)
     * }
     */
    public static void hash(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(hash$LAYOUT, hash$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*equal)(GFile *, GFile *)
     * }
     */
    public class equal {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(equal.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(equal.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout equal$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("equal"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*equal)(GFile *, GFile *)
     * }
     */
    public static final AddressLayout equal$layout() {
        return equal$LAYOUT;
    }

    private static final long equal$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*equal)(GFile *, GFile *)
     * }
     */
    public static final long equal$offset() {
        return equal$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*equal)(GFile *, GFile *)
     * }
     */
    public static MemorySegment equal(MemorySegment struct) {
        return struct.get(equal$LAYOUT, equal$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*equal)(GFile *, GFile *)
     * }
     */
    public static void equal(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(equal$LAYOUT, equal$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*is_native)(GFile *)
     * }
     */
    public class is_native {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(is_native.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(is_native.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout is_native$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("is_native"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*is_native)(GFile *)
     * }
     */
    public static final AddressLayout is_native$layout() {
        return is_native$LAYOUT;
    }

    private static final long is_native$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*is_native)(GFile *)
     * }
     */
    public static final long is_native$offset() {
        return is_native$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*is_native)(GFile *)
     * }
     */
    public static MemorySegment is_native(MemorySegment struct) {
        return struct.get(is_native$LAYOUT, is_native$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*is_native)(GFile *)
     * }
     */
    public static void is_native(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(is_native$LAYOUT, is_native$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*has_uri_scheme)(GFile *, const char *)
     * }
     */
    public class has_uri_scheme {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(has_uri_scheme.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(has_uri_scheme.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout has_uri_scheme$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("has_uri_scheme"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*has_uri_scheme)(GFile *, const char *)
     * }
     */
    public static final AddressLayout has_uri_scheme$layout() {
        return has_uri_scheme$LAYOUT;
    }

    private static final long has_uri_scheme$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*has_uri_scheme)(GFile *, const char *)
     * }
     */
    public static final long has_uri_scheme$offset() {
        return has_uri_scheme$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*has_uri_scheme)(GFile *, const char *)
     * }
     */
    public static MemorySegment has_uri_scheme(MemorySegment struct) {
        return struct.get(has_uri_scheme$LAYOUT, has_uri_scheme$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*has_uri_scheme)(GFile *, const char *)
     * }
     */
    public static void has_uri_scheme(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(has_uri_scheme$LAYOUT, has_uri_scheme$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * char *(*get_uri_scheme)(GFile *)
     * }
     */
    public class get_uri_scheme {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_uri_scheme.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_uri_scheme.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_uri_scheme$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_uri_scheme"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *(*get_uri_scheme)(GFile *)
     * }
     */
    public static final AddressLayout get_uri_scheme$layout() {
        return get_uri_scheme$LAYOUT;
    }

    private static final long get_uri_scheme$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *(*get_uri_scheme)(GFile *)
     * }
     */
    public static final long get_uri_scheme$offset() {
        return get_uri_scheme$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *(*get_uri_scheme)(GFile *)
     * }
     */
    public static MemorySegment get_uri_scheme(MemorySegment struct) {
        return struct.get(get_uri_scheme$LAYOUT, get_uri_scheme$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *(*get_uri_scheme)(GFile *)
     * }
     */
    public static void get_uri_scheme(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_uri_scheme$LAYOUT, get_uri_scheme$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * char *(*get_basename)(GFile *)
     * }
     */
    public class get_basename {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_basename.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_basename.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_basename$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_basename"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *(*get_basename)(GFile *)
     * }
     */
    public static final AddressLayout get_basename$layout() {
        return get_basename$LAYOUT;
    }

    private static final long get_basename$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *(*get_basename)(GFile *)
     * }
     */
    public static final long get_basename$offset() {
        return get_basename$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *(*get_basename)(GFile *)
     * }
     */
    public static MemorySegment get_basename(MemorySegment struct) {
        return struct.get(get_basename$LAYOUT, get_basename$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *(*get_basename)(GFile *)
     * }
     */
    public static void get_basename(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_basename$LAYOUT, get_basename$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * char *(*get_path)(GFile *)
     * }
     */
    public class get_path {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_path.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_path.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_path$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_path"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *(*get_path)(GFile *)
     * }
     */
    public static final AddressLayout get_path$layout() {
        return get_path$LAYOUT;
    }

    private static final long get_path$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *(*get_path)(GFile *)
     * }
     */
    public static final long get_path$offset() {
        return get_path$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *(*get_path)(GFile *)
     * }
     */
    public static MemorySegment get_path(MemorySegment struct) {
        return struct.get(get_path$LAYOUT, get_path$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *(*get_path)(GFile *)
     * }
     */
    public static void get_path(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_path$LAYOUT, get_path$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * char *(*get_uri)(GFile *)
     * }
     */
    public class get_uri {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_uri.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_uri.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_uri$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_uri"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *(*get_uri)(GFile *)
     * }
     */
    public static final AddressLayout get_uri$layout() {
        return get_uri$LAYOUT;
    }

    private static final long get_uri$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *(*get_uri)(GFile *)
     * }
     */
    public static final long get_uri$offset() {
        return get_uri$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *(*get_uri)(GFile *)
     * }
     */
    public static MemorySegment get_uri(MemorySegment struct) {
        return struct.get(get_uri$LAYOUT, get_uri$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *(*get_uri)(GFile *)
     * }
     */
    public static void get_uri(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_uri$LAYOUT, get_uri$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * char *(*get_parse_name)(GFile *)
     * }
     */
    public class get_parse_name {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_parse_name.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_parse_name.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_parse_name$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_parse_name"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *(*get_parse_name)(GFile *)
     * }
     */
    public static final AddressLayout get_parse_name$layout() {
        return get_parse_name$LAYOUT;
    }

    private static final long get_parse_name$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *(*get_parse_name)(GFile *)
     * }
     */
    public static final long get_parse_name$offset() {
        return get_parse_name$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *(*get_parse_name)(GFile *)
     * }
     */
    public static MemorySegment get_parse_name(MemorySegment struct) {
        return struct.get(get_parse_name$LAYOUT, get_parse_name$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *(*get_parse_name)(GFile *)
     * }
     */
    public static void get_parse_name(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_parse_name$LAYOUT, get_parse_name$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFile *(*get_parent)(GFile *)
     * }
     */
    public class get_parent {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_parent.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_parent.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_parent$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_parent"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFile *(*get_parent)(GFile *)
     * }
     */
    public static final AddressLayout get_parent$layout() {
        return get_parent$LAYOUT;
    }

    private static final long get_parent$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFile *(*get_parent)(GFile *)
     * }
     */
    public static final long get_parent$offset() {
        return get_parent$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFile *(*get_parent)(GFile *)
     * }
     */
    public static MemorySegment get_parent(MemorySegment struct) {
        return struct.get(get_parent$LAYOUT, get_parent$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFile *(*get_parent)(GFile *)
     * }
     */
    public static void get_parent(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_parent$LAYOUT, get_parent$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*prefix_matches)(GFile *, GFile *)
     * }
     */
    public class prefix_matches {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(prefix_matches.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(prefix_matches.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout prefix_matches$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("prefix_matches"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*prefix_matches)(GFile *, GFile *)
     * }
     */
    public static final AddressLayout prefix_matches$layout() {
        return prefix_matches$LAYOUT;
    }

    private static final long prefix_matches$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*prefix_matches)(GFile *, GFile *)
     * }
     */
    public static final long prefix_matches$offset() {
        return prefix_matches$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*prefix_matches)(GFile *, GFile *)
     * }
     */
    public static MemorySegment prefix_matches(MemorySegment struct) {
        return struct.get(prefix_matches$LAYOUT, prefix_matches$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*prefix_matches)(GFile *, GFile *)
     * }
     */
    public static void prefix_matches(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(prefix_matches$LAYOUT, prefix_matches$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * char *(*get_relative_path)(GFile *, GFile *)
     * }
     */
    public class get_relative_path {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_relative_path.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_relative_path.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_relative_path$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_relative_path"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *(*get_relative_path)(GFile *, GFile *)
     * }
     */
    public static final AddressLayout get_relative_path$layout() {
        return get_relative_path$LAYOUT;
    }

    private static final long get_relative_path$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *(*get_relative_path)(GFile *, GFile *)
     * }
     */
    public static final long get_relative_path$offset() {
        return get_relative_path$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *(*get_relative_path)(GFile *, GFile *)
     * }
     */
    public static MemorySegment get_relative_path(MemorySegment struct) {
        return struct.get(get_relative_path$LAYOUT, get_relative_path$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *(*get_relative_path)(GFile *, GFile *)
     * }
     */
    public static void get_relative_path(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_relative_path$LAYOUT, get_relative_path$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFile *(*resolve_relative_path)(GFile *, const char *)
     * }
     */
    public class resolve_relative_path {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(resolve_relative_path.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(resolve_relative_path.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout resolve_relative_path$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("resolve_relative_path"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFile *(*resolve_relative_path)(GFile *, const char *)
     * }
     */
    public static final AddressLayout resolve_relative_path$layout() {
        return resolve_relative_path$LAYOUT;
    }

    private static final long resolve_relative_path$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFile *(*resolve_relative_path)(GFile *, const char *)
     * }
     */
    public static final long resolve_relative_path$offset() {
        return resolve_relative_path$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFile *(*resolve_relative_path)(GFile *, const char *)
     * }
     */
    public static MemorySegment resolve_relative_path(MemorySegment struct) {
        return struct.get(resolve_relative_path$LAYOUT, resolve_relative_path$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFile *(*resolve_relative_path)(GFile *, const char *)
     * }
     */
    public static void resolve_relative_path(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(resolve_relative_path$LAYOUT, resolve_relative_path$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFile *(*get_child_for_display_name)(GFile *, const char *, GError **)
     * }
     */
    public class get_child_for_display_name {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(get_child_for_display_name.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_child_for_display_name.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_child_for_display_name$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_child_for_display_name"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFile *(*get_child_for_display_name)(GFile *, const char *, GError **)
     * }
     */
    public static final AddressLayout get_child_for_display_name$layout() {
        return get_child_for_display_name$LAYOUT;
    }

    private static final long get_child_for_display_name$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFile *(*get_child_for_display_name)(GFile *, const char *, GError **)
     * }
     */
    public static final long get_child_for_display_name$offset() {
        return get_child_for_display_name$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFile *(*get_child_for_display_name)(GFile *, const char *, GError **)
     * }
     */
    public static MemorySegment get_child_for_display_name(MemorySegment struct) {
        return struct.get(get_child_for_display_name$LAYOUT, get_child_for_display_name$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFile *(*get_child_for_display_name)(GFile *, const char *, GError **)
     * }
     */
    public static void get_child_for_display_name(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_child_for_display_name$LAYOUT, get_child_for_display_name$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileEnumerator *(*enumerate_children)(GFile *, const char *, GFileQueryInfoFlags, GCancellable *, GError **)
     * }
     */
    public class enumerate_children {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(enumerate_children.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(enumerate_children.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout enumerate_children$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("enumerate_children"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileEnumerator *(*enumerate_children)(GFile *, const char *, GFileQueryInfoFlags, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout enumerate_children$layout() {
        return enumerate_children$LAYOUT;
    }

    private static final long enumerate_children$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileEnumerator *(*enumerate_children)(GFile *, const char *, GFileQueryInfoFlags, GCancellable *, GError **)
     * }
     */
    public static final long enumerate_children$offset() {
        return enumerate_children$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileEnumerator *(*enumerate_children)(GFile *, const char *, GFileQueryInfoFlags, GCancellable *, GError **)
     * }
     */
    public static MemorySegment enumerate_children(MemorySegment struct) {
        return struct.get(enumerate_children$LAYOUT, enumerate_children$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileEnumerator *(*enumerate_children)(GFile *, const char *, GFileQueryInfoFlags, GCancellable *, GError **)
     * }
     */
    public static void enumerate_children(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(enumerate_children$LAYOUT, enumerate_children$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*enumerate_children_async)(GFile *, const char *, GFileQueryInfoFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class enumerate_children_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(enumerate_children_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(enumerate_children_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout enumerate_children_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("enumerate_children_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*enumerate_children_async)(GFile *, const char *, GFileQueryInfoFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout enumerate_children_async$layout() {
        return enumerate_children_async$LAYOUT;
    }

    private static final long enumerate_children_async$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*enumerate_children_async)(GFile *, const char *, GFileQueryInfoFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long enumerate_children_async$offset() {
        return enumerate_children_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*enumerate_children_async)(GFile *, const char *, GFileQueryInfoFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment enumerate_children_async(MemorySegment struct) {
        return struct.get(enumerate_children_async$LAYOUT, enumerate_children_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*enumerate_children_async)(GFile *, const char *, GFileQueryInfoFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void enumerate_children_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(enumerate_children_async$LAYOUT, enumerate_children_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileEnumerator *(*enumerate_children_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class enumerate_children_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(enumerate_children_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(enumerate_children_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout enumerate_children_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("enumerate_children_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileEnumerator *(*enumerate_children_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout enumerate_children_finish$layout() {
        return enumerate_children_finish$LAYOUT;
    }

    private static final long enumerate_children_finish$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileEnumerator *(*enumerate_children_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long enumerate_children_finish$offset() {
        return enumerate_children_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileEnumerator *(*enumerate_children_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment enumerate_children_finish(MemorySegment struct) {
        return struct.get(enumerate_children_finish$LAYOUT, enumerate_children_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileEnumerator *(*enumerate_children_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void enumerate_children_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(enumerate_children_finish$LAYOUT, enumerate_children_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileInfo *(*query_info)(GFile *, const char *, GFileQueryInfoFlags, GCancellable *, GError **)
     * }
     */
    public class query_info {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(query_info.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(query_info.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout query_info$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("query_info"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileInfo *(*query_info)(GFile *, const char *, GFileQueryInfoFlags, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout query_info$layout() {
        return query_info$LAYOUT;
    }

    private static final long query_info$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileInfo *(*query_info)(GFile *, const char *, GFileQueryInfoFlags, GCancellable *, GError **)
     * }
     */
    public static final long query_info$offset() {
        return query_info$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileInfo *(*query_info)(GFile *, const char *, GFileQueryInfoFlags, GCancellable *, GError **)
     * }
     */
    public static MemorySegment query_info(MemorySegment struct) {
        return struct.get(query_info$LAYOUT, query_info$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileInfo *(*query_info)(GFile *, const char *, GFileQueryInfoFlags, GCancellable *, GError **)
     * }
     */
    public static void query_info(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(query_info$LAYOUT, query_info$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*query_info_async)(GFile *, const char *, GFileQueryInfoFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class query_info_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(query_info_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(query_info_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout query_info_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("query_info_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*query_info_async)(GFile *, const char *, GFileQueryInfoFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout query_info_async$layout() {
        return query_info_async$LAYOUT;
    }

    private static final long query_info_async$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*query_info_async)(GFile *, const char *, GFileQueryInfoFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long query_info_async$offset() {
        return query_info_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*query_info_async)(GFile *, const char *, GFileQueryInfoFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment query_info_async(MemorySegment struct) {
        return struct.get(query_info_async$LAYOUT, query_info_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*query_info_async)(GFile *, const char *, GFileQueryInfoFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void query_info_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(query_info_async$LAYOUT, query_info_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileInfo *(*query_info_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class query_info_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(query_info_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(query_info_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout query_info_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("query_info_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileInfo *(*query_info_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout query_info_finish$layout() {
        return query_info_finish$LAYOUT;
    }

    private static final long query_info_finish$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileInfo *(*query_info_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long query_info_finish$offset() {
        return query_info_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileInfo *(*query_info_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment query_info_finish(MemorySegment struct) {
        return struct.get(query_info_finish$LAYOUT, query_info_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileInfo *(*query_info_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void query_info_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(query_info_finish$LAYOUT, query_info_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileInfo *(*query_filesystem_info)(GFile *, const char *, GCancellable *, GError **)
     * }
     */
    public class query_filesystem_info {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(query_filesystem_info.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(query_filesystem_info.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout query_filesystem_info$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("query_filesystem_info"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileInfo *(*query_filesystem_info)(GFile *, const char *, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout query_filesystem_info$layout() {
        return query_filesystem_info$LAYOUT;
    }

    private static final long query_filesystem_info$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileInfo *(*query_filesystem_info)(GFile *, const char *, GCancellable *, GError **)
     * }
     */
    public static final long query_filesystem_info$offset() {
        return query_filesystem_info$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileInfo *(*query_filesystem_info)(GFile *, const char *, GCancellable *, GError **)
     * }
     */
    public static MemorySegment query_filesystem_info(MemorySegment struct) {
        return struct.get(query_filesystem_info$LAYOUT, query_filesystem_info$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileInfo *(*query_filesystem_info)(GFile *, const char *, GCancellable *, GError **)
     * }
     */
    public static void query_filesystem_info(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(query_filesystem_info$LAYOUT, query_filesystem_info$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*query_filesystem_info_async)(GFile *, const char *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class query_filesystem_info_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(query_filesystem_info_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(query_filesystem_info_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout query_filesystem_info_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("query_filesystem_info_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*query_filesystem_info_async)(GFile *, const char *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout query_filesystem_info_async$layout() {
        return query_filesystem_info_async$LAYOUT;
    }

    private static final long query_filesystem_info_async$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*query_filesystem_info_async)(GFile *, const char *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long query_filesystem_info_async$offset() {
        return query_filesystem_info_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*query_filesystem_info_async)(GFile *, const char *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment query_filesystem_info_async(MemorySegment struct) {
        return struct.get(query_filesystem_info_async$LAYOUT, query_filesystem_info_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*query_filesystem_info_async)(GFile *, const char *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void query_filesystem_info_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(query_filesystem_info_async$LAYOUT, query_filesystem_info_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileInfo *(*query_filesystem_info_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class query_filesystem_info_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(query_filesystem_info_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(query_filesystem_info_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout query_filesystem_info_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("query_filesystem_info_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileInfo *(*query_filesystem_info_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout query_filesystem_info_finish$layout() {
        return query_filesystem_info_finish$LAYOUT;
    }

    private static final long query_filesystem_info_finish$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileInfo *(*query_filesystem_info_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long query_filesystem_info_finish$offset() {
        return query_filesystem_info_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileInfo *(*query_filesystem_info_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment query_filesystem_info_finish(MemorySegment struct) {
        return struct.get(query_filesystem_info_finish$LAYOUT, query_filesystem_info_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileInfo *(*query_filesystem_info_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void query_filesystem_info_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(query_filesystem_info_finish$LAYOUT, query_filesystem_info_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GMount *(*find_enclosing_mount)(GFile *, GCancellable *, GError **)
     * }
     */
    public class find_enclosing_mount {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(find_enclosing_mount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(find_enclosing_mount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout find_enclosing_mount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("find_enclosing_mount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GMount *(*find_enclosing_mount)(GFile *, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout find_enclosing_mount$layout() {
        return find_enclosing_mount$LAYOUT;
    }

    private static final long find_enclosing_mount$OFFSET = 208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GMount *(*find_enclosing_mount)(GFile *, GCancellable *, GError **)
     * }
     */
    public static final long find_enclosing_mount$offset() {
        return find_enclosing_mount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GMount *(*find_enclosing_mount)(GFile *, GCancellable *, GError **)
     * }
     */
    public static MemorySegment find_enclosing_mount(MemorySegment struct) {
        return struct.get(find_enclosing_mount$LAYOUT, find_enclosing_mount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GMount *(*find_enclosing_mount)(GFile *, GCancellable *, GError **)
     * }
     */
    public static void find_enclosing_mount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(find_enclosing_mount$LAYOUT, find_enclosing_mount$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*find_enclosing_mount_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class find_enclosing_mount_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(find_enclosing_mount_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(find_enclosing_mount_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout find_enclosing_mount_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("find_enclosing_mount_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*find_enclosing_mount_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout find_enclosing_mount_async$layout() {
        return find_enclosing_mount_async$LAYOUT;
    }

    private static final long find_enclosing_mount_async$OFFSET = 216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*find_enclosing_mount_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long find_enclosing_mount_async$offset() {
        return find_enclosing_mount_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*find_enclosing_mount_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment find_enclosing_mount_async(MemorySegment struct) {
        return struct.get(find_enclosing_mount_async$LAYOUT, find_enclosing_mount_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*find_enclosing_mount_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void find_enclosing_mount_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(find_enclosing_mount_async$LAYOUT, find_enclosing_mount_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GMount *(*find_enclosing_mount_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class find_enclosing_mount_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(find_enclosing_mount_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(find_enclosing_mount_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout find_enclosing_mount_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("find_enclosing_mount_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GMount *(*find_enclosing_mount_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout find_enclosing_mount_finish$layout() {
        return find_enclosing_mount_finish$LAYOUT;
    }

    private static final long find_enclosing_mount_finish$OFFSET = 224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GMount *(*find_enclosing_mount_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long find_enclosing_mount_finish$offset() {
        return find_enclosing_mount_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GMount *(*find_enclosing_mount_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment find_enclosing_mount_finish(MemorySegment struct) {
        return struct.get(find_enclosing_mount_finish$LAYOUT, find_enclosing_mount_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GMount *(*find_enclosing_mount_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void find_enclosing_mount_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(find_enclosing_mount_finish$LAYOUT, find_enclosing_mount_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFile *(*set_display_name)(GFile *, const char *, GCancellable *, GError **)
     * }
     */
    public class set_display_name {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(set_display_name.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(set_display_name.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_display_name$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_display_name"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFile *(*set_display_name)(GFile *, const char *, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout set_display_name$layout() {
        return set_display_name$LAYOUT;
    }

    private static final long set_display_name$OFFSET = 232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFile *(*set_display_name)(GFile *, const char *, GCancellable *, GError **)
     * }
     */
    public static final long set_display_name$offset() {
        return set_display_name$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFile *(*set_display_name)(GFile *, const char *, GCancellable *, GError **)
     * }
     */
    public static MemorySegment set_display_name(MemorySegment struct) {
        return struct.get(set_display_name$LAYOUT, set_display_name$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFile *(*set_display_name)(GFile *, const char *, GCancellable *, GError **)
     * }
     */
    public static void set_display_name(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_display_name$LAYOUT, set_display_name$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*set_display_name_async)(GFile *, const char *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class set_display_name_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(set_display_name_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(set_display_name_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_display_name_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_display_name_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*set_display_name_async)(GFile *, const char *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout set_display_name_async$layout() {
        return set_display_name_async$LAYOUT;
    }

    private static final long set_display_name_async$OFFSET = 240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*set_display_name_async)(GFile *, const char *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long set_display_name_async$offset() {
        return set_display_name_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*set_display_name_async)(GFile *, const char *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment set_display_name_async(MemorySegment struct) {
        return struct.get(set_display_name_async$LAYOUT, set_display_name_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*set_display_name_async)(GFile *, const char *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void set_display_name_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_display_name_async$LAYOUT, set_display_name_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFile *(*set_display_name_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class set_display_name_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(set_display_name_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(set_display_name_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_display_name_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_display_name_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFile *(*set_display_name_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout set_display_name_finish$layout() {
        return set_display_name_finish$LAYOUT;
    }

    private static final long set_display_name_finish$OFFSET = 248;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFile *(*set_display_name_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long set_display_name_finish$offset() {
        return set_display_name_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFile *(*set_display_name_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment set_display_name_finish(MemorySegment struct) {
        return struct.get(set_display_name_finish$LAYOUT, set_display_name_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFile *(*set_display_name_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void set_display_name_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_display_name_finish$LAYOUT, set_display_name_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileAttributeInfoList *(*query_settable_attributes)(GFile *, GCancellable *, GError **)
     * }
     */
    public class query_settable_attributes {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(query_settable_attributes.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(query_settable_attributes.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout query_settable_attributes$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("query_settable_attributes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileAttributeInfoList *(*query_settable_attributes)(GFile *, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout query_settable_attributes$layout() {
        return query_settable_attributes$LAYOUT;
    }

    private static final long query_settable_attributes$OFFSET = 256;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileAttributeInfoList *(*query_settable_attributes)(GFile *, GCancellable *, GError **)
     * }
     */
    public static final long query_settable_attributes$offset() {
        return query_settable_attributes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileAttributeInfoList *(*query_settable_attributes)(GFile *, GCancellable *, GError **)
     * }
     */
    public static MemorySegment query_settable_attributes(MemorySegment struct) {
        return struct.get(query_settable_attributes$LAYOUT, query_settable_attributes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileAttributeInfoList *(*query_settable_attributes)(GFile *, GCancellable *, GError **)
     * }
     */
    public static void query_settable_attributes(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(query_settable_attributes$LAYOUT, query_settable_attributes$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*_query_settable_attributes_async)(void)
     * }
     */
    public class _query_settable_attributes_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid();

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(_query_settable_attributes_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_query_settable_attributes_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr) {
            try {
                 DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _query_settable_attributes_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_query_settable_attributes_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*_query_settable_attributes_async)(void)
     * }
     */
    public static final AddressLayout _query_settable_attributes_async$layout() {
        return _query_settable_attributes_async$LAYOUT;
    }

    private static final long _query_settable_attributes_async$OFFSET = 264;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*_query_settable_attributes_async)(void)
     * }
     */
    public static final long _query_settable_attributes_async$offset() {
        return _query_settable_attributes_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*_query_settable_attributes_async)(void)
     * }
     */
    public static MemorySegment _query_settable_attributes_async(MemorySegment struct) {
        return struct.get(_query_settable_attributes_async$LAYOUT, _query_settable_attributes_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*_query_settable_attributes_async)(void)
     * }
     */
    public static void _query_settable_attributes_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_query_settable_attributes_async$LAYOUT, _query_settable_attributes_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*_query_settable_attributes_finish)(void)
     * }
     */
    public class _query_settable_attributes_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid();

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(_query_settable_attributes_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_query_settable_attributes_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr) {
            try {
                 DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _query_settable_attributes_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_query_settable_attributes_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*_query_settable_attributes_finish)(void)
     * }
     */
    public static final AddressLayout _query_settable_attributes_finish$layout() {
        return _query_settable_attributes_finish$LAYOUT;
    }

    private static final long _query_settable_attributes_finish$OFFSET = 272;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*_query_settable_attributes_finish)(void)
     * }
     */
    public static final long _query_settable_attributes_finish$offset() {
        return _query_settable_attributes_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*_query_settable_attributes_finish)(void)
     * }
     */
    public static MemorySegment _query_settable_attributes_finish(MemorySegment struct) {
        return struct.get(_query_settable_attributes_finish$LAYOUT, _query_settable_attributes_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*_query_settable_attributes_finish)(void)
     * }
     */
    public static void _query_settable_attributes_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_query_settable_attributes_finish$LAYOUT, _query_settable_attributes_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileAttributeInfoList *(*query_writable_namespaces)(GFile *, GCancellable *, GError **)
     * }
     */
    public class query_writable_namespaces {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(query_writable_namespaces.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(query_writable_namespaces.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout query_writable_namespaces$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("query_writable_namespaces"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileAttributeInfoList *(*query_writable_namespaces)(GFile *, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout query_writable_namespaces$layout() {
        return query_writable_namespaces$LAYOUT;
    }

    private static final long query_writable_namespaces$OFFSET = 280;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileAttributeInfoList *(*query_writable_namespaces)(GFile *, GCancellable *, GError **)
     * }
     */
    public static final long query_writable_namespaces$offset() {
        return query_writable_namespaces$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileAttributeInfoList *(*query_writable_namespaces)(GFile *, GCancellable *, GError **)
     * }
     */
    public static MemorySegment query_writable_namespaces(MemorySegment struct) {
        return struct.get(query_writable_namespaces$LAYOUT, query_writable_namespaces$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileAttributeInfoList *(*query_writable_namespaces)(GFile *, GCancellable *, GError **)
     * }
     */
    public static void query_writable_namespaces(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(query_writable_namespaces$LAYOUT, query_writable_namespaces$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*_query_writable_namespaces_async)(void)
     * }
     */
    public class _query_writable_namespaces_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid();

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(_query_writable_namespaces_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_query_writable_namespaces_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr) {
            try {
                 DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _query_writable_namespaces_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_query_writable_namespaces_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*_query_writable_namespaces_async)(void)
     * }
     */
    public static final AddressLayout _query_writable_namespaces_async$layout() {
        return _query_writable_namespaces_async$LAYOUT;
    }

    private static final long _query_writable_namespaces_async$OFFSET = 288;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*_query_writable_namespaces_async)(void)
     * }
     */
    public static final long _query_writable_namespaces_async$offset() {
        return _query_writable_namespaces_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*_query_writable_namespaces_async)(void)
     * }
     */
    public static MemorySegment _query_writable_namespaces_async(MemorySegment struct) {
        return struct.get(_query_writable_namespaces_async$LAYOUT, _query_writable_namespaces_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*_query_writable_namespaces_async)(void)
     * }
     */
    public static void _query_writable_namespaces_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_query_writable_namespaces_async$LAYOUT, _query_writable_namespaces_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*_query_writable_namespaces_finish)(void)
     * }
     */
    public class _query_writable_namespaces_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid();

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(_query_writable_namespaces_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_query_writable_namespaces_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr) {
            try {
                 DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _query_writable_namespaces_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_query_writable_namespaces_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*_query_writable_namespaces_finish)(void)
     * }
     */
    public static final AddressLayout _query_writable_namespaces_finish$layout() {
        return _query_writable_namespaces_finish$LAYOUT;
    }

    private static final long _query_writable_namespaces_finish$OFFSET = 296;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*_query_writable_namespaces_finish)(void)
     * }
     */
    public static final long _query_writable_namespaces_finish$offset() {
        return _query_writable_namespaces_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*_query_writable_namespaces_finish)(void)
     * }
     */
    public static MemorySegment _query_writable_namespaces_finish(MemorySegment struct) {
        return struct.get(_query_writable_namespaces_finish$LAYOUT, _query_writable_namespaces_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*_query_writable_namespaces_finish)(void)
     * }
     */
    public static void _query_writable_namespaces_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_query_writable_namespaces_finish$LAYOUT, _query_writable_namespaces_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*set_attribute)(GFile *, const char *, GFileAttributeType, gpointer, GFileQueryInfoFlags, GCancellable *, GError **)
     * }
     */
    public class set_attribute {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, int _x4, MemorySegment _x5, MemorySegment _x6);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(set_attribute.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(set_attribute.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, int _x4, MemorySegment _x5, MemorySegment _x6) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_attribute$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_attribute"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*set_attribute)(GFile *, const char *, GFileAttributeType, gpointer, GFileQueryInfoFlags, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout set_attribute$layout() {
        return set_attribute$LAYOUT;
    }

    private static final long set_attribute$OFFSET = 304;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*set_attribute)(GFile *, const char *, GFileAttributeType, gpointer, GFileQueryInfoFlags, GCancellable *, GError **)
     * }
     */
    public static final long set_attribute$offset() {
        return set_attribute$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*set_attribute)(GFile *, const char *, GFileAttributeType, gpointer, GFileQueryInfoFlags, GCancellable *, GError **)
     * }
     */
    public static MemorySegment set_attribute(MemorySegment struct) {
        return struct.get(set_attribute$LAYOUT, set_attribute$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*set_attribute)(GFile *, const char *, GFileAttributeType, gpointer, GFileQueryInfoFlags, GCancellable *, GError **)
     * }
     */
    public static void set_attribute(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_attribute$LAYOUT, set_attribute$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*set_attributes_from_info)(GFile *, GFileInfo *, GFileQueryInfoFlags, GCancellable *, GError **)
     * }
     */
    public class set_attributes_from_info {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(set_attributes_from_info.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(set_attributes_from_info.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_attributes_from_info$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_attributes_from_info"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*set_attributes_from_info)(GFile *, GFileInfo *, GFileQueryInfoFlags, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout set_attributes_from_info$layout() {
        return set_attributes_from_info$LAYOUT;
    }

    private static final long set_attributes_from_info$OFFSET = 312;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*set_attributes_from_info)(GFile *, GFileInfo *, GFileQueryInfoFlags, GCancellable *, GError **)
     * }
     */
    public static final long set_attributes_from_info$offset() {
        return set_attributes_from_info$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*set_attributes_from_info)(GFile *, GFileInfo *, GFileQueryInfoFlags, GCancellable *, GError **)
     * }
     */
    public static MemorySegment set_attributes_from_info(MemorySegment struct) {
        return struct.get(set_attributes_from_info$LAYOUT, set_attributes_from_info$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*set_attributes_from_info)(GFile *, GFileInfo *, GFileQueryInfoFlags, GCancellable *, GError **)
     * }
     */
    public static void set_attributes_from_info(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_attributes_from_info$LAYOUT, set_attributes_from_info$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*set_attributes_async)(GFile *, GFileInfo *, GFileQueryInfoFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class set_attributes_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(set_attributes_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(set_attributes_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_attributes_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_attributes_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*set_attributes_async)(GFile *, GFileInfo *, GFileQueryInfoFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout set_attributes_async$layout() {
        return set_attributes_async$LAYOUT;
    }

    private static final long set_attributes_async$OFFSET = 320;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*set_attributes_async)(GFile *, GFileInfo *, GFileQueryInfoFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long set_attributes_async$offset() {
        return set_attributes_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*set_attributes_async)(GFile *, GFileInfo *, GFileQueryInfoFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment set_attributes_async(MemorySegment struct) {
        return struct.get(set_attributes_async$LAYOUT, set_attributes_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*set_attributes_async)(GFile *, GFileInfo *, GFileQueryInfoFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void set_attributes_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_attributes_async$LAYOUT, set_attributes_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*set_attributes_finish)(GFile *, GAsyncResult *, GFileInfo **, GError **)
     * }
     */
    public class set_attributes_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(set_attributes_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(set_attributes_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout set_attributes_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("set_attributes_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*set_attributes_finish)(GFile *, GAsyncResult *, GFileInfo **, GError **)
     * }
     */
    public static final AddressLayout set_attributes_finish$layout() {
        return set_attributes_finish$LAYOUT;
    }

    private static final long set_attributes_finish$OFFSET = 328;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*set_attributes_finish)(GFile *, GAsyncResult *, GFileInfo **, GError **)
     * }
     */
    public static final long set_attributes_finish$offset() {
        return set_attributes_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*set_attributes_finish)(GFile *, GAsyncResult *, GFileInfo **, GError **)
     * }
     */
    public static MemorySegment set_attributes_finish(MemorySegment struct) {
        return struct.get(set_attributes_finish$LAYOUT, set_attributes_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*set_attributes_finish)(GFile *, GAsyncResult *, GFileInfo **, GError **)
     * }
     */
    public static void set_attributes_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(set_attributes_finish$LAYOUT, set_attributes_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileInputStream *(*read_fn)(GFile *, GCancellable *, GError **)
     * }
     */
    public class read_fn {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(read_fn.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_fn.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_fn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_fn"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileInputStream *(*read_fn)(GFile *, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout read_fn$layout() {
        return read_fn$LAYOUT;
    }

    private static final long read_fn$OFFSET = 336;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileInputStream *(*read_fn)(GFile *, GCancellable *, GError **)
     * }
     */
    public static final long read_fn$offset() {
        return read_fn$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileInputStream *(*read_fn)(GFile *, GCancellable *, GError **)
     * }
     */
    public static MemorySegment read_fn(MemorySegment struct) {
        return struct.get(read_fn$LAYOUT, read_fn$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileInputStream *(*read_fn)(GFile *, GCancellable *, GError **)
     * }
     */
    public static void read_fn(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_fn$LAYOUT, read_fn$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*read_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class read_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(read_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*read_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout read_async$layout() {
        return read_async$LAYOUT;
    }

    private static final long read_async$OFFSET = 344;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*read_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long read_async$offset() {
        return read_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*read_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment read_async(MemorySegment struct) {
        return struct.get(read_async$LAYOUT, read_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*read_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void read_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_async$LAYOUT, read_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileInputStream *(*read_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class read_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(read_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileInputStream *(*read_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout read_finish$layout() {
        return read_finish$LAYOUT;
    }

    private static final long read_finish$OFFSET = 352;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileInputStream *(*read_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long read_finish$offset() {
        return read_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileInputStream *(*read_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment read_finish(MemorySegment struct) {
        return struct.get(read_finish$LAYOUT, read_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileInputStream *(*read_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void read_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_finish$LAYOUT, read_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileOutputStream *(*append_to)(GFile *, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public class append_to {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(append_to.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(append_to.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout append_to$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("append_to"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*append_to)(GFile *, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout append_to$layout() {
        return append_to$LAYOUT;
    }

    private static final long append_to$OFFSET = 360;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*append_to)(GFile *, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public static final long append_to$offset() {
        return append_to$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*append_to)(GFile *, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public static MemorySegment append_to(MemorySegment struct) {
        return struct.get(append_to$LAYOUT, append_to$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*append_to)(GFile *, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public static void append_to(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(append_to$LAYOUT, append_to$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*append_to_async)(GFile *, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class append_to_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(append_to_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(append_to_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout append_to_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("append_to_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*append_to_async)(GFile *, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout append_to_async$layout() {
        return append_to_async$LAYOUT;
    }

    private static final long append_to_async$OFFSET = 368;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*append_to_async)(GFile *, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long append_to_async$offset() {
        return append_to_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*append_to_async)(GFile *, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment append_to_async(MemorySegment struct) {
        return struct.get(append_to_async$LAYOUT, append_to_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*append_to_async)(GFile *, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void append_to_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(append_to_async$LAYOUT, append_to_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileOutputStream *(*append_to_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class append_to_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(append_to_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(append_to_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout append_to_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("append_to_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*append_to_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout append_to_finish$layout() {
        return append_to_finish$LAYOUT;
    }

    private static final long append_to_finish$OFFSET = 376;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*append_to_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long append_to_finish$offset() {
        return append_to_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*append_to_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment append_to_finish(MemorySegment struct) {
        return struct.get(append_to_finish$LAYOUT, append_to_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*append_to_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void append_to_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(append_to_finish$LAYOUT, append_to_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileOutputStream *(*create)(GFile *, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public class create {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(create.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(create.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout create$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("create"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*create)(GFile *, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout create$layout() {
        return create$LAYOUT;
    }

    private static final long create$OFFSET = 384;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*create)(GFile *, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public static final long create$offset() {
        return create$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*create)(GFile *, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public static MemorySegment create(MemorySegment struct) {
        return struct.get(create$LAYOUT, create$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*create)(GFile *, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public static void create(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(create$LAYOUT, create$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*create_async)(GFile *, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class create_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(create_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(create_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout create_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("create_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*create_async)(GFile *, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout create_async$layout() {
        return create_async$LAYOUT;
    }

    private static final long create_async$OFFSET = 392;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*create_async)(GFile *, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long create_async$offset() {
        return create_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*create_async)(GFile *, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment create_async(MemorySegment struct) {
        return struct.get(create_async$LAYOUT, create_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*create_async)(GFile *, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void create_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(create_async$LAYOUT, create_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileOutputStream *(*create_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class create_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(create_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(create_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout create_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("create_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*create_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout create_finish$layout() {
        return create_finish$LAYOUT;
    }

    private static final long create_finish$OFFSET = 400;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*create_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long create_finish$offset() {
        return create_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*create_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment create_finish(MemorySegment struct) {
        return struct.get(create_finish$LAYOUT, create_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*create_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void create_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(create_finish$LAYOUT, create_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileOutputStream *(*replace)(GFile *, const char *, gboolean, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public class replace {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(replace.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(replace.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout replace$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("replace"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*replace)(GFile *, const char *, gboolean, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout replace$layout() {
        return replace$LAYOUT;
    }

    private static final long replace$OFFSET = 408;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*replace)(GFile *, const char *, gboolean, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public static final long replace$offset() {
        return replace$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*replace)(GFile *, const char *, gboolean, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public static MemorySegment replace(MemorySegment struct) {
        return struct.get(replace$LAYOUT, replace$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*replace)(GFile *, const char *, gboolean, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public static void replace(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(replace$LAYOUT, replace$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*replace_async)(GFile *, const char *, gboolean, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class replace_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, int _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(replace_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(replace_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, int _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout replace_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("replace_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*replace_async)(GFile *, const char *, gboolean, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout replace_async$layout() {
        return replace_async$LAYOUT;
    }

    private static final long replace_async$OFFSET = 416;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*replace_async)(GFile *, const char *, gboolean, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long replace_async$offset() {
        return replace_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*replace_async)(GFile *, const char *, gboolean, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment replace_async(MemorySegment struct) {
        return struct.get(replace_async$LAYOUT, replace_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*replace_async)(GFile *, const char *, gboolean, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void replace_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(replace_async$LAYOUT, replace_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileOutputStream *(*replace_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class replace_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(replace_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(replace_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout replace_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("replace_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*replace_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout replace_finish$layout() {
        return replace_finish$LAYOUT;
    }

    private static final long replace_finish$OFFSET = 424;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*replace_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long replace_finish$offset() {
        return replace_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*replace_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment replace_finish(MemorySegment struct) {
        return struct.get(replace_finish$LAYOUT, replace_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileOutputStream *(*replace_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void replace_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(replace_finish$LAYOUT, replace_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*delete_file)(GFile *, GCancellable *, GError **)
     * }
     */
    public class delete_file {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(delete_file.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(delete_file.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout delete_file$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("delete_file"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*delete_file)(GFile *, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout delete_file$layout() {
        return delete_file$LAYOUT;
    }

    private static final long delete_file$OFFSET = 432;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*delete_file)(GFile *, GCancellable *, GError **)
     * }
     */
    public static final long delete_file$offset() {
        return delete_file$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*delete_file)(GFile *, GCancellable *, GError **)
     * }
     */
    public static MemorySegment delete_file(MemorySegment struct) {
        return struct.get(delete_file$LAYOUT, delete_file$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*delete_file)(GFile *, GCancellable *, GError **)
     * }
     */
    public static void delete_file(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(delete_file$LAYOUT, delete_file$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*delete_file_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class delete_file_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(delete_file_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(delete_file_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout delete_file_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("delete_file_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*delete_file_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout delete_file_async$layout() {
        return delete_file_async$LAYOUT;
    }

    private static final long delete_file_async$OFFSET = 440;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*delete_file_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long delete_file_async$offset() {
        return delete_file_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*delete_file_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment delete_file_async(MemorySegment struct) {
        return struct.get(delete_file_async$LAYOUT, delete_file_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*delete_file_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void delete_file_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(delete_file_async$LAYOUT, delete_file_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*delete_file_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class delete_file_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(delete_file_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(delete_file_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout delete_file_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("delete_file_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*delete_file_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout delete_file_finish$layout() {
        return delete_file_finish$LAYOUT;
    }

    private static final long delete_file_finish$OFFSET = 448;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*delete_file_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long delete_file_finish$offset() {
        return delete_file_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*delete_file_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment delete_file_finish(MemorySegment struct) {
        return struct.get(delete_file_finish$LAYOUT, delete_file_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*delete_file_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void delete_file_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(delete_file_finish$LAYOUT, delete_file_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*trash)(GFile *, GCancellable *, GError **)
     * }
     */
    public class trash {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(trash.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(trash.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout trash$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("trash"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*trash)(GFile *, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout trash$layout() {
        return trash$LAYOUT;
    }

    private static final long trash$OFFSET = 456;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*trash)(GFile *, GCancellable *, GError **)
     * }
     */
    public static final long trash$offset() {
        return trash$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*trash)(GFile *, GCancellable *, GError **)
     * }
     */
    public static MemorySegment trash(MemorySegment struct) {
        return struct.get(trash$LAYOUT, trash$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*trash)(GFile *, GCancellable *, GError **)
     * }
     */
    public static void trash(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(trash$LAYOUT, trash$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*trash_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class trash_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(trash_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(trash_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout trash_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("trash_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*trash_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout trash_async$layout() {
        return trash_async$LAYOUT;
    }

    private static final long trash_async$OFFSET = 464;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*trash_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long trash_async$offset() {
        return trash_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*trash_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment trash_async(MemorySegment struct) {
        return struct.get(trash_async$LAYOUT, trash_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*trash_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void trash_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(trash_async$LAYOUT, trash_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*trash_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class trash_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(trash_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(trash_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout trash_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("trash_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*trash_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout trash_finish$layout() {
        return trash_finish$LAYOUT;
    }

    private static final long trash_finish$OFFSET = 472;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*trash_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long trash_finish$offset() {
        return trash_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*trash_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment trash_finish(MemorySegment struct) {
        return struct.get(trash_finish$LAYOUT, trash_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*trash_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void trash_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(trash_finish$LAYOUT, trash_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*make_directory)(GFile *, GCancellable *, GError **)
     * }
     */
    public class make_directory {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(make_directory.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(make_directory.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout make_directory$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("make_directory"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*make_directory)(GFile *, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout make_directory$layout() {
        return make_directory$LAYOUT;
    }

    private static final long make_directory$OFFSET = 480;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*make_directory)(GFile *, GCancellable *, GError **)
     * }
     */
    public static final long make_directory$offset() {
        return make_directory$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*make_directory)(GFile *, GCancellable *, GError **)
     * }
     */
    public static MemorySegment make_directory(MemorySegment struct) {
        return struct.get(make_directory$LAYOUT, make_directory$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*make_directory)(GFile *, GCancellable *, GError **)
     * }
     */
    public static void make_directory(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(make_directory$LAYOUT, make_directory$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*make_directory_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class make_directory_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(make_directory_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(make_directory_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout make_directory_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("make_directory_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*make_directory_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout make_directory_async$layout() {
        return make_directory_async$LAYOUT;
    }

    private static final long make_directory_async$OFFSET = 488;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*make_directory_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long make_directory_async$offset() {
        return make_directory_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*make_directory_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment make_directory_async(MemorySegment struct) {
        return struct.get(make_directory_async$LAYOUT, make_directory_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*make_directory_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void make_directory_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(make_directory_async$LAYOUT, make_directory_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*make_directory_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class make_directory_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(make_directory_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(make_directory_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout make_directory_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("make_directory_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*make_directory_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout make_directory_finish$layout() {
        return make_directory_finish$LAYOUT;
    }

    private static final long make_directory_finish$OFFSET = 496;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*make_directory_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long make_directory_finish$offset() {
        return make_directory_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*make_directory_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment make_directory_finish(MemorySegment struct) {
        return struct.get(make_directory_finish$LAYOUT, make_directory_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*make_directory_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void make_directory_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(make_directory_finish$LAYOUT, make_directory_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*make_symbolic_link)(GFile *, const char *, GCancellable *, GError **)
     * }
     */
    public class make_symbolic_link {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(make_symbolic_link.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(make_symbolic_link.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout make_symbolic_link$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("make_symbolic_link"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*make_symbolic_link)(GFile *, const char *, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout make_symbolic_link$layout() {
        return make_symbolic_link$LAYOUT;
    }

    private static final long make_symbolic_link$OFFSET = 504;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*make_symbolic_link)(GFile *, const char *, GCancellable *, GError **)
     * }
     */
    public static final long make_symbolic_link$offset() {
        return make_symbolic_link$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*make_symbolic_link)(GFile *, const char *, GCancellable *, GError **)
     * }
     */
    public static MemorySegment make_symbolic_link(MemorySegment struct) {
        return struct.get(make_symbolic_link$LAYOUT, make_symbolic_link$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*make_symbolic_link)(GFile *, const char *, GCancellable *, GError **)
     * }
     */
    public static void make_symbolic_link(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(make_symbolic_link$LAYOUT, make_symbolic_link$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*make_symbolic_link_async)(GFile *, const char *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class make_symbolic_link_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(make_symbolic_link_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(make_symbolic_link_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout make_symbolic_link_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("make_symbolic_link_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*make_symbolic_link_async)(GFile *, const char *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout make_symbolic_link_async$layout() {
        return make_symbolic_link_async$LAYOUT;
    }

    private static final long make_symbolic_link_async$OFFSET = 512;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*make_symbolic_link_async)(GFile *, const char *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long make_symbolic_link_async$offset() {
        return make_symbolic_link_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*make_symbolic_link_async)(GFile *, const char *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment make_symbolic_link_async(MemorySegment struct) {
        return struct.get(make_symbolic_link_async$LAYOUT, make_symbolic_link_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*make_symbolic_link_async)(GFile *, const char *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void make_symbolic_link_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(make_symbolic_link_async$LAYOUT, make_symbolic_link_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*make_symbolic_link_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class make_symbolic_link_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(make_symbolic_link_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(make_symbolic_link_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout make_symbolic_link_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("make_symbolic_link_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*make_symbolic_link_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout make_symbolic_link_finish$layout() {
        return make_symbolic_link_finish$LAYOUT;
    }

    private static final long make_symbolic_link_finish$OFFSET = 520;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*make_symbolic_link_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long make_symbolic_link_finish$offset() {
        return make_symbolic_link_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*make_symbolic_link_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment make_symbolic_link_finish(MemorySegment struct) {
        return struct.get(make_symbolic_link_finish$LAYOUT, make_symbolic_link_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*make_symbolic_link_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void make_symbolic_link_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(make_symbolic_link_finish$LAYOUT, make_symbolic_link_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*copy)(GFile *, GFile *, GFileCopyFlags, GCancellable *, GFileProgressCallback, gpointer, GError **)
     * }
     */
    public class copy {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(copy.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(copy.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout copy$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("copy"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*copy)(GFile *, GFile *, GFileCopyFlags, GCancellable *, GFileProgressCallback, gpointer, GError **)
     * }
     */
    public static final AddressLayout copy$layout() {
        return copy$LAYOUT;
    }

    private static final long copy$OFFSET = 528;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*copy)(GFile *, GFile *, GFileCopyFlags, GCancellable *, GFileProgressCallback, gpointer, GError **)
     * }
     */
    public static final long copy$offset() {
        return copy$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*copy)(GFile *, GFile *, GFileCopyFlags, GCancellable *, GFileProgressCallback, gpointer, GError **)
     * }
     */
    public static MemorySegment copy(MemorySegment struct) {
        return struct.get(copy$LAYOUT, copy$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*copy)(GFile *, GFile *, GFileCopyFlags, GCancellable *, GFileProgressCallback, gpointer, GError **)
     * }
     */
    public static void copy(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(copy$LAYOUT, copy$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*copy_async)(GFile *, GFile *, GFileCopyFlags, int, GCancellable *, GFileProgressCallback, gpointer, GAsyncReadyCallback, gpointer)
     * }
     */
    public class copy_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, MemorySegment _x8);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(copy_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(copy_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, MemorySegment _x8) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout copy_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("copy_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*copy_async)(GFile *, GFile *, GFileCopyFlags, int, GCancellable *, GFileProgressCallback, gpointer, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout copy_async$layout() {
        return copy_async$LAYOUT;
    }

    private static final long copy_async$OFFSET = 536;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*copy_async)(GFile *, GFile *, GFileCopyFlags, int, GCancellable *, GFileProgressCallback, gpointer, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long copy_async$offset() {
        return copy_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*copy_async)(GFile *, GFile *, GFileCopyFlags, int, GCancellable *, GFileProgressCallback, gpointer, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment copy_async(MemorySegment struct) {
        return struct.get(copy_async$LAYOUT, copy_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*copy_async)(GFile *, GFile *, GFileCopyFlags, int, GCancellable *, GFileProgressCallback, gpointer, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void copy_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(copy_async$LAYOUT, copy_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*copy_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class copy_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(copy_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(copy_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout copy_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("copy_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*copy_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout copy_finish$layout() {
        return copy_finish$LAYOUT;
    }

    private static final long copy_finish$OFFSET = 544;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*copy_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long copy_finish$offset() {
        return copy_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*copy_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment copy_finish(MemorySegment struct) {
        return struct.get(copy_finish$LAYOUT, copy_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*copy_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void copy_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(copy_finish$LAYOUT, copy_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*move)(GFile *, GFile *, GFileCopyFlags, GCancellable *, GFileProgressCallback, gpointer, GError **)
     * }
     */
    public class move {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(move.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(move.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout move$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("move"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*move)(GFile *, GFile *, GFileCopyFlags, GCancellable *, GFileProgressCallback, gpointer, GError **)
     * }
     */
    public static final AddressLayout move$layout() {
        return move$LAYOUT;
    }

    private static final long move$OFFSET = 552;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*move)(GFile *, GFile *, GFileCopyFlags, GCancellable *, GFileProgressCallback, gpointer, GError **)
     * }
     */
    public static final long move$offset() {
        return move$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*move)(GFile *, GFile *, GFileCopyFlags, GCancellable *, GFileProgressCallback, gpointer, GError **)
     * }
     */
    public static MemorySegment move(MemorySegment struct) {
        return struct.get(move$LAYOUT, move$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*move)(GFile *, GFile *, GFileCopyFlags, GCancellable *, GFileProgressCallback, gpointer, GError **)
     * }
     */
    public static void move(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(move$LAYOUT, move$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*move_async)(GFile *, GFile *, GFileCopyFlags, int, GCancellable *, GFileProgressCallback, gpointer, GAsyncReadyCallback, gpointer)
     * }
     */
    public class move_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, MemorySegment _x8);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(move_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(move_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, MemorySegment _x8) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout move_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("move_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*move_async)(GFile *, GFile *, GFileCopyFlags, int, GCancellable *, GFileProgressCallback, gpointer, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout move_async$layout() {
        return move_async$LAYOUT;
    }

    private static final long move_async$OFFSET = 560;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*move_async)(GFile *, GFile *, GFileCopyFlags, int, GCancellable *, GFileProgressCallback, gpointer, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long move_async$offset() {
        return move_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*move_async)(GFile *, GFile *, GFileCopyFlags, int, GCancellable *, GFileProgressCallback, gpointer, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment move_async(MemorySegment struct) {
        return struct.get(move_async$LAYOUT, move_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*move_async)(GFile *, GFile *, GFileCopyFlags, int, GCancellable *, GFileProgressCallback, gpointer, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void move_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(move_async$LAYOUT, move_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*move_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class move_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(move_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(move_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout move_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("move_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*move_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout move_finish$layout() {
        return move_finish$LAYOUT;
    }

    private static final long move_finish$OFFSET = 568;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*move_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long move_finish$offset() {
        return move_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*move_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment move_finish(MemorySegment struct) {
        return struct.get(move_finish$LAYOUT, move_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*move_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void move_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(move_finish$LAYOUT, move_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*mount_mountable)(GFile *, GMountMountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class mount_mountable {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(mount_mountable.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(mount_mountable.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout mount_mountable$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("mount_mountable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*mount_mountable)(GFile *, GMountMountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout mount_mountable$layout() {
        return mount_mountable$LAYOUT;
    }

    private static final long mount_mountable$OFFSET = 576;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*mount_mountable)(GFile *, GMountMountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long mount_mountable$offset() {
        return mount_mountable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*mount_mountable)(GFile *, GMountMountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment mount_mountable(MemorySegment struct) {
        return struct.get(mount_mountable$LAYOUT, mount_mountable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*mount_mountable)(GFile *, GMountMountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void mount_mountable(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(mount_mountable$LAYOUT, mount_mountable$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFile *(*mount_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class mount_mountable_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(mount_mountable_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(mount_mountable_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout mount_mountable_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("mount_mountable_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFile *(*mount_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout mount_mountable_finish$layout() {
        return mount_mountable_finish$LAYOUT;
    }

    private static final long mount_mountable_finish$OFFSET = 584;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFile *(*mount_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long mount_mountable_finish$offset() {
        return mount_mountable_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFile *(*mount_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment mount_mountable_finish(MemorySegment struct) {
        return struct.get(mount_mountable_finish$LAYOUT, mount_mountable_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFile *(*mount_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void mount_mountable_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(mount_mountable_finish$LAYOUT, mount_mountable_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*unmount_mountable)(GFile *, GMountUnmountFlags, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class unmount_mountable {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(unmount_mountable.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(unmount_mountable.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout unmount_mountable$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("unmount_mountable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*unmount_mountable)(GFile *, GMountUnmountFlags, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout unmount_mountable$layout() {
        return unmount_mountable$LAYOUT;
    }

    private static final long unmount_mountable$OFFSET = 592;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*unmount_mountable)(GFile *, GMountUnmountFlags, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long unmount_mountable$offset() {
        return unmount_mountable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*unmount_mountable)(GFile *, GMountUnmountFlags, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment unmount_mountable(MemorySegment struct) {
        return struct.get(unmount_mountable$LAYOUT, unmount_mountable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*unmount_mountable)(GFile *, GMountUnmountFlags, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void unmount_mountable(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(unmount_mountable$LAYOUT, unmount_mountable$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*unmount_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class unmount_mountable_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(unmount_mountable_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(unmount_mountable_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout unmount_mountable_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("unmount_mountable_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*unmount_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout unmount_mountable_finish$layout() {
        return unmount_mountable_finish$LAYOUT;
    }

    private static final long unmount_mountable_finish$OFFSET = 600;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*unmount_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long unmount_mountable_finish$offset() {
        return unmount_mountable_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*unmount_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment unmount_mountable_finish(MemorySegment struct) {
        return struct.get(unmount_mountable_finish$LAYOUT, unmount_mountable_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*unmount_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void unmount_mountable_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(unmount_mountable_finish$LAYOUT, unmount_mountable_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*eject_mountable)(GFile *, GMountUnmountFlags, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class eject_mountable {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(eject_mountable.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(eject_mountable.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout eject_mountable$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("eject_mountable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*eject_mountable)(GFile *, GMountUnmountFlags, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout eject_mountable$layout() {
        return eject_mountable$LAYOUT;
    }

    private static final long eject_mountable$OFFSET = 608;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*eject_mountable)(GFile *, GMountUnmountFlags, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long eject_mountable$offset() {
        return eject_mountable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*eject_mountable)(GFile *, GMountUnmountFlags, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment eject_mountable(MemorySegment struct) {
        return struct.get(eject_mountable$LAYOUT, eject_mountable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*eject_mountable)(GFile *, GMountUnmountFlags, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void eject_mountable(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(eject_mountable$LAYOUT, eject_mountable$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*eject_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class eject_mountable_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(eject_mountable_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(eject_mountable_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout eject_mountable_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("eject_mountable_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*eject_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout eject_mountable_finish$layout() {
        return eject_mountable_finish$LAYOUT;
    }

    private static final long eject_mountable_finish$OFFSET = 616;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*eject_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long eject_mountable_finish$offset() {
        return eject_mountable_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*eject_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment eject_mountable_finish(MemorySegment struct) {
        return struct.get(eject_mountable_finish$LAYOUT, eject_mountable_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*eject_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void eject_mountable_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(eject_mountable_finish$LAYOUT, eject_mountable_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*mount_enclosing_volume)(GFile *, GMountMountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class mount_enclosing_volume {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(mount_enclosing_volume.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(mount_enclosing_volume.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout mount_enclosing_volume$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("mount_enclosing_volume"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*mount_enclosing_volume)(GFile *, GMountMountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout mount_enclosing_volume$layout() {
        return mount_enclosing_volume$LAYOUT;
    }

    private static final long mount_enclosing_volume$OFFSET = 624;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*mount_enclosing_volume)(GFile *, GMountMountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long mount_enclosing_volume$offset() {
        return mount_enclosing_volume$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*mount_enclosing_volume)(GFile *, GMountMountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment mount_enclosing_volume(MemorySegment struct) {
        return struct.get(mount_enclosing_volume$LAYOUT, mount_enclosing_volume$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*mount_enclosing_volume)(GFile *, GMountMountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void mount_enclosing_volume(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(mount_enclosing_volume$LAYOUT, mount_enclosing_volume$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*mount_enclosing_volume_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class mount_enclosing_volume_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(mount_enclosing_volume_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(mount_enclosing_volume_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout mount_enclosing_volume_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("mount_enclosing_volume_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*mount_enclosing_volume_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout mount_enclosing_volume_finish$layout() {
        return mount_enclosing_volume_finish$LAYOUT;
    }

    private static final long mount_enclosing_volume_finish$OFFSET = 632;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*mount_enclosing_volume_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long mount_enclosing_volume_finish$offset() {
        return mount_enclosing_volume_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*mount_enclosing_volume_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment mount_enclosing_volume_finish(MemorySegment struct) {
        return struct.get(mount_enclosing_volume_finish$LAYOUT, mount_enclosing_volume_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*mount_enclosing_volume_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void mount_enclosing_volume_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(mount_enclosing_volume_finish$LAYOUT, mount_enclosing_volume_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileMonitor *(*monitor_dir)(GFile *, GFileMonitorFlags, GCancellable *, GError **)
     * }
     */
    public class monitor_dir {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(monitor_dir.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(monitor_dir.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout monitor_dir$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("monitor_dir"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileMonitor *(*monitor_dir)(GFile *, GFileMonitorFlags, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout monitor_dir$layout() {
        return monitor_dir$LAYOUT;
    }

    private static final long monitor_dir$OFFSET = 640;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileMonitor *(*monitor_dir)(GFile *, GFileMonitorFlags, GCancellable *, GError **)
     * }
     */
    public static final long monitor_dir$offset() {
        return monitor_dir$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileMonitor *(*monitor_dir)(GFile *, GFileMonitorFlags, GCancellable *, GError **)
     * }
     */
    public static MemorySegment monitor_dir(MemorySegment struct) {
        return struct.get(monitor_dir$LAYOUT, monitor_dir$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileMonitor *(*monitor_dir)(GFile *, GFileMonitorFlags, GCancellable *, GError **)
     * }
     */
    public static void monitor_dir(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(monitor_dir$LAYOUT, monitor_dir$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileMonitor *(*monitor_file)(GFile *, GFileMonitorFlags, GCancellable *, GError **)
     * }
     */
    public class monitor_file {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(monitor_file.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(monitor_file.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout monitor_file$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("monitor_file"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileMonitor *(*monitor_file)(GFile *, GFileMonitorFlags, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout monitor_file$layout() {
        return monitor_file$LAYOUT;
    }

    private static final long monitor_file$OFFSET = 648;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileMonitor *(*monitor_file)(GFile *, GFileMonitorFlags, GCancellable *, GError **)
     * }
     */
    public static final long monitor_file$offset() {
        return monitor_file$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileMonitor *(*monitor_file)(GFile *, GFileMonitorFlags, GCancellable *, GError **)
     * }
     */
    public static MemorySegment monitor_file(MemorySegment struct) {
        return struct.get(monitor_file$LAYOUT, monitor_file$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileMonitor *(*monitor_file)(GFile *, GFileMonitorFlags, GCancellable *, GError **)
     * }
     */
    public static void monitor_file(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(monitor_file$LAYOUT, monitor_file$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileIOStream *(*open_readwrite)(GFile *, GCancellable *, GError **)
     * }
     */
    public class open_readwrite {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(open_readwrite.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(open_readwrite.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout open_readwrite$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("open_readwrite"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileIOStream *(*open_readwrite)(GFile *, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout open_readwrite$layout() {
        return open_readwrite$LAYOUT;
    }

    private static final long open_readwrite$OFFSET = 656;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileIOStream *(*open_readwrite)(GFile *, GCancellable *, GError **)
     * }
     */
    public static final long open_readwrite$offset() {
        return open_readwrite$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileIOStream *(*open_readwrite)(GFile *, GCancellable *, GError **)
     * }
     */
    public static MemorySegment open_readwrite(MemorySegment struct) {
        return struct.get(open_readwrite$LAYOUT, open_readwrite$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileIOStream *(*open_readwrite)(GFile *, GCancellable *, GError **)
     * }
     */
    public static void open_readwrite(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(open_readwrite$LAYOUT, open_readwrite$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*open_readwrite_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class open_readwrite_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(open_readwrite_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(open_readwrite_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout open_readwrite_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("open_readwrite_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*open_readwrite_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout open_readwrite_async$layout() {
        return open_readwrite_async$LAYOUT;
    }

    private static final long open_readwrite_async$OFFSET = 664;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*open_readwrite_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long open_readwrite_async$offset() {
        return open_readwrite_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*open_readwrite_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment open_readwrite_async(MemorySegment struct) {
        return struct.get(open_readwrite_async$LAYOUT, open_readwrite_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*open_readwrite_async)(GFile *, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void open_readwrite_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(open_readwrite_async$LAYOUT, open_readwrite_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileIOStream *(*open_readwrite_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class open_readwrite_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(open_readwrite_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(open_readwrite_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout open_readwrite_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("open_readwrite_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileIOStream *(*open_readwrite_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout open_readwrite_finish$layout() {
        return open_readwrite_finish$LAYOUT;
    }

    private static final long open_readwrite_finish$OFFSET = 672;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileIOStream *(*open_readwrite_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long open_readwrite_finish$offset() {
        return open_readwrite_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileIOStream *(*open_readwrite_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment open_readwrite_finish(MemorySegment struct) {
        return struct.get(open_readwrite_finish$LAYOUT, open_readwrite_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileIOStream *(*open_readwrite_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void open_readwrite_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(open_readwrite_finish$LAYOUT, open_readwrite_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileIOStream *(*create_readwrite)(GFile *, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public class create_readwrite {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(create_readwrite.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(create_readwrite.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout create_readwrite$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("create_readwrite"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileIOStream *(*create_readwrite)(GFile *, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout create_readwrite$layout() {
        return create_readwrite$LAYOUT;
    }

    private static final long create_readwrite$OFFSET = 680;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileIOStream *(*create_readwrite)(GFile *, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public static final long create_readwrite$offset() {
        return create_readwrite$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileIOStream *(*create_readwrite)(GFile *, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public static MemorySegment create_readwrite(MemorySegment struct) {
        return struct.get(create_readwrite$LAYOUT, create_readwrite$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileIOStream *(*create_readwrite)(GFile *, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public static void create_readwrite(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(create_readwrite$LAYOUT, create_readwrite$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*create_readwrite_async)(GFile *, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class create_readwrite_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(create_readwrite_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(create_readwrite_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout create_readwrite_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("create_readwrite_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*create_readwrite_async)(GFile *, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout create_readwrite_async$layout() {
        return create_readwrite_async$LAYOUT;
    }

    private static final long create_readwrite_async$OFFSET = 688;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*create_readwrite_async)(GFile *, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long create_readwrite_async$offset() {
        return create_readwrite_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*create_readwrite_async)(GFile *, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment create_readwrite_async(MemorySegment struct) {
        return struct.get(create_readwrite_async$LAYOUT, create_readwrite_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*create_readwrite_async)(GFile *, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void create_readwrite_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(create_readwrite_async$LAYOUT, create_readwrite_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileIOStream *(*create_readwrite_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class create_readwrite_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(create_readwrite_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(create_readwrite_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout create_readwrite_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("create_readwrite_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileIOStream *(*create_readwrite_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout create_readwrite_finish$layout() {
        return create_readwrite_finish$LAYOUT;
    }

    private static final long create_readwrite_finish$OFFSET = 696;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileIOStream *(*create_readwrite_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long create_readwrite_finish$offset() {
        return create_readwrite_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileIOStream *(*create_readwrite_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment create_readwrite_finish(MemorySegment struct) {
        return struct.get(create_readwrite_finish$LAYOUT, create_readwrite_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileIOStream *(*create_readwrite_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void create_readwrite_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(create_readwrite_finish$LAYOUT, create_readwrite_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileIOStream *(*replace_readwrite)(GFile *, const char *, gboolean, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public class replace_readwrite {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(replace_readwrite.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(replace_readwrite.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout replace_readwrite$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("replace_readwrite"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileIOStream *(*replace_readwrite)(GFile *, const char *, gboolean, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public static final AddressLayout replace_readwrite$layout() {
        return replace_readwrite$LAYOUT;
    }

    private static final long replace_readwrite$OFFSET = 704;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileIOStream *(*replace_readwrite)(GFile *, const char *, gboolean, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public static final long replace_readwrite$offset() {
        return replace_readwrite$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileIOStream *(*replace_readwrite)(GFile *, const char *, gboolean, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public static MemorySegment replace_readwrite(MemorySegment struct) {
        return struct.get(replace_readwrite$LAYOUT, replace_readwrite$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileIOStream *(*replace_readwrite)(GFile *, const char *, gboolean, GFileCreateFlags, GCancellable *, GError **)
     * }
     */
    public static void replace_readwrite(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(replace_readwrite$LAYOUT, replace_readwrite$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*replace_readwrite_async)(GFile *, const char *, gboolean, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class replace_readwrite_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, int _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(replace_readwrite_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(replace_readwrite_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, int _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout replace_readwrite_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("replace_readwrite_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*replace_readwrite_async)(GFile *, const char *, gboolean, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout replace_readwrite_async$layout() {
        return replace_readwrite_async$LAYOUT;
    }

    private static final long replace_readwrite_async$OFFSET = 712;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*replace_readwrite_async)(GFile *, const char *, gboolean, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long replace_readwrite_async$offset() {
        return replace_readwrite_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*replace_readwrite_async)(GFile *, const char *, gboolean, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment replace_readwrite_async(MemorySegment struct) {
        return struct.get(replace_readwrite_async$LAYOUT, replace_readwrite_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*replace_readwrite_async)(GFile *, const char *, gboolean, GFileCreateFlags, int, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void replace_readwrite_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(replace_readwrite_async$LAYOUT, replace_readwrite_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * GFileIOStream *(*replace_readwrite_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class replace_readwrite_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(replace_readwrite_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(replace_readwrite_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout replace_readwrite_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("replace_readwrite_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GFileIOStream *(*replace_readwrite_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout replace_readwrite_finish$layout() {
        return replace_readwrite_finish$LAYOUT;
    }

    private static final long replace_readwrite_finish$OFFSET = 720;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GFileIOStream *(*replace_readwrite_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long replace_readwrite_finish$offset() {
        return replace_readwrite_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GFileIOStream *(*replace_readwrite_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment replace_readwrite_finish(MemorySegment struct) {
        return struct.get(replace_readwrite_finish$LAYOUT, replace_readwrite_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GFileIOStream *(*replace_readwrite_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void replace_readwrite_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(replace_readwrite_finish$LAYOUT, replace_readwrite_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*start_mountable)(GFile *, GDriveStartFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class start_mountable {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(start_mountable.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(start_mountable.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout start_mountable$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("start_mountable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*start_mountable)(GFile *, GDriveStartFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout start_mountable$layout() {
        return start_mountable$LAYOUT;
    }

    private static final long start_mountable$OFFSET = 728;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*start_mountable)(GFile *, GDriveStartFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long start_mountable$offset() {
        return start_mountable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*start_mountable)(GFile *, GDriveStartFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment start_mountable(MemorySegment struct) {
        return struct.get(start_mountable$LAYOUT, start_mountable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*start_mountable)(GFile *, GDriveStartFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void start_mountable(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(start_mountable$LAYOUT, start_mountable$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*start_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class start_mountable_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(start_mountable_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(start_mountable_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout start_mountable_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("start_mountable_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*start_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout start_mountable_finish$layout() {
        return start_mountable_finish$LAYOUT;
    }

    private static final long start_mountable_finish$OFFSET = 736;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*start_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long start_mountable_finish$offset() {
        return start_mountable_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*start_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment start_mountable_finish(MemorySegment struct) {
        return struct.get(start_mountable_finish$LAYOUT, start_mountable_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*start_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void start_mountable_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(start_mountable_finish$LAYOUT, start_mountable_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*stop_mountable)(GFile *, GMountUnmountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class stop_mountable {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(stop_mountable.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(stop_mountable.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout stop_mountable$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("stop_mountable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*stop_mountable)(GFile *, GMountUnmountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout stop_mountable$layout() {
        return stop_mountable$LAYOUT;
    }

    private static final long stop_mountable$OFFSET = 744;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*stop_mountable)(GFile *, GMountUnmountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long stop_mountable$offset() {
        return stop_mountable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*stop_mountable)(GFile *, GMountUnmountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment stop_mountable(MemorySegment struct) {
        return struct.get(stop_mountable$LAYOUT, stop_mountable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*stop_mountable)(GFile *, GMountUnmountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void stop_mountable(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(stop_mountable$LAYOUT, stop_mountable$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*stop_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class stop_mountable_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(stop_mountable_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(stop_mountable_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout stop_mountable_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("stop_mountable_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*stop_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout stop_mountable_finish$layout() {
        return stop_mountable_finish$LAYOUT;
    }

    private static final long stop_mountable_finish$OFFSET = 752;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*stop_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long stop_mountable_finish$offset() {
        return stop_mountable_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*stop_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment stop_mountable_finish(MemorySegment struct) {
        return struct.get(stop_mountable_finish$LAYOUT, stop_mountable_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*stop_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void stop_mountable_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(stop_mountable_finish$LAYOUT, stop_mountable_finish$OFFSET, fieldValue);
    }

    private static final OfInt supports_thread_contexts$LAYOUT = (OfInt)$LAYOUT.select(groupElement("supports_thread_contexts"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean supports_thread_contexts
     * }
     */
    public static final OfInt supports_thread_contexts$layout() {
        return supports_thread_contexts$LAYOUT;
    }

    private static final long supports_thread_contexts$OFFSET = 760;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean supports_thread_contexts
     * }
     */
    public static final long supports_thread_contexts$offset() {
        return supports_thread_contexts$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean supports_thread_contexts
     * }
     */
    public static int supports_thread_contexts(MemorySegment struct) {
        return struct.get(supports_thread_contexts$LAYOUT, supports_thread_contexts$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean supports_thread_contexts
     * }
     */
    public static void supports_thread_contexts(MemorySegment struct, int fieldValue) {
        struct.set(supports_thread_contexts$LAYOUT, supports_thread_contexts$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*unmount_mountable_with_operation)(GFile *, GMountUnmountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class unmount_mountable_with_operation {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(unmount_mountable_with_operation.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(unmount_mountable_with_operation.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout unmount_mountable_with_operation$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("unmount_mountable_with_operation"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*unmount_mountable_with_operation)(GFile *, GMountUnmountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout unmount_mountable_with_operation$layout() {
        return unmount_mountable_with_operation$LAYOUT;
    }

    private static final long unmount_mountable_with_operation$OFFSET = 768;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*unmount_mountable_with_operation)(GFile *, GMountUnmountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long unmount_mountable_with_operation$offset() {
        return unmount_mountable_with_operation$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*unmount_mountable_with_operation)(GFile *, GMountUnmountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment unmount_mountable_with_operation(MemorySegment struct) {
        return struct.get(unmount_mountable_with_operation$LAYOUT, unmount_mountable_with_operation$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*unmount_mountable_with_operation)(GFile *, GMountUnmountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void unmount_mountable_with_operation(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(unmount_mountable_with_operation$LAYOUT, unmount_mountable_with_operation$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*unmount_mountable_with_operation_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class unmount_mountable_with_operation_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(unmount_mountable_with_operation_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(unmount_mountable_with_operation_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout unmount_mountable_with_operation_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("unmount_mountable_with_operation_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*unmount_mountable_with_operation_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout unmount_mountable_with_operation_finish$layout() {
        return unmount_mountable_with_operation_finish$LAYOUT;
    }

    private static final long unmount_mountable_with_operation_finish$OFFSET = 776;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*unmount_mountable_with_operation_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long unmount_mountable_with_operation_finish$offset() {
        return unmount_mountable_with_operation_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*unmount_mountable_with_operation_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment unmount_mountable_with_operation_finish(MemorySegment struct) {
        return struct.get(unmount_mountable_with_operation_finish$LAYOUT, unmount_mountable_with_operation_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*unmount_mountable_with_operation_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void unmount_mountable_with_operation_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(unmount_mountable_with_operation_finish$LAYOUT, unmount_mountable_with_operation_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*eject_mountable_with_operation)(GFile *, GMountUnmountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class eject_mountable_with_operation {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(eject_mountable_with_operation.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(eject_mountable_with_operation.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout eject_mountable_with_operation$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("eject_mountable_with_operation"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*eject_mountable_with_operation)(GFile *, GMountUnmountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout eject_mountable_with_operation$layout() {
        return eject_mountable_with_operation$LAYOUT;
    }

    private static final long eject_mountable_with_operation$OFFSET = 784;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*eject_mountable_with_operation)(GFile *, GMountUnmountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long eject_mountable_with_operation$offset() {
        return eject_mountable_with_operation$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*eject_mountable_with_operation)(GFile *, GMountUnmountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment eject_mountable_with_operation(MemorySegment struct) {
        return struct.get(eject_mountable_with_operation$LAYOUT, eject_mountable_with_operation$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*eject_mountable_with_operation)(GFile *, GMountUnmountFlags, GMountOperation *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void eject_mountable_with_operation(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(eject_mountable_with_operation$LAYOUT, eject_mountable_with_operation$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*eject_mountable_with_operation_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class eject_mountable_with_operation_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(eject_mountable_with_operation_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(eject_mountable_with_operation_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout eject_mountable_with_operation_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("eject_mountable_with_operation_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*eject_mountable_with_operation_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout eject_mountable_with_operation_finish$layout() {
        return eject_mountable_with_operation_finish$LAYOUT;
    }

    private static final long eject_mountable_with_operation_finish$OFFSET = 792;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*eject_mountable_with_operation_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long eject_mountable_with_operation_finish$offset() {
        return eject_mountable_with_operation_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*eject_mountable_with_operation_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment eject_mountable_with_operation_finish(MemorySegment struct) {
        return struct.get(eject_mountable_with_operation_finish$LAYOUT, eject_mountable_with_operation_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*eject_mountable_with_operation_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void eject_mountable_with_operation_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(eject_mountable_with_operation_finish$LAYOUT, eject_mountable_with_operation_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*poll_mountable)(GFile *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public class poll_mountable {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(poll_mountable.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(poll_mountable.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout poll_mountable$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("poll_mountable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*poll_mountable)(GFile *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout poll_mountable$layout() {
        return poll_mountable$LAYOUT;
    }

    private static final long poll_mountable$OFFSET = 800;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*poll_mountable)(GFile *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long poll_mountable$offset() {
        return poll_mountable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*poll_mountable)(GFile *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment poll_mountable(MemorySegment struct) {
        return struct.get(poll_mountable$LAYOUT, poll_mountable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*poll_mountable)(GFile *, GCancellable *, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void poll_mountable(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(poll_mountable$LAYOUT, poll_mountable$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*poll_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public class poll_mountable_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(poll_mountable_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(poll_mountable_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout poll_mountable_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("poll_mountable_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*poll_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final AddressLayout poll_mountable_finish$layout() {
        return poll_mountable_finish$LAYOUT;
    }

    private static final long poll_mountable_finish$OFFSET = 808;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*poll_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static final long poll_mountable_finish$offset() {
        return poll_mountable_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*poll_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static MemorySegment poll_mountable_finish(MemorySegment struct) {
        return struct.get(poll_mountable_finish$LAYOUT, poll_mountable_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*poll_mountable_finish)(GFile *, GAsyncResult *, GError **)
     * }
     */
    public static void poll_mountable_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(poll_mountable_finish$LAYOUT, poll_mountable_finish$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*measure_disk_usage)(GFile *, GFileMeasureFlags, GCancellable *, GFileMeasureProgressCallback, gpointer, guint64 *, guint64 *, guint64 *, GError **)
     * }
     */
    public class measure_disk_usage {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, MemorySegment _x8);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(measure_disk_usage.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(measure_disk_usage.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7, MemorySegment _x8) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout measure_disk_usage$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("measure_disk_usage"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*measure_disk_usage)(GFile *, GFileMeasureFlags, GCancellable *, GFileMeasureProgressCallback, gpointer, guint64 *, guint64 *, guint64 *, GError **)
     * }
     */
    public static final AddressLayout measure_disk_usage$layout() {
        return measure_disk_usage$LAYOUT;
    }

    private static final long measure_disk_usage$OFFSET = 816;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*measure_disk_usage)(GFile *, GFileMeasureFlags, GCancellable *, GFileMeasureProgressCallback, gpointer, guint64 *, guint64 *, guint64 *, GError **)
     * }
     */
    public static final long measure_disk_usage$offset() {
        return measure_disk_usage$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*measure_disk_usage)(GFile *, GFileMeasureFlags, GCancellable *, GFileMeasureProgressCallback, gpointer, guint64 *, guint64 *, guint64 *, GError **)
     * }
     */
    public static MemorySegment measure_disk_usage(MemorySegment struct) {
        return struct.get(measure_disk_usage$LAYOUT, measure_disk_usage$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*measure_disk_usage)(GFile *, GFileMeasureFlags, GCancellable *, GFileMeasureProgressCallback, gpointer, guint64 *, guint64 *, guint64 *, GError **)
     * }
     */
    public static void measure_disk_usage(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(measure_disk_usage$LAYOUT, measure_disk_usage$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*measure_disk_usage_async)(GFile *, GFileMeasureFlags, gint, GCancellable *, GFileMeasureProgressCallback, gpointer, GAsyncReadyCallback, gpointer)
     * }
     */
    public class measure_disk_usage_async {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            app_indicator_h.C_POINTER,
            app_indicator_h.C_INT,
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(measure_disk_usage_async.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(measure_disk_usage_async.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout measure_disk_usage_async$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("measure_disk_usage_async"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*measure_disk_usage_async)(GFile *, GFileMeasureFlags, gint, GCancellable *, GFileMeasureProgressCallback, gpointer, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final AddressLayout measure_disk_usage_async$layout() {
        return measure_disk_usage_async$LAYOUT;
    }

    private static final long measure_disk_usage_async$OFFSET = 824;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*measure_disk_usage_async)(GFile *, GFileMeasureFlags, gint, GCancellable *, GFileMeasureProgressCallback, gpointer, GAsyncReadyCallback, gpointer)
     * }
     */
    public static final long measure_disk_usage_async$offset() {
        return measure_disk_usage_async$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*measure_disk_usage_async)(GFile *, GFileMeasureFlags, gint, GCancellable *, GFileMeasureProgressCallback, gpointer, GAsyncReadyCallback, gpointer)
     * }
     */
    public static MemorySegment measure_disk_usage_async(MemorySegment struct) {
        return struct.get(measure_disk_usage_async$LAYOUT, measure_disk_usage_async$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*measure_disk_usage_async)(GFile *, GFileMeasureFlags, gint, GCancellable *, GFileMeasureProgressCallback, gpointer, GAsyncReadyCallback, gpointer)
     * }
     */
    public static void measure_disk_usage_async(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(measure_disk_usage_async$LAYOUT, measure_disk_usage_async$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * gboolean (*measure_disk_usage_finish)(GFile *, GAsyncResult *, guint64 *, guint64 *, guint64 *, GError **)
     * }
     */
    public class measure_disk_usage_finish {

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            app_indicator_h.C_INT,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER,
            app_indicator_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = app_indicator_h.upcallHandle(measure_disk_usage_finish.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(measure_disk_usage_finish.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout measure_disk_usage_finish$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("measure_disk_usage_finish"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean (*measure_disk_usage_finish)(GFile *, GAsyncResult *, guint64 *, guint64 *, guint64 *, GError **)
     * }
     */
    public static final AddressLayout measure_disk_usage_finish$layout() {
        return measure_disk_usage_finish$LAYOUT;
    }

    private static final long measure_disk_usage_finish$OFFSET = 832;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean (*measure_disk_usage_finish)(GFile *, GAsyncResult *, guint64 *, guint64 *, guint64 *, GError **)
     * }
     */
    public static final long measure_disk_usage_finish$offset() {
        return measure_disk_usage_finish$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean (*measure_disk_usage_finish)(GFile *, GAsyncResult *, guint64 *, guint64 *, guint64 *, GError **)
     * }
     */
    public static MemorySegment measure_disk_usage_finish(MemorySegment struct) {
        return struct.get(measure_disk_usage_finish$LAYOUT, measure_disk_usage_finish$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean (*measure_disk_usage_finish)(GFile *, GAsyncResult *, guint64 *, guint64 *, guint64 *, GError **)
     * }
     */
    public static void measure_disk_usage_finish(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(measure_disk_usage_finish$LAYOUT, measure_disk_usage_finish$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

