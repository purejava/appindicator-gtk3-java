// Generated by jextract

package org.purejava.linux;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
public class _GFileIface {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        MemoryLayout.structLayout(
            Constants$root.C_LONG_LONG$LAYOUT.withName("g_type"),
            Constants$root.C_LONG_LONG$LAYOUT.withName("g_instance_type")
        ).withName("g_iface"),
        Constants$root.C_POINTER$LAYOUT.withName("dup"),
        Constants$root.C_POINTER$LAYOUT.withName("hash"),
        Constants$root.C_POINTER$LAYOUT.withName("equal"),
        Constants$root.C_POINTER$LAYOUT.withName("is_native"),
        Constants$root.C_POINTER$LAYOUT.withName("has_uri_scheme"),
        Constants$root.C_POINTER$LAYOUT.withName("get_uri_scheme"),
        Constants$root.C_POINTER$LAYOUT.withName("get_basename"),
        Constants$root.C_POINTER$LAYOUT.withName("get_path"),
        Constants$root.C_POINTER$LAYOUT.withName("get_uri"),
        Constants$root.C_POINTER$LAYOUT.withName("get_parse_name"),
        Constants$root.C_POINTER$LAYOUT.withName("get_parent"),
        Constants$root.C_POINTER$LAYOUT.withName("prefix_matches"),
        Constants$root.C_POINTER$LAYOUT.withName("get_relative_path"),
        Constants$root.C_POINTER$LAYOUT.withName("resolve_relative_path"),
        Constants$root.C_POINTER$LAYOUT.withName("get_child_for_display_name"),
        Constants$root.C_POINTER$LAYOUT.withName("enumerate_children"),
        Constants$root.C_POINTER$LAYOUT.withName("enumerate_children_async"),
        Constants$root.C_POINTER$LAYOUT.withName("enumerate_children_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("query_info"),
        Constants$root.C_POINTER$LAYOUT.withName("query_info_async"),
        Constants$root.C_POINTER$LAYOUT.withName("query_info_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("query_filesystem_info"),
        Constants$root.C_POINTER$LAYOUT.withName("query_filesystem_info_async"),
        Constants$root.C_POINTER$LAYOUT.withName("query_filesystem_info_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("find_enclosing_mount"),
        Constants$root.C_POINTER$LAYOUT.withName("find_enclosing_mount_async"),
        Constants$root.C_POINTER$LAYOUT.withName("find_enclosing_mount_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("set_display_name"),
        Constants$root.C_POINTER$LAYOUT.withName("set_display_name_async"),
        Constants$root.C_POINTER$LAYOUT.withName("set_display_name_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("query_settable_attributes"),
        Constants$root.C_POINTER$LAYOUT.withName("_query_settable_attributes_async"),
        Constants$root.C_POINTER$LAYOUT.withName("_query_settable_attributes_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("query_writable_namespaces"),
        Constants$root.C_POINTER$LAYOUT.withName("_query_writable_namespaces_async"),
        Constants$root.C_POINTER$LAYOUT.withName("_query_writable_namespaces_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("set_attribute"),
        Constants$root.C_POINTER$LAYOUT.withName("set_attributes_from_info"),
        Constants$root.C_POINTER$LAYOUT.withName("set_attributes_async"),
        Constants$root.C_POINTER$LAYOUT.withName("set_attributes_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("read_fn"),
        Constants$root.C_POINTER$LAYOUT.withName("read_async"),
        Constants$root.C_POINTER$LAYOUT.withName("read_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("append_to"),
        Constants$root.C_POINTER$LAYOUT.withName("append_to_async"),
        Constants$root.C_POINTER$LAYOUT.withName("append_to_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("create"),
        Constants$root.C_POINTER$LAYOUT.withName("create_async"),
        Constants$root.C_POINTER$LAYOUT.withName("create_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("replace"),
        Constants$root.C_POINTER$LAYOUT.withName("replace_async"),
        Constants$root.C_POINTER$LAYOUT.withName("replace_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("delete_file"),
        Constants$root.C_POINTER$LAYOUT.withName("delete_file_async"),
        Constants$root.C_POINTER$LAYOUT.withName("delete_file_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("trash"),
        Constants$root.C_POINTER$LAYOUT.withName("trash_async"),
        Constants$root.C_POINTER$LAYOUT.withName("trash_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("make_directory"),
        Constants$root.C_POINTER$LAYOUT.withName("make_directory_async"),
        Constants$root.C_POINTER$LAYOUT.withName("make_directory_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("make_symbolic_link"),
        Constants$root.C_POINTER$LAYOUT.withName("_make_symbolic_link_async"),
        Constants$root.C_POINTER$LAYOUT.withName("_make_symbolic_link_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("copy"),
        Constants$root.C_POINTER$LAYOUT.withName("copy_async"),
        Constants$root.C_POINTER$LAYOUT.withName("copy_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("move"),
        Constants$root.C_POINTER$LAYOUT.withName("move_async"),
        Constants$root.C_POINTER$LAYOUT.withName("move_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("mount_mountable"),
        Constants$root.C_POINTER$LAYOUT.withName("mount_mountable_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("unmount_mountable"),
        Constants$root.C_POINTER$LAYOUT.withName("unmount_mountable_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("eject_mountable"),
        Constants$root.C_POINTER$LAYOUT.withName("eject_mountable_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("mount_enclosing_volume"),
        Constants$root.C_POINTER$LAYOUT.withName("mount_enclosing_volume_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("monitor_dir"),
        Constants$root.C_POINTER$LAYOUT.withName("monitor_file"),
        Constants$root.C_POINTER$LAYOUT.withName("open_readwrite"),
        Constants$root.C_POINTER$LAYOUT.withName("open_readwrite_async"),
        Constants$root.C_POINTER$LAYOUT.withName("open_readwrite_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("create_readwrite"),
        Constants$root.C_POINTER$LAYOUT.withName("create_readwrite_async"),
        Constants$root.C_POINTER$LAYOUT.withName("create_readwrite_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("replace_readwrite"),
        Constants$root.C_POINTER$LAYOUT.withName("replace_readwrite_async"),
        Constants$root.C_POINTER$LAYOUT.withName("replace_readwrite_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("start_mountable"),
        Constants$root.C_POINTER$LAYOUT.withName("start_mountable_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("stop_mountable"),
        Constants$root.C_POINTER$LAYOUT.withName("stop_mountable_finish"),
        Constants$root.C_INT$LAYOUT.withName("supports_thread_contexts"),
        MemoryLayout.paddingLayout(32),
        Constants$root.C_POINTER$LAYOUT.withName("unmount_mountable_with_operation"),
        Constants$root.C_POINTER$LAYOUT.withName("unmount_mountable_with_operation_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("eject_mountable_with_operation"),
        Constants$root.C_POINTER$LAYOUT.withName("eject_mountable_with_operation_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("poll_mountable"),
        Constants$root.C_POINTER$LAYOUT.withName("poll_mountable_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("measure_disk_usage"),
        Constants$root.C_POINTER$LAYOUT.withName("measure_disk_usage_async"),
        Constants$root.C_POINTER$LAYOUT.withName("measure_disk_usage_finish")
    ).withName("_GFileIface");
    public static MemoryLayout $LAYOUT() {
        return _GFileIface.$struct$LAYOUT;
    }
    public static MemorySegment g_iface$slice(MemorySegment seg) {
        return seg.asSlice(0, 16);
    }
    static final FunctionDescriptor dup$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle dup$MH = RuntimeHelper.downcallHandle(
        _GFileIface.dup$FUNC
    );
    public interface dup {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(dup fi, MemorySession session) {
            return RuntimeHelper.upcallStub(dup.class, fi, _GFileIface.dup$FUNC, session);
        }
        static dup ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.dup$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle dup$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("dup"));
    public static VarHandle dup$VH() {
        return _GFileIface.dup$VH;
    }
    public static MemoryAddress dup$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.dup$VH.get(seg);
    }
    public static void dup$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.dup$VH.set(seg, x);
    }
    public static MemoryAddress dup$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.dup$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void dup$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.dup$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static dup dup (MemorySegment segment, MemorySession session) {
        return dup.ofAddress(dup$get(segment), session);
    }
    static final FunctionDescriptor hash$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle hash$MH = RuntimeHelper.downcallHandle(
        _GFileIface.hash$FUNC
    );
    public interface hash {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(hash fi, MemorySession session) {
            return RuntimeHelper.upcallStub(hash.class, fi, _GFileIface.hash$FUNC, session);
        }
        static hash ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)_GFileIface.hash$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle hash$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("hash"));
    public static VarHandle hash$VH() {
        return _GFileIface.hash$VH;
    }
    public static MemoryAddress hash$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.hash$VH.get(seg);
    }
    public static void hash$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.hash$VH.set(seg, x);
    }
    public static MemoryAddress hash$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.hash$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void hash$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.hash$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static hash hash (MemorySegment segment, MemorySession session) {
        return hash.ofAddress(hash$get(segment), session);
    }
    static final FunctionDescriptor equal$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle equal$MH = RuntimeHelper.downcallHandle(
        _GFileIface.equal$FUNC
    );
    public interface equal {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(equal fi, MemorySession session) {
            return RuntimeHelper.upcallStub(equal.class, fi, _GFileIface.equal$FUNC, session);
        }
        static equal ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)_GFileIface.equal$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle equal$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("equal"));
    public static VarHandle equal$VH() {
        return _GFileIface.equal$VH;
    }
    public static MemoryAddress equal$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.equal$VH.get(seg);
    }
    public static void equal$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.equal$VH.set(seg, x);
    }
    public static MemoryAddress equal$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.equal$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void equal$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.equal$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static equal equal (MemorySegment segment, MemorySession session) {
        return equal.ofAddress(equal$get(segment), session);
    }
    static final FunctionDescriptor is_native$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle is_native$MH = RuntimeHelper.downcallHandle(
        _GFileIface.is_native$FUNC
    );
    public interface is_native {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(is_native fi, MemorySession session) {
            return RuntimeHelper.upcallStub(is_native.class, fi, _GFileIface.is_native$FUNC, session);
        }
        static is_native ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)_GFileIface.is_native$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle is_native$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("is_native"));
    public static VarHandle is_native$VH() {
        return _GFileIface.is_native$VH;
    }
    public static MemoryAddress is_native$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.is_native$VH.get(seg);
    }
    public static void is_native$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.is_native$VH.set(seg, x);
    }
    public static MemoryAddress is_native$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.is_native$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void is_native$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.is_native$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static is_native is_native (MemorySegment segment, MemorySession session) {
        return is_native.ofAddress(is_native$get(segment), session);
    }
    static final FunctionDescriptor has_uri_scheme$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle has_uri_scheme$MH = RuntimeHelper.downcallHandle(
        _GFileIface.has_uri_scheme$FUNC
    );
    public interface has_uri_scheme {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(has_uri_scheme fi, MemorySession session) {
            return RuntimeHelper.upcallStub(has_uri_scheme.class, fi, _GFileIface.has_uri_scheme$FUNC, session);
        }
        static has_uri_scheme ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)_GFileIface.has_uri_scheme$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle has_uri_scheme$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("has_uri_scheme"));
    public static VarHandle has_uri_scheme$VH() {
        return _GFileIface.has_uri_scheme$VH;
    }
    public static MemoryAddress has_uri_scheme$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.has_uri_scheme$VH.get(seg);
    }
    public static void has_uri_scheme$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.has_uri_scheme$VH.set(seg, x);
    }
    public static MemoryAddress has_uri_scheme$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.has_uri_scheme$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void has_uri_scheme$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.has_uri_scheme$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static has_uri_scheme has_uri_scheme (MemorySegment segment, MemorySession session) {
        return has_uri_scheme.ofAddress(has_uri_scheme$get(segment), session);
    }
    static final FunctionDescriptor get_uri_scheme$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_uri_scheme$MH = RuntimeHelper.downcallHandle(
        _GFileIface.get_uri_scheme$FUNC
    );
    public interface get_uri_scheme {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(get_uri_scheme fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_uri_scheme.class, fi, _GFileIface.get_uri_scheme$FUNC, session);
        }
        static get_uri_scheme ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.get_uri_scheme$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_uri_scheme$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_uri_scheme"));
    public static VarHandle get_uri_scheme$VH() {
        return _GFileIface.get_uri_scheme$VH;
    }
    public static MemoryAddress get_uri_scheme$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.get_uri_scheme$VH.get(seg);
    }
    public static void get_uri_scheme$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.get_uri_scheme$VH.set(seg, x);
    }
    public static MemoryAddress get_uri_scheme$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.get_uri_scheme$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_uri_scheme$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.get_uri_scheme$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_uri_scheme get_uri_scheme (MemorySegment segment, MemorySession session) {
        return get_uri_scheme.ofAddress(get_uri_scheme$get(segment), session);
    }
    static final FunctionDescriptor get_basename$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_basename$MH = RuntimeHelper.downcallHandle(
        _GFileIface.get_basename$FUNC
    );
    public interface get_basename {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(get_basename fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_basename.class, fi, _GFileIface.get_basename$FUNC, session);
        }
        static get_basename ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.get_basename$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_basename$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_basename"));
    public static VarHandle get_basename$VH() {
        return _GFileIface.get_basename$VH;
    }
    public static MemoryAddress get_basename$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.get_basename$VH.get(seg);
    }
    public static void get_basename$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.get_basename$VH.set(seg, x);
    }
    public static MemoryAddress get_basename$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.get_basename$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_basename$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.get_basename$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_basename get_basename (MemorySegment segment, MemorySession session) {
        return get_basename.ofAddress(get_basename$get(segment), session);
    }
    static final FunctionDescriptor get_path$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_path$MH = RuntimeHelper.downcallHandle(
        _GFileIface.get_path$FUNC
    );
    public interface get_path {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(get_path fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_path.class, fi, _GFileIface.get_path$FUNC, session);
        }
        static get_path ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.get_path$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_path$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_path"));
    public static VarHandle get_path$VH() {
        return _GFileIface.get_path$VH;
    }
    public static MemoryAddress get_path$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.get_path$VH.get(seg);
    }
    public static void get_path$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.get_path$VH.set(seg, x);
    }
    public static MemoryAddress get_path$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.get_path$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_path$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.get_path$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_path get_path (MemorySegment segment, MemorySession session) {
        return get_path.ofAddress(get_path$get(segment), session);
    }
    static final FunctionDescriptor get_uri$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_uri$MH = RuntimeHelper.downcallHandle(
        _GFileIface.get_uri$FUNC
    );
    public interface get_uri {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(get_uri fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_uri.class, fi, _GFileIface.get_uri$FUNC, session);
        }
        static get_uri ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.get_uri$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_uri$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_uri"));
    public static VarHandle get_uri$VH() {
        return _GFileIface.get_uri$VH;
    }
    public static MemoryAddress get_uri$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.get_uri$VH.get(seg);
    }
    public static void get_uri$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.get_uri$VH.set(seg, x);
    }
    public static MemoryAddress get_uri$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.get_uri$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_uri$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.get_uri$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_uri get_uri (MemorySegment segment, MemorySession session) {
        return get_uri.ofAddress(get_uri$get(segment), session);
    }
    static final FunctionDescriptor get_parse_name$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_parse_name$MH = RuntimeHelper.downcallHandle(
        _GFileIface.get_parse_name$FUNC
    );
    public interface get_parse_name {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(get_parse_name fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_parse_name.class, fi, _GFileIface.get_parse_name$FUNC, session);
        }
        static get_parse_name ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.get_parse_name$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_parse_name$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_parse_name"));
    public static VarHandle get_parse_name$VH() {
        return _GFileIface.get_parse_name$VH;
    }
    public static MemoryAddress get_parse_name$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.get_parse_name$VH.get(seg);
    }
    public static void get_parse_name$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.get_parse_name$VH.set(seg, x);
    }
    public static MemoryAddress get_parse_name$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.get_parse_name$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_parse_name$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.get_parse_name$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_parse_name get_parse_name (MemorySegment segment, MemorySession session) {
        return get_parse_name.ofAddress(get_parse_name$get(segment), session);
    }
    static final FunctionDescriptor get_parent$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_parent$MH = RuntimeHelper.downcallHandle(
        _GFileIface.get_parent$FUNC
    );
    public interface get_parent {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(get_parent fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_parent.class, fi, _GFileIface.get_parent$FUNC, session);
        }
        static get_parent ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.get_parent$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_parent$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_parent"));
    public static VarHandle get_parent$VH() {
        return _GFileIface.get_parent$VH;
    }
    public static MemoryAddress get_parent$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.get_parent$VH.get(seg);
    }
    public static void get_parent$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.get_parent$VH.set(seg, x);
    }
    public static MemoryAddress get_parent$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.get_parent$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_parent$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.get_parent$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_parent get_parent (MemorySegment segment, MemorySession session) {
        return get_parent.ofAddress(get_parent$get(segment), session);
    }
    static final FunctionDescriptor prefix_matches$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle prefix_matches$MH = RuntimeHelper.downcallHandle(
        _GFileIface.prefix_matches$FUNC
    );
    public interface prefix_matches {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(prefix_matches fi, MemorySession session) {
            return RuntimeHelper.upcallStub(prefix_matches.class, fi, _GFileIface.prefix_matches$FUNC, session);
        }
        static prefix_matches ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)_GFileIface.prefix_matches$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle prefix_matches$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("prefix_matches"));
    public static VarHandle prefix_matches$VH() {
        return _GFileIface.prefix_matches$VH;
    }
    public static MemoryAddress prefix_matches$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.prefix_matches$VH.get(seg);
    }
    public static void prefix_matches$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.prefix_matches$VH.set(seg, x);
    }
    public static MemoryAddress prefix_matches$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.prefix_matches$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void prefix_matches$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.prefix_matches$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static prefix_matches prefix_matches (MemorySegment segment, MemorySession session) {
        return prefix_matches.ofAddress(prefix_matches$get(segment), session);
    }
    static final FunctionDescriptor get_relative_path$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_relative_path$MH = RuntimeHelper.downcallHandle(
        _GFileIface.get_relative_path$FUNC
    );
    public interface get_relative_path {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(get_relative_path fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_relative_path.class, fi, _GFileIface.get_relative_path$FUNC, session);
        }
        static get_relative_path ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.get_relative_path$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_relative_path$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_relative_path"));
    public static VarHandle get_relative_path$VH() {
        return _GFileIface.get_relative_path$VH;
    }
    public static MemoryAddress get_relative_path$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.get_relative_path$VH.get(seg);
    }
    public static void get_relative_path$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.get_relative_path$VH.set(seg, x);
    }
    public static MemoryAddress get_relative_path$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.get_relative_path$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_relative_path$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.get_relative_path$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_relative_path get_relative_path (MemorySegment segment, MemorySession session) {
        return get_relative_path.ofAddress(get_relative_path$get(segment), session);
    }
    static final FunctionDescriptor resolve_relative_path$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle resolve_relative_path$MH = RuntimeHelper.downcallHandle(
        _GFileIface.resolve_relative_path$FUNC
    );
    public interface resolve_relative_path {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(resolve_relative_path fi, MemorySession session) {
            return RuntimeHelper.upcallStub(resolve_relative_path.class, fi, _GFileIface.resolve_relative_path$FUNC, session);
        }
        static resolve_relative_path ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.resolve_relative_path$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle resolve_relative_path$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("resolve_relative_path"));
    public static VarHandle resolve_relative_path$VH() {
        return _GFileIface.resolve_relative_path$VH;
    }
    public static MemoryAddress resolve_relative_path$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.resolve_relative_path$VH.get(seg);
    }
    public static void resolve_relative_path$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.resolve_relative_path$VH.set(seg, x);
    }
    public static MemoryAddress resolve_relative_path$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.resolve_relative_path$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void resolve_relative_path$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.resolve_relative_path$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static resolve_relative_path resolve_relative_path (MemorySegment segment, MemorySession session) {
        return resolve_relative_path.ofAddress(resolve_relative_path$get(segment), session);
    }
    static final FunctionDescriptor get_child_for_display_name$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_child_for_display_name$MH = RuntimeHelper.downcallHandle(
        _GFileIface.get_child_for_display_name$FUNC
    );
    public interface get_child_for_display_name {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(get_child_for_display_name fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_child_for_display_name.class, fi, _GFileIface.get_child_for_display_name$FUNC, session);
        }
        static get_child_for_display_name ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.get_child_for_display_name$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_child_for_display_name$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_child_for_display_name"));
    public static VarHandle get_child_for_display_name$VH() {
        return _GFileIface.get_child_for_display_name$VH;
    }
    public static MemoryAddress get_child_for_display_name$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.get_child_for_display_name$VH.get(seg);
    }
    public static void get_child_for_display_name$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.get_child_for_display_name$VH.set(seg, x);
    }
    public static MemoryAddress get_child_for_display_name$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.get_child_for_display_name$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_child_for_display_name$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.get_child_for_display_name$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_child_for_display_name get_child_for_display_name (MemorySegment segment, MemorySession session) {
        return get_child_for_display_name.ofAddress(get_child_for_display_name$get(segment), session);
    }
    static final FunctionDescriptor enumerate_children$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle enumerate_children$MH = RuntimeHelper.downcallHandle(
        _GFileIface.enumerate_children$FUNC
    );
    public interface enumerate_children {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(enumerate_children fi, MemorySession session) {
            return RuntimeHelper.upcallStub(enumerate_children.class, fi, _GFileIface.enumerate_children$FUNC, session);
        }
        static enumerate_children ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.enumerate_children$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle enumerate_children$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("enumerate_children"));
    public static VarHandle enumerate_children$VH() {
        return _GFileIface.enumerate_children$VH;
    }
    public static MemoryAddress enumerate_children$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.enumerate_children$VH.get(seg);
    }
    public static void enumerate_children$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.enumerate_children$VH.set(seg, x);
    }
    public static MemoryAddress enumerate_children$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.enumerate_children$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void enumerate_children$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.enumerate_children$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static enumerate_children enumerate_children (MemorySegment segment, MemorySession session) {
        return enumerate_children.ofAddress(enumerate_children$get(segment), session);
    }
    static final FunctionDescriptor enumerate_children_async$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle enumerate_children_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface.enumerate_children_async$FUNC
    );
    public interface enumerate_children_async {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6);
        static MemorySegment allocate(enumerate_children_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(enumerate_children_async.class, fi, _GFileIface.enumerate_children_async$FUNC, session);
        }
        static enumerate_children_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6) -> {
                try {
                    _GFileIface.enumerate_children_async$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle enumerate_children_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("enumerate_children_async"));
    public static VarHandle enumerate_children_async$VH() {
        return _GFileIface.enumerate_children_async$VH;
    }
    public static MemoryAddress enumerate_children_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.enumerate_children_async$VH.get(seg);
    }
    public static void enumerate_children_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.enumerate_children_async$VH.set(seg, x);
    }
    public static MemoryAddress enumerate_children_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.enumerate_children_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void enumerate_children_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.enumerate_children_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static enumerate_children_async enumerate_children_async (MemorySegment segment, MemorySession session) {
        return enumerate_children_async.ofAddress(enumerate_children_async$get(segment), session);
    }
    static final FunctionDescriptor enumerate_children_finish$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle enumerate_children_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.enumerate_children_finish$FUNC
    );
    public interface enumerate_children_finish {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(enumerate_children_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(enumerate_children_finish.class, fi, _GFileIface.enumerate_children_finish$FUNC, session);
        }
        static enumerate_children_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.enumerate_children_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle enumerate_children_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("enumerate_children_finish"));
    public static VarHandle enumerate_children_finish$VH() {
        return _GFileIface.enumerate_children_finish$VH;
    }
    public static MemoryAddress enumerate_children_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.enumerate_children_finish$VH.get(seg);
    }
    public static void enumerate_children_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.enumerate_children_finish$VH.set(seg, x);
    }
    public static MemoryAddress enumerate_children_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.enumerate_children_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void enumerate_children_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.enumerate_children_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static enumerate_children_finish enumerate_children_finish (MemorySegment segment, MemorySession session) {
        return enumerate_children_finish.ofAddress(enumerate_children_finish$get(segment), session);
    }
    static final FunctionDescriptor query_info$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle query_info$MH = RuntimeHelper.downcallHandle(
        _GFileIface.query_info$FUNC
    );
    public interface query_info {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(query_info fi, MemorySession session) {
            return RuntimeHelper.upcallStub(query_info.class, fi, _GFileIface.query_info$FUNC, session);
        }
        static query_info ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.query_info$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle query_info$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("query_info"));
    public static VarHandle query_info$VH() {
        return _GFileIface.query_info$VH;
    }
    public static MemoryAddress query_info$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.query_info$VH.get(seg);
    }
    public static void query_info$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.query_info$VH.set(seg, x);
    }
    public static MemoryAddress query_info$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.query_info$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void query_info$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.query_info$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static query_info query_info (MemorySegment segment, MemorySession session) {
        return query_info.ofAddress(query_info$get(segment), session);
    }
    static final FunctionDescriptor query_info_async$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle query_info_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface.query_info_async$FUNC
    );
    public interface query_info_async {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6);
        static MemorySegment allocate(query_info_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(query_info_async.class, fi, _GFileIface.query_info_async$FUNC, session);
        }
        static query_info_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6) -> {
                try {
                    _GFileIface.query_info_async$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle query_info_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("query_info_async"));
    public static VarHandle query_info_async$VH() {
        return _GFileIface.query_info_async$VH;
    }
    public static MemoryAddress query_info_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.query_info_async$VH.get(seg);
    }
    public static void query_info_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.query_info_async$VH.set(seg, x);
    }
    public static MemoryAddress query_info_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.query_info_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void query_info_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.query_info_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static query_info_async query_info_async (MemorySegment segment, MemorySession session) {
        return query_info_async.ofAddress(query_info_async$get(segment), session);
    }
    static final FunctionDescriptor query_info_finish$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle query_info_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.query_info_finish$FUNC
    );
    public interface query_info_finish {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(query_info_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(query_info_finish.class, fi, _GFileIface.query_info_finish$FUNC, session);
        }
        static query_info_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.query_info_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle query_info_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("query_info_finish"));
    public static VarHandle query_info_finish$VH() {
        return _GFileIface.query_info_finish$VH;
    }
    public static MemoryAddress query_info_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.query_info_finish$VH.get(seg);
    }
    public static void query_info_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.query_info_finish$VH.set(seg, x);
    }
    public static MemoryAddress query_info_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.query_info_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void query_info_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.query_info_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static query_info_finish query_info_finish (MemorySegment segment, MemorySession session) {
        return query_info_finish.ofAddress(query_info_finish$get(segment), session);
    }
    static final FunctionDescriptor query_filesystem_info$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle query_filesystem_info$MH = RuntimeHelper.downcallHandle(
        _GFileIface.query_filesystem_info$FUNC
    );
    public interface query_filesystem_info {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(query_filesystem_info fi, MemorySession session) {
            return RuntimeHelper.upcallStub(query_filesystem_info.class, fi, _GFileIface.query_filesystem_info$FUNC, session);
        }
        static query_filesystem_info ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.query_filesystem_info$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle query_filesystem_info$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("query_filesystem_info"));
    public static VarHandle query_filesystem_info$VH() {
        return _GFileIface.query_filesystem_info$VH;
    }
    public static MemoryAddress query_filesystem_info$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.query_filesystem_info$VH.get(seg);
    }
    public static void query_filesystem_info$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.query_filesystem_info$VH.set(seg, x);
    }
    public static MemoryAddress query_filesystem_info$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.query_filesystem_info$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void query_filesystem_info$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.query_filesystem_info$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static query_filesystem_info query_filesystem_info (MemorySegment segment, MemorySession session) {
        return query_filesystem_info.ofAddress(query_filesystem_info$get(segment), session);
    }
    static final FunctionDescriptor query_filesystem_info_async$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle query_filesystem_info_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface.query_filesystem_info_async$FUNC
    );
    public interface query_filesystem_info_async {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(query_filesystem_info_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(query_filesystem_info_async.class, fi, _GFileIface.query_filesystem_info_async$FUNC, session);
        }
        static query_filesystem_info_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    _GFileIface.query_filesystem_info_async$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle query_filesystem_info_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("query_filesystem_info_async"));
    public static VarHandle query_filesystem_info_async$VH() {
        return _GFileIface.query_filesystem_info_async$VH;
    }
    public static MemoryAddress query_filesystem_info_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.query_filesystem_info_async$VH.get(seg);
    }
    public static void query_filesystem_info_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.query_filesystem_info_async$VH.set(seg, x);
    }
    public static MemoryAddress query_filesystem_info_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.query_filesystem_info_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void query_filesystem_info_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.query_filesystem_info_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static query_filesystem_info_async query_filesystem_info_async (MemorySegment segment, MemorySession session) {
        return query_filesystem_info_async.ofAddress(query_filesystem_info_async$get(segment), session);
    }
    static final FunctionDescriptor query_filesystem_info_finish$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle query_filesystem_info_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.query_filesystem_info_finish$FUNC
    );
    public interface query_filesystem_info_finish {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(query_filesystem_info_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(query_filesystem_info_finish.class, fi, _GFileIface.query_filesystem_info_finish$FUNC, session);
        }
        static query_filesystem_info_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.query_filesystem_info_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle query_filesystem_info_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("query_filesystem_info_finish"));
    public static VarHandle query_filesystem_info_finish$VH() {
        return _GFileIface.query_filesystem_info_finish$VH;
    }
    public static MemoryAddress query_filesystem_info_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.query_filesystem_info_finish$VH.get(seg);
    }
    public static void query_filesystem_info_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.query_filesystem_info_finish$VH.set(seg, x);
    }
    public static MemoryAddress query_filesystem_info_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.query_filesystem_info_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void query_filesystem_info_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.query_filesystem_info_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static query_filesystem_info_finish query_filesystem_info_finish (MemorySegment segment, MemorySession session) {
        return query_filesystem_info_finish.ofAddress(query_filesystem_info_finish$get(segment), session);
    }
    static final FunctionDescriptor find_enclosing_mount$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle find_enclosing_mount$MH = RuntimeHelper.downcallHandle(
        _GFileIface.find_enclosing_mount$FUNC
    );
    public interface find_enclosing_mount {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(find_enclosing_mount fi, MemorySession session) {
            return RuntimeHelper.upcallStub(find_enclosing_mount.class, fi, _GFileIface.find_enclosing_mount$FUNC, session);
        }
        static find_enclosing_mount ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.find_enclosing_mount$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle find_enclosing_mount$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("find_enclosing_mount"));
    public static VarHandle find_enclosing_mount$VH() {
        return _GFileIface.find_enclosing_mount$VH;
    }
    public static MemoryAddress find_enclosing_mount$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.find_enclosing_mount$VH.get(seg);
    }
    public static void find_enclosing_mount$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.find_enclosing_mount$VH.set(seg, x);
    }
    public static MemoryAddress find_enclosing_mount$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.find_enclosing_mount$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void find_enclosing_mount$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.find_enclosing_mount$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static find_enclosing_mount find_enclosing_mount (MemorySegment segment, MemorySession session) {
        return find_enclosing_mount.ofAddress(find_enclosing_mount$get(segment), session);
    }
    static final FunctionDescriptor find_enclosing_mount_async$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle find_enclosing_mount_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface.find_enclosing_mount_async$FUNC
    );
    public interface find_enclosing_mount_async {

        void apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(find_enclosing_mount_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(find_enclosing_mount_async.class, fi, _GFileIface.find_enclosing_mount_async$FUNC, session);
        }
        static find_enclosing_mount_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    _GFileIface.find_enclosing_mount_async$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle find_enclosing_mount_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("find_enclosing_mount_async"));
    public static VarHandle find_enclosing_mount_async$VH() {
        return _GFileIface.find_enclosing_mount_async$VH;
    }
    public static MemoryAddress find_enclosing_mount_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.find_enclosing_mount_async$VH.get(seg);
    }
    public static void find_enclosing_mount_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.find_enclosing_mount_async$VH.set(seg, x);
    }
    public static MemoryAddress find_enclosing_mount_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.find_enclosing_mount_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void find_enclosing_mount_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.find_enclosing_mount_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static find_enclosing_mount_async find_enclosing_mount_async (MemorySegment segment, MemorySession session) {
        return find_enclosing_mount_async.ofAddress(find_enclosing_mount_async$get(segment), session);
    }
    static final FunctionDescriptor find_enclosing_mount_finish$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle find_enclosing_mount_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.find_enclosing_mount_finish$FUNC
    );
    public interface find_enclosing_mount_finish {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(find_enclosing_mount_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(find_enclosing_mount_finish.class, fi, _GFileIface.find_enclosing_mount_finish$FUNC, session);
        }
        static find_enclosing_mount_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.find_enclosing_mount_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle find_enclosing_mount_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("find_enclosing_mount_finish"));
    public static VarHandle find_enclosing_mount_finish$VH() {
        return _GFileIface.find_enclosing_mount_finish$VH;
    }
    public static MemoryAddress find_enclosing_mount_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.find_enclosing_mount_finish$VH.get(seg);
    }
    public static void find_enclosing_mount_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.find_enclosing_mount_finish$VH.set(seg, x);
    }
    public static MemoryAddress find_enclosing_mount_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.find_enclosing_mount_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void find_enclosing_mount_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.find_enclosing_mount_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static find_enclosing_mount_finish find_enclosing_mount_finish (MemorySegment segment, MemorySession session) {
        return find_enclosing_mount_finish.ofAddress(find_enclosing_mount_finish$get(segment), session);
    }
    static final FunctionDescriptor set_display_name$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle set_display_name$MH = RuntimeHelper.downcallHandle(
        _GFileIface.set_display_name$FUNC
    );
    public interface set_display_name {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(set_display_name fi, MemorySession session) {
            return RuntimeHelper.upcallStub(set_display_name.class, fi, _GFileIface.set_display_name$FUNC, session);
        }
        static set_display_name ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.set_display_name$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle set_display_name$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("set_display_name"));
    public static VarHandle set_display_name$VH() {
        return _GFileIface.set_display_name$VH;
    }
    public static MemoryAddress set_display_name$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.set_display_name$VH.get(seg);
    }
    public static void set_display_name$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.set_display_name$VH.set(seg, x);
    }
    public static MemoryAddress set_display_name$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.set_display_name$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void set_display_name$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.set_display_name$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static set_display_name set_display_name (MemorySegment segment, MemorySession session) {
        return set_display_name.ofAddress(set_display_name$get(segment), session);
    }
    static final FunctionDescriptor set_display_name_async$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle set_display_name_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface.set_display_name_async$FUNC
    );
    public interface set_display_name_async {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(set_display_name_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(set_display_name_async.class, fi, _GFileIface.set_display_name_async$FUNC, session);
        }
        static set_display_name_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    _GFileIface.set_display_name_async$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle set_display_name_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("set_display_name_async"));
    public static VarHandle set_display_name_async$VH() {
        return _GFileIface.set_display_name_async$VH;
    }
    public static MemoryAddress set_display_name_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.set_display_name_async$VH.get(seg);
    }
    public static void set_display_name_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.set_display_name_async$VH.set(seg, x);
    }
    public static MemoryAddress set_display_name_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.set_display_name_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void set_display_name_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.set_display_name_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static set_display_name_async set_display_name_async (MemorySegment segment, MemorySession session) {
        return set_display_name_async.ofAddress(set_display_name_async$get(segment), session);
    }
    static final FunctionDescriptor set_display_name_finish$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle set_display_name_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.set_display_name_finish$FUNC
    );
    public interface set_display_name_finish {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(set_display_name_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(set_display_name_finish.class, fi, _GFileIface.set_display_name_finish$FUNC, session);
        }
        static set_display_name_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.set_display_name_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle set_display_name_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("set_display_name_finish"));
    public static VarHandle set_display_name_finish$VH() {
        return _GFileIface.set_display_name_finish$VH;
    }
    public static MemoryAddress set_display_name_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.set_display_name_finish$VH.get(seg);
    }
    public static void set_display_name_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.set_display_name_finish$VH.set(seg, x);
    }
    public static MemoryAddress set_display_name_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.set_display_name_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void set_display_name_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.set_display_name_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static set_display_name_finish set_display_name_finish (MemorySegment segment, MemorySession session) {
        return set_display_name_finish.ofAddress(set_display_name_finish$get(segment), session);
    }
    static final FunctionDescriptor query_settable_attributes$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle query_settable_attributes$MH = RuntimeHelper.downcallHandle(
        _GFileIface.query_settable_attributes$FUNC
    );
    public interface query_settable_attributes {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(query_settable_attributes fi, MemorySession session) {
            return RuntimeHelper.upcallStub(query_settable_attributes.class, fi, _GFileIface.query_settable_attributes$FUNC, session);
        }
        static query_settable_attributes ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.query_settable_attributes$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle query_settable_attributes$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("query_settable_attributes"));
    public static VarHandle query_settable_attributes$VH() {
        return _GFileIface.query_settable_attributes$VH;
    }
    public static MemoryAddress query_settable_attributes$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.query_settable_attributes$VH.get(seg);
    }
    public static void query_settable_attributes$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.query_settable_attributes$VH.set(seg, x);
    }
    public static MemoryAddress query_settable_attributes$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.query_settable_attributes$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void query_settable_attributes$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.query_settable_attributes$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static query_settable_attributes query_settable_attributes (MemorySegment segment, MemorySession session) {
        return query_settable_attributes.ofAddress(query_settable_attributes$get(segment), session);
    }
    static final FunctionDescriptor _query_settable_attributes_async$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _query_settable_attributes_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface._query_settable_attributes_async$FUNC
    );
    public interface _query_settable_attributes_async {

        void apply();
        static MemorySegment allocate(_query_settable_attributes_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_query_settable_attributes_async.class, fi, _GFileIface._query_settable_attributes_async$FUNC, session);
        }
        static _query_settable_attributes_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GFileIface._query_settable_attributes_async$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _query_settable_attributes_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_query_settable_attributes_async"));
    public static VarHandle _query_settable_attributes_async$VH() {
        return _GFileIface._query_settable_attributes_async$VH;
    }
    public static MemoryAddress _query_settable_attributes_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface._query_settable_attributes_async$VH.get(seg);
    }
    public static void _query_settable_attributes_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface._query_settable_attributes_async$VH.set(seg, x);
    }
    public static MemoryAddress _query_settable_attributes_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface._query_settable_attributes_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _query_settable_attributes_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface._query_settable_attributes_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _query_settable_attributes_async _query_settable_attributes_async (MemorySegment segment, MemorySession session) {
        return _query_settable_attributes_async.ofAddress(_query_settable_attributes_async$get(segment), session);
    }
    static final FunctionDescriptor _query_settable_attributes_finish$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _query_settable_attributes_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface._query_settable_attributes_finish$FUNC
    );
    public interface _query_settable_attributes_finish {

        void apply();
        static MemorySegment allocate(_query_settable_attributes_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_query_settable_attributes_finish.class, fi, _GFileIface._query_settable_attributes_finish$FUNC, session);
        }
        static _query_settable_attributes_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GFileIface._query_settable_attributes_finish$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _query_settable_attributes_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_query_settable_attributes_finish"));
    public static VarHandle _query_settable_attributes_finish$VH() {
        return _GFileIface._query_settable_attributes_finish$VH;
    }
    public static MemoryAddress _query_settable_attributes_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface._query_settable_attributes_finish$VH.get(seg);
    }
    public static void _query_settable_attributes_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface._query_settable_attributes_finish$VH.set(seg, x);
    }
    public static MemoryAddress _query_settable_attributes_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface._query_settable_attributes_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _query_settable_attributes_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface._query_settable_attributes_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _query_settable_attributes_finish _query_settable_attributes_finish (MemorySegment segment, MemorySession session) {
        return _query_settable_attributes_finish.ofAddress(_query_settable_attributes_finish$get(segment), session);
    }
    static final FunctionDescriptor query_writable_namespaces$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle query_writable_namespaces$MH = RuntimeHelper.downcallHandle(
        _GFileIface.query_writable_namespaces$FUNC
    );
    public interface query_writable_namespaces {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(query_writable_namespaces fi, MemorySession session) {
            return RuntimeHelper.upcallStub(query_writable_namespaces.class, fi, _GFileIface.query_writable_namespaces$FUNC, session);
        }
        static query_writable_namespaces ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.query_writable_namespaces$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle query_writable_namespaces$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("query_writable_namespaces"));
    public static VarHandle query_writable_namespaces$VH() {
        return _GFileIface.query_writable_namespaces$VH;
    }
    public static MemoryAddress query_writable_namespaces$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.query_writable_namespaces$VH.get(seg);
    }
    public static void query_writable_namespaces$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.query_writable_namespaces$VH.set(seg, x);
    }
    public static MemoryAddress query_writable_namespaces$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.query_writable_namespaces$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void query_writable_namespaces$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.query_writable_namespaces$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static query_writable_namespaces query_writable_namespaces (MemorySegment segment, MemorySession session) {
        return query_writable_namespaces.ofAddress(query_writable_namespaces$get(segment), session);
    }
    static final FunctionDescriptor _query_writable_namespaces_async$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _query_writable_namespaces_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface._query_writable_namespaces_async$FUNC
    );
    public interface _query_writable_namespaces_async {

        void apply();
        static MemorySegment allocate(_query_writable_namespaces_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_query_writable_namespaces_async.class, fi, _GFileIface._query_writable_namespaces_async$FUNC, session);
        }
        static _query_writable_namespaces_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GFileIface._query_writable_namespaces_async$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _query_writable_namespaces_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_query_writable_namespaces_async"));
    public static VarHandle _query_writable_namespaces_async$VH() {
        return _GFileIface._query_writable_namespaces_async$VH;
    }
    public static MemoryAddress _query_writable_namespaces_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface._query_writable_namespaces_async$VH.get(seg);
    }
    public static void _query_writable_namespaces_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface._query_writable_namespaces_async$VH.set(seg, x);
    }
    public static MemoryAddress _query_writable_namespaces_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface._query_writable_namespaces_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _query_writable_namespaces_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface._query_writable_namespaces_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _query_writable_namespaces_async _query_writable_namespaces_async (MemorySegment segment, MemorySession session) {
        return _query_writable_namespaces_async.ofAddress(_query_writable_namespaces_async$get(segment), session);
    }
    static final FunctionDescriptor _query_writable_namespaces_finish$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _query_writable_namespaces_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface._query_writable_namespaces_finish$FUNC
    );
    public interface _query_writable_namespaces_finish {

        void apply();
        static MemorySegment allocate(_query_writable_namespaces_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_query_writable_namespaces_finish.class, fi, _GFileIface._query_writable_namespaces_finish$FUNC, session);
        }
        static _query_writable_namespaces_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GFileIface._query_writable_namespaces_finish$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _query_writable_namespaces_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_query_writable_namespaces_finish"));
    public static VarHandle _query_writable_namespaces_finish$VH() {
        return _GFileIface._query_writable_namespaces_finish$VH;
    }
    public static MemoryAddress _query_writable_namespaces_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface._query_writable_namespaces_finish$VH.get(seg);
    }
    public static void _query_writable_namespaces_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface._query_writable_namespaces_finish$VH.set(seg, x);
    }
    public static MemoryAddress _query_writable_namespaces_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface._query_writable_namespaces_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _query_writable_namespaces_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface._query_writable_namespaces_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _query_writable_namespaces_finish _query_writable_namespaces_finish (MemorySegment segment, MemorySession session) {
        return _query_writable_namespaces_finish.ofAddress(_query_writable_namespaces_finish$get(segment), session);
    }
    static final FunctionDescriptor set_attribute$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle set_attribute$MH = RuntimeHelper.downcallHandle(
        _GFileIface.set_attribute$FUNC
    );
    public interface set_attribute {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, java.lang.foreign.MemoryAddress _x3, int _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6);
        static MemorySegment allocate(set_attribute fi, MemorySession session) {
            return RuntimeHelper.upcallStub(set_attribute.class, fi, _GFileIface.set_attribute$FUNC, session);
        }
        static set_attribute ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, java.lang.foreign.MemoryAddress __x3, int __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6) -> {
                try {
                    return (int)_GFileIface.set_attribute$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, (java.lang.foreign.Addressable)__x3, __x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle set_attribute$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("set_attribute"));
    public static VarHandle set_attribute$VH() {
        return _GFileIface.set_attribute$VH;
    }
    public static MemoryAddress set_attribute$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.set_attribute$VH.get(seg);
    }
    public static void set_attribute$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.set_attribute$VH.set(seg, x);
    }
    public static MemoryAddress set_attribute$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.set_attribute$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void set_attribute$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.set_attribute$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static set_attribute set_attribute (MemorySegment segment, MemorySession session) {
        return set_attribute.ofAddress(set_attribute$get(segment), session);
    }
    static final FunctionDescriptor set_attributes_from_info$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle set_attributes_from_info$MH = RuntimeHelper.downcallHandle(
        _GFileIface.set_attributes_from_info$FUNC
    );
    public interface set_attributes_from_info {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(set_attributes_from_info fi, MemorySession session) {
            return RuntimeHelper.upcallStub(set_attributes_from_info.class, fi, _GFileIface.set_attributes_from_info$FUNC, session);
        }
        static set_attributes_from_info ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (int)_GFileIface.set_attributes_from_info$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle set_attributes_from_info$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("set_attributes_from_info"));
    public static VarHandle set_attributes_from_info$VH() {
        return _GFileIface.set_attributes_from_info$VH;
    }
    public static MemoryAddress set_attributes_from_info$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.set_attributes_from_info$VH.get(seg);
    }
    public static void set_attributes_from_info$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.set_attributes_from_info$VH.set(seg, x);
    }
    public static MemoryAddress set_attributes_from_info$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.set_attributes_from_info$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void set_attributes_from_info$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.set_attributes_from_info$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static set_attributes_from_info set_attributes_from_info (MemorySegment segment, MemorySession session) {
        return set_attributes_from_info.ofAddress(set_attributes_from_info$get(segment), session);
    }
    static final FunctionDescriptor set_attributes_async$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle set_attributes_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface.set_attributes_async$FUNC
    );
    public interface set_attributes_async {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6);
        static MemorySegment allocate(set_attributes_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(set_attributes_async.class, fi, _GFileIface.set_attributes_async$FUNC, session);
        }
        static set_attributes_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6) -> {
                try {
                    _GFileIface.set_attributes_async$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle set_attributes_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("set_attributes_async"));
    public static VarHandle set_attributes_async$VH() {
        return _GFileIface.set_attributes_async$VH;
    }
    public static MemoryAddress set_attributes_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.set_attributes_async$VH.get(seg);
    }
    public static void set_attributes_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.set_attributes_async$VH.set(seg, x);
    }
    public static MemoryAddress set_attributes_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.set_attributes_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void set_attributes_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.set_attributes_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static set_attributes_async set_attributes_async (MemorySegment segment, MemorySession session) {
        return set_attributes_async.ofAddress(set_attributes_async$get(segment), session);
    }
    static final FunctionDescriptor set_attributes_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle set_attributes_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.set_attributes_finish$FUNC
    );
    public interface set_attributes_finish {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(set_attributes_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(set_attributes_finish.class, fi, _GFileIface.set_attributes_finish$FUNC, session);
        }
        static set_attributes_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (int)_GFileIface.set_attributes_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle set_attributes_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("set_attributes_finish"));
    public static VarHandle set_attributes_finish$VH() {
        return _GFileIface.set_attributes_finish$VH;
    }
    public static MemoryAddress set_attributes_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.set_attributes_finish$VH.get(seg);
    }
    public static void set_attributes_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.set_attributes_finish$VH.set(seg, x);
    }
    public static MemoryAddress set_attributes_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.set_attributes_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void set_attributes_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.set_attributes_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static set_attributes_finish set_attributes_finish (MemorySegment segment, MemorySession session) {
        return set_attributes_finish.ofAddress(set_attributes_finish$get(segment), session);
    }
    static final FunctionDescriptor read_fn$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle read_fn$MH = RuntimeHelper.downcallHandle(
        _GFileIface.read_fn$FUNC
    );
    public interface read_fn {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(read_fn fi, MemorySession session) {
            return RuntimeHelper.upcallStub(read_fn.class, fi, _GFileIface.read_fn$FUNC, session);
        }
        static read_fn ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.read_fn$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle read_fn$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("read_fn"));
    public static VarHandle read_fn$VH() {
        return _GFileIface.read_fn$VH;
    }
    public static MemoryAddress read_fn$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.read_fn$VH.get(seg);
    }
    public static void read_fn$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.read_fn$VH.set(seg, x);
    }
    public static MemoryAddress read_fn$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.read_fn$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void read_fn$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.read_fn$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static read_fn read_fn (MemorySegment segment, MemorySession session) {
        return read_fn.ofAddress(read_fn$get(segment), session);
    }
    static final FunctionDescriptor read_async$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle read_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface.read_async$FUNC
    );
    public interface read_async {

        void apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(read_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(read_async.class, fi, _GFileIface.read_async$FUNC, session);
        }
        static read_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    _GFileIface.read_async$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle read_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("read_async"));
    public static VarHandle read_async$VH() {
        return _GFileIface.read_async$VH;
    }
    public static MemoryAddress read_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.read_async$VH.get(seg);
    }
    public static void read_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.read_async$VH.set(seg, x);
    }
    public static MemoryAddress read_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.read_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void read_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.read_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static read_async read_async (MemorySegment segment, MemorySession session) {
        return read_async.ofAddress(read_async$get(segment), session);
    }
    static final FunctionDescriptor read_finish$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle read_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.read_finish$FUNC
    );
    public interface read_finish {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(read_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(read_finish.class, fi, _GFileIface.read_finish$FUNC, session);
        }
        static read_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.read_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle read_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("read_finish"));
    public static VarHandle read_finish$VH() {
        return _GFileIface.read_finish$VH;
    }
    public static MemoryAddress read_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.read_finish$VH.get(seg);
    }
    public static void read_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.read_finish$VH.set(seg, x);
    }
    public static MemoryAddress read_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.read_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void read_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.read_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static read_finish read_finish (MemorySegment segment, MemorySession session) {
        return read_finish.ofAddress(read_finish$get(segment), session);
    }
    static final FunctionDescriptor append_to$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle append_to$MH = RuntimeHelper.downcallHandle(
        _GFileIface.append_to$FUNC
    );
    public interface append_to {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(append_to fi, MemorySession session) {
            return RuntimeHelper.upcallStub(append_to.class, fi, _GFileIface.append_to$FUNC, session);
        }
        static append_to ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.append_to$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle append_to$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("append_to"));
    public static VarHandle append_to$VH() {
        return _GFileIface.append_to$VH;
    }
    public static MemoryAddress append_to$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.append_to$VH.get(seg);
    }
    public static void append_to$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.append_to$VH.set(seg, x);
    }
    public static MemoryAddress append_to$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.append_to$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void append_to$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.append_to$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static append_to append_to (MemorySegment segment, MemorySession session) {
        return append_to.ofAddress(append_to$get(segment), session);
    }
    static final FunctionDescriptor append_to_async$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle append_to_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface.append_to_async$FUNC
    );
    public interface append_to_async {

        void apply(java.lang.foreign.MemoryAddress _x0, int _x1, int _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(append_to_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(append_to_async.class, fi, _GFileIface.append_to_async$FUNC, session);
        }
        static append_to_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, int __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    _GFileIface.append_to_async$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle append_to_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("append_to_async"));
    public static VarHandle append_to_async$VH() {
        return _GFileIface.append_to_async$VH;
    }
    public static MemoryAddress append_to_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.append_to_async$VH.get(seg);
    }
    public static void append_to_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.append_to_async$VH.set(seg, x);
    }
    public static MemoryAddress append_to_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.append_to_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void append_to_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.append_to_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static append_to_async append_to_async (MemorySegment segment, MemorySession session) {
        return append_to_async.ofAddress(append_to_async$get(segment), session);
    }
    static final FunctionDescriptor append_to_finish$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle append_to_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.append_to_finish$FUNC
    );
    public interface append_to_finish {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(append_to_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(append_to_finish.class, fi, _GFileIface.append_to_finish$FUNC, session);
        }
        static append_to_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.append_to_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle append_to_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("append_to_finish"));
    public static VarHandle append_to_finish$VH() {
        return _GFileIface.append_to_finish$VH;
    }
    public static MemoryAddress append_to_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.append_to_finish$VH.get(seg);
    }
    public static void append_to_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.append_to_finish$VH.set(seg, x);
    }
    public static MemoryAddress append_to_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.append_to_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void append_to_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.append_to_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static append_to_finish append_to_finish (MemorySegment segment, MemorySession session) {
        return append_to_finish.ofAddress(append_to_finish$get(segment), session);
    }
    static final FunctionDescriptor create$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle create$MH = RuntimeHelper.downcallHandle(
        _GFileIface.create$FUNC
    );
    public interface create {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(create fi, MemorySession session) {
            return RuntimeHelper.upcallStub(create.class, fi, _GFileIface.create$FUNC, session);
        }
        static create ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.create$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle create$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("create"));
    public static VarHandle create$VH() {
        return _GFileIface.create$VH;
    }
    public static MemoryAddress create$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.create$VH.get(seg);
    }
    public static void create$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.create$VH.set(seg, x);
    }
    public static MemoryAddress create$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.create$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void create$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.create$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static create create (MemorySegment segment, MemorySession session) {
        return create.ofAddress(create$get(segment), session);
    }
    static final FunctionDescriptor create_async$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle create_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface.create_async$FUNC
    );
    public interface create_async {

        void apply(java.lang.foreign.MemoryAddress _x0, int _x1, int _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(create_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(create_async.class, fi, _GFileIface.create_async$FUNC, session);
        }
        static create_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, int __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    _GFileIface.create_async$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle create_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("create_async"));
    public static VarHandle create_async$VH() {
        return _GFileIface.create_async$VH;
    }
    public static MemoryAddress create_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.create_async$VH.get(seg);
    }
    public static void create_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.create_async$VH.set(seg, x);
    }
    public static MemoryAddress create_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.create_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void create_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.create_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static create_async create_async (MemorySegment segment, MemorySession session) {
        return create_async.ofAddress(create_async$get(segment), session);
    }
    static final FunctionDescriptor create_finish$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle create_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.create_finish$FUNC
    );
    public interface create_finish {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(create_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(create_finish.class, fi, _GFileIface.create_finish$FUNC, session);
        }
        static create_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.create_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle create_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("create_finish"));
    public static VarHandle create_finish$VH() {
        return _GFileIface.create_finish$VH;
    }
    public static MemoryAddress create_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.create_finish$VH.get(seg);
    }
    public static void create_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.create_finish$VH.set(seg, x);
    }
    public static MemoryAddress create_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.create_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void create_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.create_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static create_finish create_finish (MemorySegment segment, MemorySession session) {
        return create_finish.ofAddress(create_finish$get(segment), session);
    }
    static final FunctionDescriptor replace$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle replace$MH = RuntimeHelper.downcallHandle(
        _GFileIface.replace$FUNC
    );
    public interface replace {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(replace fi, MemorySession session) {
            return RuntimeHelper.upcallStub(replace.class, fi, _GFileIface.replace$FUNC, session);
        }
        static replace ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.replace$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle replace$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("replace"));
    public static VarHandle replace$VH() {
        return _GFileIface.replace$VH;
    }
    public static MemoryAddress replace$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.replace$VH.get(seg);
    }
    public static void replace$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.replace$VH.set(seg, x);
    }
    public static MemoryAddress replace$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.replace$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void replace$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.replace$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static replace replace (MemorySegment segment, MemorySession session) {
        return replace.ofAddress(replace$get(segment), session);
    }
    static final FunctionDescriptor replace_async$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle replace_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface.replace_async$FUNC
    );
    public interface replace_async {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, int _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6, java.lang.foreign.MemoryAddress _x7);
        static MemorySegment allocate(replace_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(replace_async.class, fi, _GFileIface.replace_async$FUNC, session);
        }
        static replace_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, int __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6, java.lang.foreign.MemoryAddress __x7) -> {
                try {
                    _GFileIface.replace_async$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, __x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6, (java.lang.foreign.Addressable)__x7);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle replace_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("replace_async"));
    public static VarHandle replace_async$VH() {
        return _GFileIface.replace_async$VH;
    }
    public static MemoryAddress replace_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.replace_async$VH.get(seg);
    }
    public static void replace_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.replace_async$VH.set(seg, x);
    }
    public static MemoryAddress replace_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.replace_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void replace_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.replace_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static replace_async replace_async (MemorySegment segment, MemorySession session) {
        return replace_async.ofAddress(replace_async$get(segment), session);
    }
    static final FunctionDescriptor replace_finish$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle replace_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.replace_finish$FUNC
    );
    public interface replace_finish {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(replace_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(replace_finish.class, fi, _GFileIface.replace_finish$FUNC, session);
        }
        static replace_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.replace_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle replace_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("replace_finish"));
    public static VarHandle replace_finish$VH() {
        return _GFileIface.replace_finish$VH;
    }
    public static MemoryAddress replace_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.replace_finish$VH.get(seg);
    }
    public static void replace_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.replace_finish$VH.set(seg, x);
    }
    public static MemoryAddress replace_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.replace_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void replace_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.replace_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static replace_finish replace_finish (MemorySegment segment, MemorySession session) {
        return replace_finish.ofAddress(replace_finish$get(segment), session);
    }
    static final FunctionDescriptor delete_file$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle delete_file$MH = RuntimeHelper.downcallHandle(
        _GFileIface.delete_file$FUNC
    );
    public interface delete_file {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(delete_file fi, MemorySession session) {
            return RuntimeHelper.upcallStub(delete_file.class, fi, _GFileIface.delete_file$FUNC, session);
        }
        static delete_file ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GFileIface.delete_file$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle delete_file$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("delete_file"));
    public static VarHandle delete_file$VH() {
        return _GFileIface.delete_file$VH;
    }
    public static MemoryAddress delete_file$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.delete_file$VH.get(seg);
    }
    public static void delete_file$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.delete_file$VH.set(seg, x);
    }
    public static MemoryAddress delete_file$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.delete_file$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void delete_file$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.delete_file$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static delete_file delete_file (MemorySegment segment, MemorySession session) {
        return delete_file.ofAddress(delete_file$get(segment), session);
    }
    static final FunctionDescriptor delete_file_async$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle delete_file_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface.delete_file_async$FUNC
    );
    public interface delete_file_async {

        void apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(delete_file_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(delete_file_async.class, fi, _GFileIface.delete_file_async$FUNC, session);
        }
        static delete_file_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    _GFileIface.delete_file_async$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle delete_file_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("delete_file_async"));
    public static VarHandle delete_file_async$VH() {
        return _GFileIface.delete_file_async$VH;
    }
    public static MemoryAddress delete_file_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.delete_file_async$VH.get(seg);
    }
    public static void delete_file_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.delete_file_async$VH.set(seg, x);
    }
    public static MemoryAddress delete_file_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.delete_file_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void delete_file_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.delete_file_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static delete_file_async delete_file_async (MemorySegment segment, MemorySession session) {
        return delete_file_async.ofAddress(delete_file_async$get(segment), session);
    }
    static final FunctionDescriptor delete_file_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle delete_file_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.delete_file_finish$FUNC
    );
    public interface delete_file_finish {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(delete_file_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(delete_file_finish.class, fi, _GFileIface.delete_file_finish$FUNC, session);
        }
        static delete_file_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GFileIface.delete_file_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle delete_file_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("delete_file_finish"));
    public static VarHandle delete_file_finish$VH() {
        return _GFileIface.delete_file_finish$VH;
    }
    public static MemoryAddress delete_file_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.delete_file_finish$VH.get(seg);
    }
    public static void delete_file_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.delete_file_finish$VH.set(seg, x);
    }
    public static MemoryAddress delete_file_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.delete_file_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void delete_file_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.delete_file_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static delete_file_finish delete_file_finish (MemorySegment segment, MemorySession session) {
        return delete_file_finish.ofAddress(delete_file_finish$get(segment), session);
    }
    static final FunctionDescriptor trash$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle trash$MH = RuntimeHelper.downcallHandle(
        _GFileIface.trash$FUNC
    );
    public interface trash {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(trash fi, MemorySession session) {
            return RuntimeHelper.upcallStub(trash.class, fi, _GFileIface.trash$FUNC, session);
        }
        static trash ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GFileIface.trash$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle trash$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("trash"));
    public static VarHandle trash$VH() {
        return _GFileIface.trash$VH;
    }
    public static MemoryAddress trash$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.trash$VH.get(seg);
    }
    public static void trash$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.trash$VH.set(seg, x);
    }
    public static MemoryAddress trash$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.trash$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void trash$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.trash$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static trash trash (MemorySegment segment, MemorySession session) {
        return trash.ofAddress(trash$get(segment), session);
    }
    static final FunctionDescriptor trash_async$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle trash_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface.trash_async$FUNC
    );
    public interface trash_async {

        void apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(trash_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(trash_async.class, fi, _GFileIface.trash_async$FUNC, session);
        }
        static trash_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    _GFileIface.trash_async$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle trash_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("trash_async"));
    public static VarHandle trash_async$VH() {
        return _GFileIface.trash_async$VH;
    }
    public static MemoryAddress trash_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.trash_async$VH.get(seg);
    }
    public static void trash_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.trash_async$VH.set(seg, x);
    }
    public static MemoryAddress trash_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.trash_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void trash_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.trash_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static trash_async trash_async (MemorySegment segment, MemorySession session) {
        return trash_async.ofAddress(trash_async$get(segment), session);
    }
    static final FunctionDescriptor trash_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle trash_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.trash_finish$FUNC
    );
    public interface trash_finish {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(trash_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(trash_finish.class, fi, _GFileIface.trash_finish$FUNC, session);
        }
        static trash_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GFileIface.trash_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle trash_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("trash_finish"));
    public static VarHandle trash_finish$VH() {
        return _GFileIface.trash_finish$VH;
    }
    public static MemoryAddress trash_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.trash_finish$VH.get(seg);
    }
    public static void trash_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.trash_finish$VH.set(seg, x);
    }
    public static MemoryAddress trash_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.trash_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void trash_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.trash_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static trash_finish trash_finish (MemorySegment segment, MemorySession session) {
        return trash_finish.ofAddress(trash_finish$get(segment), session);
    }
    static final FunctionDescriptor make_directory$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle make_directory$MH = RuntimeHelper.downcallHandle(
        _GFileIface.make_directory$FUNC
    );
    public interface make_directory {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(make_directory fi, MemorySession session) {
            return RuntimeHelper.upcallStub(make_directory.class, fi, _GFileIface.make_directory$FUNC, session);
        }
        static make_directory ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GFileIface.make_directory$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle make_directory$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("make_directory"));
    public static VarHandle make_directory$VH() {
        return _GFileIface.make_directory$VH;
    }
    public static MemoryAddress make_directory$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.make_directory$VH.get(seg);
    }
    public static void make_directory$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.make_directory$VH.set(seg, x);
    }
    public static MemoryAddress make_directory$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.make_directory$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void make_directory$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.make_directory$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static make_directory make_directory (MemorySegment segment, MemorySession session) {
        return make_directory.ofAddress(make_directory$get(segment), session);
    }
    static final FunctionDescriptor make_directory_async$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle make_directory_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface.make_directory_async$FUNC
    );
    public interface make_directory_async {

        void apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(make_directory_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(make_directory_async.class, fi, _GFileIface.make_directory_async$FUNC, session);
        }
        static make_directory_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    _GFileIface.make_directory_async$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle make_directory_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("make_directory_async"));
    public static VarHandle make_directory_async$VH() {
        return _GFileIface.make_directory_async$VH;
    }
    public static MemoryAddress make_directory_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.make_directory_async$VH.get(seg);
    }
    public static void make_directory_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.make_directory_async$VH.set(seg, x);
    }
    public static MemoryAddress make_directory_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.make_directory_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void make_directory_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.make_directory_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static make_directory_async make_directory_async (MemorySegment segment, MemorySession session) {
        return make_directory_async.ofAddress(make_directory_async$get(segment), session);
    }
    static final FunctionDescriptor make_directory_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle make_directory_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.make_directory_finish$FUNC
    );
    public interface make_directory_finish {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(make_directory_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(make_directory_finish.class, fi, _GFileIface.make_directory_finish$FUNC, session);
        }
        static make_directory_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GFileIface.make_directory_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle make_directory_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("make_directory_finish"));
    public static VarHandle make_directory_finish$VH() {
        return _GFileIface.make_directory_finish$VH;
    }
    public static MemoryAddress make_directory_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.make_directory_finish$VH.get(seg);
    }
    public static void make_directory_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.make_directory_finish$VH.set(seg, x);
    }
    public static MemoryAddress make_directory_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.make_directory_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void make_directory_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.make_directory_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static make_directory_finish make_directory_finish (MemorySegment segment, MemorySession session) {
        return make_directory_finish.ofAddress(make_directory_finish$get(segment), session);
    }
    static final FunctionDescriptor make_symbolic_link$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle make_symbolic_link$MH = RuntimeHelper.downcallHandle(
        _GFileIface.make_symbolic_link$FUNC
    );
    public interface make_symbolic_link {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(make_symbolic_link fi, MemorySession session) {
            return RuntimeHelper.upcallStub(make_symbolic_link.class, fi, _GFileIface.make_symbolic_link$FUNC, session);
        }
        static make_symbolic_link ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (int)_GFileIface.make_symbolic_link$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle make_symbolic_link$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("make_symbolic_link"));
    public static VarHandle make_symbolic_link$VH() {
        return _GFileIface.make_symbolic_link$VH;
    }
    public static MemoryAddress make_symbolic_link$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.make_symbolic_link$VH.get(seg);
    }
    public static void make_symbolic_link$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.make_symbolic_link$VH.set(seg, x);
    }
    public static MemoryAddress make_symbolic_link$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.make_symbolic_link$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void make_symbolic_link$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.make_symbolic_link$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static make_symbolic_link make_symbolic_link (MemorySegment segment, MemorySession session) {
        return make_symbolic_link.ofAddress(make_symbolic_link$get(segment), session);
    }
    static final FunctionDescriptor _make_symbolic_link_async$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _make_symbolic_link_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface._make_symbolic_link_async$FUNC
    );
    public interface _make_symbolic_link_async {

        void apply();
        static MemorySegment allocate(_make_symbolic_link_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_make_symbolic_link_async.class, fi, _GFileIface._make_symbolic_link_async$FUNC, session);
        }
        static _make_symbolic_link_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GFileIface._make_symbolic_link_async$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _make_symbolic_link_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_make_symbolic_link_async"));
    public static VarHandle _make_symbolic_link_async$VH() {
        return _GFileIface._make_symbolic_link_async$VH;
    }
    public static MemoryAddress _make_symbolic_link_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface._make_symbolic_link_async$VH.get(seg);
    }
    public static void _make_symbolic_link_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface._make_symbolic_link_async$VH.set(seg, x);
    }
    public static MemoryAddress _make_symbolic_link_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface._make_symbolic_link_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _make_symbolic_link_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface._make_symbolic_link_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _make_symbolic_link_async _make_symbolic_link_async (MemorySegment segment, MemorySession session) {
        return _make_symbolic_link_async.ofAddress(_make_symbolic_link_async$get(segment), session);
    }
    static final FunctionDescriptor _make_symbolic_link_finish$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _make_symbolic_link_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface._make_symbolic_link_finish$FUNC
    );
    public interface _make_symbolic_link_finish {

        void apply();
        static MemorySegment allocate(_make_symbolic_link_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_make_symbolic_link_finish.class, fi, _GFileIface._make_symbolic_link_finish$FUNC, session);
        }
        static _make_symbolic_link_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GFileIface._make_symbolic_link_finish$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _make_symbolic_link_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_make_symbolic_link_finish"));
    public static VarHandle _make_symbolic_link_finish$VH() {
        return _GFileIface._make_symbolic_link_finish$VH;
    }
    public static MemoryAddress _make_symbolic_link_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface._make_symbolic_link_finish$VH.get(seg);
    }
    public static void _make_symbolic_link_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface._make_symbolic_link_finish$VH.set(seg, x);
    }
    public static MemoryAddress _make_symbolic_link_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface._make_symbolic_link_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _make_symbolic_link_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface._make_symbolic_link_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _make_symbolic_link_finish _make_symbolic_link_finish (MemorySegment segment, MemorySession session) {
        return _make_symbolic_link_finish.ofAddress(_make_symbolic_link_finish$get(segment), session);
    }
    static final FunctionDescriptor copy$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle copy$MH = RuntimeHelper.downcallHandle(
        _GFileIface.copy$FUNC
    );
    public interface copy {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6);
        static MemorySegment allocate(copy fi, MemorySession session) {
            return RuntimeHelper.upcallStub(copy.class, fi, _GFileIface.copy$FUNC, session);
        }
        static copy ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6) -> {
                try {
                    return (int)_GFileIface.copy$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle copy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("copy"));
    public static VarHandle copy$VH() {
        return _GFileIface.copy$VH;
    }
    public static MemoryAddress copy$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.copy$VH.get(seg);
    }
    public static void copy$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.copy$VH.set(seg, x);
    }
    public static MemoryAddress copy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.copy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void copy$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.copy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static copy copy (MemorySegment segment, MemorySession session) {
        return copy.ofAddress(copy$get(segment), session);
    }
    static final FunctionDescriptor copy_async$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle copy_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface.copy_async$FUNC
    );
    public interface copy_async {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6, java.lang.foreign.MemoryAddress _x7, java.lang.foreign.MemoryAddress _x8);
        static MemorySegment allocate(copy_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(copy_async.class, fi, _GFileIface.copy_async$FUNC, session);
        }
        static copy_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6, java.lang.foreign.MemoryAddress __x7, java.lang.foreign.MemoryAddress __x8) -> {
                try {
                    _GFileIface.copy_async$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6, (java.lang.foreign.Addressable)__x7, (java.lang.foreign.Addressable)__x8);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle copy_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("copy_async"));
    public static VarHandle copy_async$VH() {
        return _GFileIface.copy_async$VH;
    }
    public static MemoryAddress copy_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.copy_async$VH.get(seg);
    }
    public static void copy_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.copy_async$VH.set(seg, x);
    }
    public static MemoryAddress copy_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.copy_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void copy_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.copy_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static copy_async copy_async (MemorySegment segment, MemorySession session) {
        return copy_async.ofAddress(copy_async$get(segment), session);
    }
    static final FunctionDescriptor copy_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle copy_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.copy_finish$FUNC
    );
    public interface copy_finish {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(copy_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(copy_finish.class, fi, _GFileIface.copy_finish$FUNC, session);
        }
        static copy_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GFileIface.copy_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle copy_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("copy_finish"));
    public static VarHandle copy_finish$VH() {
        return _GFileIface.copy_finish$VH;
    }
    public static MemoryAddress copy_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.copy_finish$VH.get(seg);
    }
    public static void copy_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.copy_finish$VH.set(seg, x);
    }
    public static MemoryAddress copy_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.copy_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void copy_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.copy_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static copy_finish copy_finish (MemorySegment segment, MemorySession session) {
        return copy_finish.ofAddress(copy_finish$get(segment), session);
    }
    static final FunctionDescriptor move$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle move$MH = RuntimeHelper.downcallHandle(
        _GFileIface.move$FUNC
    );
    public interface move {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6);
        static MemorySegment allocate(move fi, MemorySession session) {
            return RuntimeHelper.upcallStub(move.class, fi, _GFileIface.move$FUNC, session);
        }
        static move ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6) -> {
                try {
                    return (int)_GFileIface.move$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle move$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("move"));
    public static VarHandle move$VH() {
        return _GFileIface.move$VH;
    }
    public static MemoryAddress move$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.move$VH.get(seg);
    }
    public static void move$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.move$VH.set(seg, x);
    }
    public static MemoryAddress move$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.move$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void move$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.move$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static move move (MemorySegment segment, MemorySession session) {
        return move.ofAddress(move$get(segment), session);
    }
    static final FunctionDescriptor move_async$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle move_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface.move_async$FUNC
    );
    public interface move_async {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6, java.lang.foreign.MemoryAddress _x7, java.lang.foreign.MemoryAddress _x8);
        static MemorySegment allocate(move_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(move_async.class, fi, _GFileIface.move_async$FUNC, session);
        }
        static move_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6, java.lang.foreign.MemoryAddress __x7, java.lang.foreign.MemoryAddress __x8) -> {
                try {
                    _GFileIface.move_async$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6, (java.lang.foreign.Addressable)__x7, (java.lang.foreign.Addressable)__x8);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle move_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("move_async"));
    public static VarHandle move_async$VH() {
        return _GFileIface.move_async$VH;
    }
    public static MemoryAddress move_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.move_async$VH.get(seg);
    }
    public static void move_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.move_async$VH.set(seg, x);
    }
    public static MemoryAddress move_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.move_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void move_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.move_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static move_async move_async (MemorySegment segment, MemorySession session) {
        return move_async.ofAddress(move_async$get(segment), session);
    }
    static final FunctionDescriptor move_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle move_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.move_finish$FUNC
    );
    public interface move_finish {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(move_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(move_finish.class, fi, _GFileIface.move_finish$FUNC, session);
        }
        static move_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GFileIface.move_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle move_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("move_finish"));
    public static VarHandle move_finish$VH() {
        return _GFileIface.move_finish$VH;
    }
    public static MemoryAddress move_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.move_finish$VH.get(seg);
    }
    public static void move_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.move_finish$VH.set(seg, x);
    }
    public static MemoryAddress move_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.move_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void move_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.move_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static move_finish move_finish (MemorySegment segment, MemorySession session) {
        return move_finish.ofAddress(move_finish$get(segment), session);
    }
    static final FunctionDescriptor mount_mountable$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle mount_mountable$MH = RuntimeHelper.downcallHandle(
        _GFileIface.mount_mountable$FUNC
    );
    public interface mount_mountable {

        void apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(mount_mountable fi, MemorySession session) {
            return RuntimeHelper.upcallStub(mount_mountable.class, fi, _GFileIface.mount_mountable$FUNC, session);
        }
        static mount_mountable ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    _GFileIface.mount_mountable$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle mount_mountable$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("mount_mountable"));
    public static VarHandle mount_mountable$VH() {
        return _GFileIface.mount_mountable$VH;
    }
    public static MemoryAddress mount_mountable$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.mount_mountable$VH.get(seg);
    }
    public static void mount_mountable$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.mount_mountable$VH.set(seg, x);
    }
    public static MemoryAddress mount_mountable$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.mount_mountable$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void mount_mountable$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.mount_mountable$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static mount_mountable mount_mountable (MemorySegment segment, MemorySession session) {
        return mount_mountable.ofAddress(mount_mountable$get(segment), session);
    }
    static final FunctionDescriptor mount_mountable_finish$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle mount_mountable_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.mount_mountable_finish$FUNC
    );
    public interface mount_mountable_finish {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(mount_mountable_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(mount_mountable_finish.class, fi, _GFileIface.mount_mountable_finish$FUNC, session);
        }
        static mount_mountable_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.mount_mountable_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle mount_mountable_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("mount_mountable_finish"));
    public static VarHandle mount_mountable_finish$VH() {
        return _GFileIface.mount_mountable_finish$VH;
    }
    public static MemoryAddress mount_mountable_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.mount_mountable_finish$VH.get(seg);
    }
    public static void mount_mountable_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.mount_mountable_finish$VH.set(seg, x);
    }
    public static MemoryAddress mount_mountable_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.mount_mountable_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void mount_mountable_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.mount_mountable_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static mount_mountable_finish mount_mountable_finish (MemorySegment segment, MemorySession session) {
        return mount_mountable_finish.ofAddress(mount_mountable_finish$get(segment), session);
    }
    static final FunctionDescriptor unmount_mountable$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle unmount_mountable$MH = RuntimeHelper.downcallHandle(
        _GFileIface.unmount_mountable$FUNC
    );
    public interface unmount_mountable {

        void apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(unmount_mountable fi, MemorySession session) {
            return RuntimeHelper.upcallStub(unmount_mountable.class, fi, _GFileIface.unmount_mountable$FUNC, session);
        }
        static unmount_mountable ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    _GFileIface.unmount_mountable$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle unmount_mountable$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("unmount_mountable"));
    public static VarHandle unmount_mountable$VH() {
        return _GFileIface.unmount_mountable$VH;
    }
    public static MemoryAddress unmount_mountable$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.unmount_mountable$VH.get(seg);
    }
    public static void unmount_mountable$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.unmount_mountable$VH.set(seg, x);
    }
    public static MemoryAddress unmount_mountable$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.unmount_mountable$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void unmount_mountable$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.unmount_mountable$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static unmount_mountable unmount_mountable (MemorySegment segment, MemorySession session) {
        return unmount_mountable.ofAddress(unmount_mountable$get(segment), session);
    }
    static final FunctionDescriptor unmount_mountable_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle unmount_mountable_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.unmount_mountable_finish$FUNC
    );
    public interface unmount_mountable_finish {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(unmount_mountable_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(unmount_mountable_finish.class, fi, _GFileIface.unmount_mountable_finish$FUNC, session);
        }
        static unmount_mountable_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GFileIface.unmount_mountable_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle unmount_mountable_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("unmount_mountable_finish"));
    public static VarHandle unmount_mountable_finish$VH() {
        return _GFileIface.unmount_mountable_finish$VH;
    }
    public static MemoryAddress unmount_mountable_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.unmount_mountable_finish$VH.get(seg);
    }
    public static void unmount_mountable_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.unmount_mountable_finish$VH.set(seg, x);
    }
    public static MemoryAddress unmount_mountable_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.unmount_mountable_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void unmount_mountable_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.unmount_mountable_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static unmount_mountable_finish unmount_mountable_finish (MemorySegment segment, MemorySession session) {
        return unmount_mountable_finish.ofAddress(unmount_mountable_finish$get(segment), session);
    }
    static final FunctionDescriptor eject_mountable$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle eject_mountable$MH = RuntimeHelper.downcallHandle(
        _GFileIface.eject_mountable$FUNC
    );
    public interface eject_mountable {

        void apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(eject_mountable fi, MemorySession session) {
            return RuntimeHelper.upcallStub(eject_mountable.class, fi, _GFileIface.eject_mountable$FUNC, session);
        }
        static eject_mountable ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    _GFileIface.eject_mountable$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle eject_mountable$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("eject_mountable"));
    public static VarHandle eject_mountable$VH() {
        return _GFileIface.eject_mountable$VH;
    }
    public static MemoryAddress eject_mountable$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.eject_mountable$VH.get(seg);
    }
    public static void eject_mountable$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.eject_mountable$VH.set(seg, x);
    }
    public static MemoryAddress eject_mountable$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.eject_mountable$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void eject_mountable$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.eject_mountable$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static eject_mountable eject_mountable (MemorySegment segment, MemorySession session) {
        return eject_mountable.ofAddress(eject_mountable$get(segment), session);
    }
    static final FunctionDescriptor eject_mountable_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle eject_mountable_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.eject_mountable_finish$FUNC
    );
    public interface eject_mountable_finish {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(eject_mountable_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(eject_mountable_finish.class, fi, _GFileIface.eject_mountable_finish$FUNC, session);
        }
        static eject_mountable_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GFileIface.eject_mountable_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle eject_mountable_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("eject_mountable_finish"));
    public static VarHandle eject_mountable_finish$VH() {
        return _GFileIface.eject_mountable_finish$VH;
    }
    public static MemoryAddress eject_mountable_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.eject_mountable_finish$VH.get(seg);
    }
    public static void eject_mountable_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.eject_mountable_finish$VH.set(seg, x);
    }
    public static MemoryAddress eject_mountable_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.eject_mountable_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void eject_mountable_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.eject_mountable_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static eject_mountable_finish eject_mountable_finish (MemorySegment segment, MemorySession session) {
        return eject_mountable_finish.ofAddress(eject_mountable_finish$get(segment), session);
    }
    static final FunctionDescriptor mount_enclosing_volume$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle mount_enclosing_volume$MH = RuntimeHelper.downcallHandle(
        _GFileIface.mount_enclosing_volume$FUNC
    );
    public interface mount_enclosing_volume {

        void apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(mount_enclosing_volume fi, MemorySession session) {
            return RuntimeHelper.upcallStub(mount_enclosing_volume.class, fi, _GFileIface.mount_enclosing_volume$FUNC, session);
        }
        static mount_enclosing_volume ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    _GFileIface.mount_enclosing_volume$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle mount_enclosing_volume$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("mount_enclosing_volume"));
    public static VarHandle mount_enclosing_volume$VH() {
        return _GFileIface.mount_enclosing_volume$VH;
    }
    public static MemoryAddress mount_enclosing_volume$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.mount_enclosing_volume$VH.get(seg);
    }
    public static void mount_enclosing_volume$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.mount_enclosing_volume$VH.set(seg, x);
    }
    public static MemoryAddress mount_enclosing_volume$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.mount_enclosing_volume$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void mount_enclosing_volume$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.mount_enclosing_volume$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static mount_enclosing_volume mount_enclosing_volume (MemorySegment segment, MemorySession session) {
        return mount_enclosing_volume.ofAddress(mount_enclosing_volume$get(segment), session);
    }
    static final FunctionDescriptor mount_enclosing_volume_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle mount_enclosing_volume_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.mount_enclosing_volume_finish$FUNC
    );
    public interface mount_enclosing_volume_finish {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(mount_enclosing_volume_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(mount_enclosing_volume_finish.class, fi, _GFileIface.mount_enclosing_volume_finish$FUNC, session);
        }
        static mount_enclosing_volume_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GFileIface.mount_enclosing_volume_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle mount_enclosing_volume_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("mount_enclosing_volume_finish"));
    public static VarHandle mount_enclosing_volume_finish$VH() {
        return _GFileIface.mount_enclosing_volume_finish$VH;
    }
    public static MemoryAddress mount_enclosing_volume_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.mount_enclosing_volume_finish$VH.get(seg);
    }
    public static void mount_enclosing_volume_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.mount_enclosing_volume_finish$VH.set(seg, x);
    }
    public static MemoryAddress mount_enclosing_volume_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.mount_enclosing_volume_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void mount_enclosing_volume_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.mount_enclosing_volume_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static mount_enclosing_volume_finish mount_enclosing_volume_finish (MemorySegment segment, MemorySession session) {
        return mount_enclosing_volume_finish.ofAddress(mount_enclosing_volume_finish$get(segment), session);
    }
    static final FunctionDescriptor monitor_dir$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle monitor_dir$MH = RuntimeHelper.downcallHandle(
        _GFileIface.monitor_dir$FUNC
    );
    public interface monitor_dir {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(monitor_dir fi, MemorySession session) {
            return RuntimeHelper.upcallStub(monitor_dir.class, fi, _GFileIface.monitor_dir$FUNC, session);
        }
        static monitor_dir ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.monitor_dir$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle monitor_dir$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("monitor_dir"));
    public static VarHandle monitor_dir$VH() {
        return _GFileIface.monitor_dir$VH;
    }
    public static MemoryAddress monitor_dir$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.monitor_dir$VH.get(seg);
    }
    public static void monitor_dir$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.monitor_dir$VH.set(seg, x);
    }
    public static MemoryAddress monitor_dir$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.monitor_dir$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void monitor_dir$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.monitor_dir$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static monitor_dir monitor_dir (MemorySegment segment, MemorySession session) {
        return monitor_dir.ofAddress(monitor_dir$get(segment), session);
    }
    static final FunctionDescriptor monitor_file$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle monitor_file$MH = RuntimeHelper.downcallHandle(
        _GFileIface.monitor_file$FUNC
    );
    public interface monitor_file {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(monitor_file fi, MemorySession session) {
            return RuntimeHelper.upcallStub(monitor_file.class, fi, _GFileIface.monitor_file$FUNC, session);
        }
        static monitor_file ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.monitor_file$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle monitor_file$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("monitor_file"));
    public static VarHandle monitor_file$VH() {
        return _GFileIface.monitor_file$VH;
    }
    public static MemoryAddress monitor_file$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.monitor_file$VH.get(seg);
    }
    public static void monitor_file$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.monitor_file$VH.set(seg, x);
    }
    public static MemoryAddress monitor_file$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.monitor_file$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void monitor_file$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.monitor_file$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static monitor_file monitor_file (MemorySegment segment, MemorySession session) {
        return monitor_file.ofAddress(monitor_file$get(segment), session);
    }
    static final FunctionDescriptor open_readwrite$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle open_readwrite$MH = RuntimeHelper.downcallHandle(
        _GFileIface.open_readwrite$FUNC
    );
    public interface open_readwrite {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(open_readwrite fi, MemorySession session) {
            return RuntimeHelper.upcallStub(open_readwrite.class, fi, _GFileIface.open_readwrite$FUNC, session);
        }
        static open_readwrite ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.open_readwrite$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle open_readwrite$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("open_readwrite"));
    public static VarHandle open_readwrite$VH() {
        return _GFileIface.open_readwrite$VH;
    }
    public static MemoryAddress open_readwrite$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.open_readwrite$VH.get(seg);
    }
    public static void open_readwrite$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.open_readwrite$VH.set(seg, x);
    }
    public static MemoryAddress open_readwrite$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.open_readwrite$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void open_readwrite$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.open_readwrite$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static open_readwrite open_readwrite (MemorySegment segment, MemorySession session) {
        return open_readwrite.ofAddress(open_readwrite$get(segment), session);
    }
    static final FunctionDescriptor open_readwrite_async$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle open_readwrite_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface.open_readwrite_async$FUNC
    );
    public interface open_readwrite_async {

        void apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(open_readwrite_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(open_readwrite_async.class, fi, _GFileIface.open_readwrite_async$FUNC, session);
        }
        static open_readwrite_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    _GFileIface.open_readwrite_async$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle open_readwrite_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("open_readwrite_async"));
    public static VarHandle open_readwrite_async$VH() {
        return _GFileIface.open_readwrite_async$VH;
    }
    public static MemoryAddress open_readwrite_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.open_readwrite_async$VH.get(seg);
    }
    public static void open_readwrite_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.open_readwrite_async$VH.set(seg, x);
    }
    public static MemoryAddress open_readwrite_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.open_readwrite_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void open_readwrite_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.open_readwrite_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static open_readwrite_async open_readwrite_async (MemorySegment segment, MemorySession session) {
        return open_readwrite_async.ofAddress(open_readwrite_async$get(segment), session);
    }
    static final FunctionDescriptor open_readwrite_finish$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle open_readwrite_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.open_readwrite_finish$FUNC
    );
    public interface open_readwrite_finish {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(open_readwrite_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(open_readwrite_finish.class, fi, _GFileIface.open_readwrite_finish$FUNC, session);
        }
        static open_readwrite_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.open_readwrite_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle open_readwrite_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("open_readwrite_finish"));
    public static VarHandle open_readwrite_finish$VH() {
        return _GFileIface.open_readwrite_finish$VH;
    }
    public static MemoryAddress open_readwrite_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.open_readwrite_finish$VH.get(seg);
    }
    public static void open_readwrite_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.open_readwrite_finish$VH.set(seg, x);
    }
    public static MemoryAddress open_readwrite_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.open_readwrite_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void open_readwrite_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.open_readwrite_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static open_readwrite_finish open_readwrite_finish (MemorySegment segment, MemorySession session) {
        return open_readwrite_finish.ofAddress(open_readwrite_finish$get(segment), session);
    }
    static final FunctionDescriptor create_readwrite$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle create_readwrite$MH = RuntimeHelper.downcallHandle(
        _GFileIface.create_readwrite$FUNC
    );
    public interface create_readwrite {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(create_readwrite fi, MemorySession session) {
            return RuntimeHelper.upcallStub(create_readwrite.class, fi, _GFileIface.create_readwrite$FUNC, session);
        }
        static create_readwrite ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.create_readwrite$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle create_readwrite$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("create_readwrite"));
    public static VarHandle create_readwrite$VH() {
        return _GFileIface.create_readwrite$VH;
    }
    public static MemoryAddress create_readwrite$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.create_readwrite$VH.get(seg);
    }
    public static void create_readwrite$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.create_readwrite$VH.set(seg, x);
    }
    public static MemoryAddress create_readwrite$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.create_readwrite$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void create_readwrite$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.create_readwrite$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static create_readwrite create_readwrite (MemorySegment segment, MemorySession session) {
        return create_readwrite.ofAddress(create_readwrite$get(segment), session);
    }
    static final FunctionDescriptor create_readwrite_async$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle create_readwrite_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface.create_readwrite_async$FUNC
    );
    public interface create_readwrite_async {

        void apply(java.lang.foreign.MemoryAddress _x0, int _x1, int _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(create_readwrite_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(create_readwrite_async.class, fi, _GFileIface.create_readwrite_async$FUNC, session);
        }
        static create_readwrite_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, int __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    _GFileIface.create_readwrite_async$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle create_readwrite_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("create_readwrite_async"));
    public static VarHandle create_readwrite_async$VH() {
        return _GFileIface.create_readwrite_async$VH;
    }
    public static MemoryAddress create_readwrite_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.create_readwrite_async$VH.get(seg);
    }
    public static void create_readwrite_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.create_readwrite_async$VH.set(seg, x);
    }
    public static MemoryAddress create_readwrite_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.create_readwrite_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void create_readwrite_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.create_readwrite_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static create_readwrite_async create_readwrite_async (MemorySegment segment, MemorySession session) {
        return create_readwrite_async.ofAddress(create_readwrite_async$get(segment), session);
    }
    static final FunctionDescriptor create_readwrite_finish$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle create_readwrite_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.create_readwrite_finish$FUNC
    );
    public interface create_readwrite_finish {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(create_readwrite_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(create_readwrite_finish.class, fi, _GFileIface.create_readwrite_finish$FUNC, session);
        }
        static create_readwrite_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.create_readwrite_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle create_readwrite_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("create_readwrite_finish"));
    public static VarHandle create_readwrite_finish$VH() {
        return _GFileIface.create_readwrite_finish$VH;
    }
    public static MemoryAddress create_readwrite_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.create_readwrite_finish$VH.get(seg);
    }
    public static void create_readwrite_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.create_readwrite_finish$VH.set(seg, x);
    }
    public static MemoryAddress create_readwrite_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.create_readwrite_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void create_readwrite_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.create_readwrite_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static create_readwrite_finish create_readwrite_finish (MemorySegment segment, MemorySession session) {
        return create_readwrite_finish.ofAddress(create_readwrite_finish$get(segment), session);
    }
    static final FunctionDescriptor replace_readwrite$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle replace_readwrite$MH = RuntimeHelper.downcallHandle(
        _GFileIface.replace_readwrite$FUNC
    );
    public interface replace_readwrite {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(replace_readwrite fi, MemorySession session) {
            return RuntimeHelper.upcallStub(replace_readwrite.class, fi, _GFileIface.replace_readwrite$FUNC, session);
        }
        static replace_readwrite ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.replace_readwrite$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle replace_readwrite$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("replace_readwrite"));
    public static VarHandle replace_readwrite$VH() {
        return _GFileIface.replace_readwrite$VH;
    }
    public static MemoryAddress replace_readwrite$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.replace_readwrite$VH.get(seg);
    }
    public static void replace_readwrite$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.replace_readwrite$VH.set(seg, x);
    }
    public static MemoryAddress replace_readwrite$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.replace_readwrite$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void replace_readwrite$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.replace_readwrite$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static replace_readwrite replace_readwrite (MemorySegment segment, MemorySession session) {
        return replace_readwrite.ofAddress(replace_readwrite$get(segment), session);
    }
    static final FunctionDescriptor replace_readwrite_async$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle replace_readwrite_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface.replace_readwrite_async$FUNC
    );
    public interface replace_readwrite_async {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, int _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6, java.lang.foreign.MemoryAddress _x7);
        static MemorySegment allocate(replace_readwrite_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(replace_readwrite_async.class, fi, _GFileIface.replace_readwrite_async$FUNC, session);
        }
        static replace_readwrite_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, int __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6, java.lang.foreign.MemoryAddress __x7) -> {
                try {
                    _GFileIface.replace_readwrite_async$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, __x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6, (java.lang.foreign.Addressable)__x7);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle replace_readwrite_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("replace_readwrite_async"));
    public static VarHandle replace_readwrite_async$VH() {
        return _GFileIface.replace_readwrite_async$VH;
    }
    public static MemoryAddress replace_readwrite_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.replace_readwrite_async$VH.get(seg);
    }
    public static void replace_readwrite_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.replace_readwrite_async$VH.set(seg, x);
    }
    public static MemoryAddress replace_readwrite_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.replace_readwrite_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void replace_readwrite_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.replace_readwrite_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static replace_readwrite_async replace_readwrite_async (MemorySegment segment, MemorySession session) {
        return replace_readwrite_async.ofAddress(replace_readwrite_async$get(segment), session);
    }
    static final FunctionDescriptor replace_readwrite_finish$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle replace_readwrite_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.replace_readwrite_finish$FUNC
    );
    public interface replace_readwrite_finish {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(replace_readwrite_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(replace_readwrite_finish.class, fi, _GFileIface.replace_readwrite_finish$FUNC, session);
        }
        static replace_readwrite_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GFileIface.replace_readwrite_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle replace_readwrite_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("replace_readwrite_finish"));
    public static VarHandle replace_readwrite_finish$VH() {
        return _GFileIface.replace_readwrite_finish$VH;
    }
    public static MemoryAddress replace_readwrite_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.replace_readwrite_finish$VH.get(seg);
    }
    public static void replace_readwrite_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.replace_readwrite_finish$VH.set(seg, x);
    }
    public static MemoryAddress replace_readwrite_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.replace_readwrite_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void replace_readwrite_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.replace_readwrite_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static replace_readwrite_finish replace_readwrite_finish (MemorySegment segment, MemorySession session) {
        return replace_readwrite_finish.ofAddress(replace_readwrite_finish$get(segment), session);
    }
    static final FunctionDescriptor start_mountable$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle start_mountable$MH = RuntimeHelper.downcallHandle(
        _GFileIface.start_mountable$FUNC
    );
    public interface start_mountable {

        void apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(start_mountable fi, MemorySession session) {
            return RuntimeHelper.upcallStub(start_mountable.class, fi, _GFileIface.start_mountable$FUNC, session);
        }
        static start_mountable ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    _GFileIface.start_mountable$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle start_mountable$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("start_mountable"));
    public static VarHandle start_mountable$VH() {
        return _GFileIface.start_mountable$VH;
    }
    public static MemoryAddress start_mountable$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.start_mountable$VH.get(seg);
    }
    public static void start_mountable$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.start_mountable$VH.set(seg, x);
    }
    public static MemoryAddress start_mountable$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.start_mountable$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void start_mountable$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.start_mountable$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static start_mountable start_mountable (MemorySegment segment, MemorySession session) {
        return start_mountable.ofAddress(start_mountable$get(segment), session);
    }
    static final FunctionDescriptor start_mountable_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle start_mountable_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.start_mountable_finish$FUNC
    );
    public interface start_mountable_finish {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(start_mountable_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(start_mountable_finish.class, fi, _GFileIface.start_mountable_finish$FUNC, session);
        }
        static start_mountable_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GFileIface.start_mountable_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle start_mountable_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("start_mountable_finish"));
    public static VarHandle start_mountable_finish$VH() {
        return _GFileIface.start_mountable_finish$VH;
    }
    public static MemoryAddress start_mountable_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.start_mountable_finish$VH.get(seg);
    }
    public static void start_mountable_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.start_mountable_finish$VH.set(seg, x);
    }
    public static MemoryAddress start_mountable_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.start_mountable_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void start_mountable_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.start_mountable_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static start_mountable_finish start_mountable_finish (MemorySegment segment, MemorySession session) {
        return start_mountable_finish.ofAddress(start_mountable_finish$get(segment), session);
    }
    static final FunctionDescriptor stop_mountable$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle stop_mountable$MH = RuntimeHelper.downcallHandle(
        _GFileIface.stop_mountable$FUNC
    );
    public interface stop_mountable {

        void apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(stop_mountable fi, MemorySession session) {
            return RuntimeHelper.upcallStub(stop_mountable.class, fi, _GFileIface.stop_mountable$FUNC, session);
        }
        static stop_mountable ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    _GFileIface.stop_mountable$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle stop_mountable$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("stop_mountable"));
    public static VarHandle stop_mountable$VH() {
        return _GFileIface.stop_mountable$VH;
    }
    public static MemoryAddress stop_mountable$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.stop_mountable$VH.get(seg);
    }
    public static void stop_mountable$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.stop_mountable$VH.set(seg, x);
    }
    public static MemoryAddress stop_mountable$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.stop_mountable$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void stop_mountable$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.stop_mountable$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static stop_mountable stop_mountable (MemorySegment segment, MemorySession session) {
        return stop_mountable.ofAddress(stop_mountable$get(segment), session);
    }
    static final FunctionDescriptor stop_mountable_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle stop_mountable_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.stop_mountable_finish$FUNC
    );
    public interface stop_mountable_finish {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(stop_mountable_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(stop_mountable_finish.class, fi, _GFileIface.stop_mountable_finish$FUNC, session);
        }
        static stop_mountable_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GFileIface.stop_mountable_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle stop_mountable_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("stop_mountable_finish"));
    public static VarHandle stop_mountable_finish$VH() {
        return _GFileIface.stop_mountable_finish$VH;
    }
    public static MemoryAddress stop_mountable_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.stop_mountable_finish$VH.get(seg);
    }
    public static void stop_mountable_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.stop_mountable_finish$VH.set(seg, x);
    }
    public static MemoryAddress stop_mountable_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.stop_mountable_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void stop_mountable_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.stop_mountable_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static stop_mountable_finish stop_mountable_finish (MemorySegment segment, MemorySession session) {
        return stop_mountable_finish.ofAddress(stop_mountable_finish$get(segment), session);
    }
    static final VarHandle supports_thread_contexts$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("supports_thread_contexts"));
    public static VarHandle supports_thread_contexts$VH() {
        return _GFileIface.supports_thread_contexts$VH;
    }
    public static int supports_thread_contexts$get(MemorySegment seg) {
        return (int)_GFileIface.supports_thread_contexts$VH.get(seg);
    }
    public static void supports_thread_contexts$set( MemorySegment seg, int x) {
        _GFileIface.supports_thread_contexts$VH.set(seg, x);
    }
    public static int supports_thread_contexts$get(MemorySegment seg, long index) {
        return (int)_GFileIface.supports_thread_contexts$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void supports_thread_contexts$set(MemorySegment seg, long index, int x) {
        _GFileIface.supports_thread_contexts$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor unmount_mountable_with_operation$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle unmount_mountable_with_operation$MH = RuntimeHelper.downcallHandle(
        _GFileIface.unmount_mountable_with_operation$FUNC
    );
    public interface unmount_mountable_with_operation {

        void apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(unmount_mountable_with_operation fi, MemorySession session) {
            return RuntimeHelper.upcallStub(unmount_mountable_with_operation.class, fi, _GFileIface.unmount_mountable_with_operation$FUNC, session);
        }
        static unmount_mountable_with_operation ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    _GFileIface.unmount_mountable_with_operation$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle unmount_mountable_with_operation$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("unmount_mountable_with_operation"));
    public static VarHandle unmount_mountable_with_operation$VH() {
        return _GFileIface.unmount_mountable_with_operation$VH;
    }
    public static MemoryAddress unmount_mountable_with_operation$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.unmount_mountable_with_operation$VH.get(seg);
    }
    public static void unmount_mountable_with_operation$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.unmount_mountable_with_operation$VH.set(seg, x);
    }
    public static MemoryAddress unmount_mountable_with_operation$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.unmount_mountable_with_operation$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void unmount_mountable_with_operation$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.unmount_mountable_with_operation$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static unmount_mountable_with_operation unmount_mountable_with_operation (MemorySegment segment, MemorySession session) {
        return unmount_mountable_with_operation.ofAddress(unmount_mountable_with_operation$get(segment), session);
    }
    static final FunctionDescriptor unmount_mountable_with_operation_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle unmount_mountable_with_operation_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.unmount_mountable_with_operation_finish$FUNC
    );
    public interface unmount_mountable_with_operation_finish {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(unmount_mountable_with_operation_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(unmount_mountable_with_operation_finish.class, fi, _GFileIface.unmount_mountable_with_operation_finish$FUNC, session);
        }
        static unmount_mountable_with_operation_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GFileIface.unmount_mountable_with_operation_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle unmount_mountable_with_operation_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("unmount_mountable_with_operation_finish"));
    public static VarHandle unmount_mountable_with_operation_finish$VH() {
        return _GFileIface.unmount_mountable_with_operation_finish$VH;
    }
    public static MemoryAddress unmount_mountable_with_operation_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.unmount_mountable_with_operation_finish$VH.get(seg);
    }
    public static void unmount_mountable_with_operation_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.unmount_mountable_with_operation_finish$VH.set(seg, x);
    }
    public static MemoryAddress unmount_mountable_with_operation_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.unmount_mountable_with_operation_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void unmount_mountable_with_operation_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.unmount_mountable_with_operation_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static unmount_mountable_with_operation_finish unmount_mountable_with_operation_finish (MemorySegment segment, MemorySession session) {
        return unmount_mountable_with_operation_finish.ofAddress(unmount_mountable_with_operation_finish$get(segment), session);
    }
    static final FunctionDescriptor eject_mountable_with_operation$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle eject_mountable_with_operation$MH = RuntimeHelper.downcallHandle(
        _GFileIface.eject_mountable_with_operation$FUNC
    );
    public interface eject_mountable_with_operation {

        void apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(eject_mountable_with_operation fi, MemorySession session) {
            return RuntimeHelper.upcallStub(eject_mountable_with_operation.class, fi, _GFileIface.eject_mountable_with_operation$FUNC, session);
        }
        static eject_mountable_with_operation ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    _GFileIface.eject_mountable_with_operation$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle eject_mountable_with_operation$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("eject_mountable_with_operation"));
    public static VarHandle eject_mountable_with_operation$VH() {
        return _GFileIface.eject_mountable_with_operation$VH;
    }
    public static MemoryAddress eject_mountable_with_operation$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.eject_mountable_with_operation$VH.get(seg);
    }
    public static void eject_mountable_with_operation$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.eject_mountable_with_operation$VH.set(seg, x);
    }
    public static MemoryAddress eject_mountable_with_operation$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.eject_mountable_with_operation$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void eject_mountable_with_operation$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.eject_mountable_with_operation$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static eject_mountable_with_operation eject_mountable_with_operation (MemorySegment segment, MemorySession session) {
        return eject_mountable_with_operation.ofAddress(eject_mountable_with_operation$get(segment), session);
    }
    static final FunctionDescriptor eject_mountable_with_operation_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle eject_mountable_with_operation_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.eject_mountable_with_operation_finish$FUNC
    );
    public interface eject_mountable_with_operation_finish {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(eject_mountable_with_operation_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(eject_mountable_with_operation_finish.class, fi, _GFileIface.eject_mountable_with_operation_finish$FUNC, session);
        }
        static eject_mountable_with_operation_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GFileIface.eject_mountable_with_operation_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle eject_mountable_with_operation_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("eject_mountable_with_operation_finish"));
    public static VarHandle eject_mountable_with_operation_finish$VH() {
        return _GFileIface.eject_mountable_with_operation_finish$VH;
    }
    public static MemoryAddress eject_mountable_with_operation_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.eject_mountable_with_operation_finish$VH.get(seg);
    }
    public static void eject_mountable_with_operation_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.eject_mountable_with_operation_finish$VH.set(seg, x);
    }
    public static MemoryAddress eject_mountable_with_operation_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.eject_mountable_with_operation_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void eject_mountable_with_operation_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.eject_mountable_with_operation_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static eject_mountable_with_operation_finish eject_mountable_with_operation_finish (MemorySegment segment, MemorySession session) {
        return eject_mountable_with_operation_finish.ofAddress(eject_mountable_with_operation_finish$get(segment), session);
    }
    static final FunctionDescriptor poll_mountable$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle poll_mountable$MH = RuntimeHelper.downcallHandle(
        _GFileIface.poll_mountable$FUNC
    );
    public interface poll_mountable {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(poll_mountable fi, MemorySession session) {
            return RuntimeHelper.upcallStub(poll_mountable.class, fi, _GFileIface.poll_mountable$FUNC, session);
        }
        static poll_mountable ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    _GFileIface.poll_mountable$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle poll_mountable$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("poll_mountable"));
    public static VarHandle poll_mountable$VH() {
        return _GFileIface.poll_mountable$VH;
    }
    public static MemoryAddress poll_mountable$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.poll_mountable$VH.get(seg);
    }
    public static void poll_mountable$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.poll_mountable$VH.set(seg, x);
    }
    public static MemoryAddress poll_mountable$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.poll_mountable$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void poll_mountable$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.poll_mountable$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static poll_mountable poll_mountable (MemorySegment segment, MemorySession session) {
        return poll_mountable.ofAddress(poll_mountable$get(segment), session);
    }
    static final FunctionDescriptor poll_mountable_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle poll_mountable_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.poll_mountable_finish$FUNC
    );
    public interface poll_mountable_finish {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(poll_mountable_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(poll_mountable_finish.class, fi, _GFileIface.poll_mountable_finish$FUNC, session);
        }
        static poll_mountable_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GFileIface.poll_mountable_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle poll_mountable_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("poll_mountable_finish"));
    public static VarHandle poll_mountable_finish$VH() {
        return _GFileIface.poll_mountable_finish$VH;
    }
    public static MemoryAddress poll_mountable_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.poll_mountable_finish$VH.get(seg);
    }
    public static void poll_mountable_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.poll_mountable_finish$VH.set(seg, x);
    }
    public static MemoryAddress poll_mountable_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.poll_mountable_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void poll_mountable_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.poll_mountable_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static poll_mountable_finish poll_mountable_finish (MemorySegment segment, MemorySession session) {
        return poll_mountable_finish.ofAddress(poll_mountable_finish$get(segment), session);
    }
    static final FunctionDescriptor measure_disk_usage$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle measure_disk_usage$MH = RuntimeHelper.downcallHandle(
        _GFileIface.measure_disk_usage$FUNC
    );
    public interface measure_disk_usage {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6, java.lang.foreign.MemoryAddress _x7, java.lang.foreign.MemoryAddress _x8);
        static MemorySegment allocate(measure_disk_usage fi, MemorySession session) {
            return RuntimeHelper.upcallStub(measure_disk_usage.class, fi, _GFileIface.measure_disk_usage$FUNC, session);
        }
        static measure_disk_usage ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6, java.lang.foreign.MemoryAddress __x7, java.lang.foreign.MemoryAddress __x8) -> {
                try {
                    return (int)_GFileIface.measure_disk_usage$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6, (java.lang.foreign.Addressable)__x7, (java.lang.foreign.Addressable)__x8);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle measure_disk_usage$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("measure_disk_usage"));
    public static VarHandle measure_disk_usage$VH() {
        return _GFileIface.measure_disk_usage$VH;
    }
    public static MemoryAddress measure_disk_usage$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.measure_disk_usage$VH.get(seg);
    }
    public static void measure_disk_usage$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.measure_disk_usage$VH.set(seg, x);
    }
    public static MemoryAddress measure_disk_usage$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.measure_disk_usage$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void measure_disk_usage$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.measure_disk_usage$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static measure_disk_usage measure_disk_usage (MemorySegment segment, MemorySession session) {
        return measure_disk_usage.ofAddress(measure_disk_usage$get(segment), session);
    }
    static final FunctionDescriptor measure_disk_usage_async$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle measure_disk_usage_async$MH = RuntimeHelper.downcallHandle(
        _GFileIface.measure_disk_usage_async$FUNC
    );
    public interface measure_disk_usage_async {

        void apply(java.lang.foreign.MemoryAddress _x0, int _x1, int _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6, java.lang.foreign.MemoryAddress _x7);
        static MemorySegment allocate(measure_disk_usage_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(measure_disk_usage_async.class, fi, _GFileIface.measure_disk_usage_async$FUNC, session);
        }
        static measure_disk_usage_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, int __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6, java.lang.foreign.MemoryAddress __x7) -> {
                try {
                    _GFileIface.measure_disk_usage_async$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6, (java.lang.foreign.Addressable)__x7);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle measure_disk_usage_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("measure_disk_usage_async"));
    public static VarHandle measure_disk_usage_async$VH() {
        return _GFileIface.measure_disk_usage_async$VH;
    }
    public static MemoryAddress measure_disk_usage_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.measure_disk_usage_async$VH.get(seg);
    }
    public static void measure_disk_usage_async$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.measure_disk_usage_async$VH.set(seg, x);
    }
    public static MemoryAddress measure_disk_usage_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.measure_disk_usage_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void measure_disk_usage_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.measure_disk_usage_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static measure_disk_usage_async measure_disk_usage_async (MemorySegment segment, MemorySession session) {
        return measure_disk_usage_async.ofAddress(measure_disk_usage_async$get(segment), session);
    }
    static final FunctionDescriptor measure_disk_usage_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle measure_disk_usage_finish$MH = RuntimeHelper.downcallHandle(
        _GFileIface.measure_disk_usage_finish$FUNC
    );
    public interface measure_disk_usage_finish {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(measure_disk_usage_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(measure_disk_usage_finish.class, fi, _GFileIface.measure_disk_usage_finish$FUNC, session);
        }
        static measure_disk_usage_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    return (int)_GFileIface.measure_disk_usage_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle measure_disk_usage_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("measure_disk_usage_finish"));
    public static VarHandle measure_disk_usage_finish$VH() {
        return _GFileIface.measure_disk_usage_finish$VH;
    }
    public static MemoryAddress measure_disk_usage_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.measure_disk_usage_finish$VH.get(seg);
    }
    public static void measure_disk_usage_finish$set( MemorySegment seg, MemoryAddress x) {
        _GFileIface.measure_disk_usage_finish$VH.set(seg, x);
    }
    public static MemoryAddress measure_disk_usage_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GFileIface.measure_disk_usage_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void measure_disk_usage_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GFileIface.measure_disk_usage_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static measure_disk_usage_finish measure_disk_usage_finish (MemorySegment segment, MemorySession session) {
        return measure_disk_usage_finish.ofAddress(measure_disk_usage_finish$get(segment), session);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }
}


