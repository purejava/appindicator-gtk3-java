// Generated by jextract

package org.purejava.linux;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
public class _GtkStyleClass {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        MemoryLayout.structLayout(
            MemoryLayout.structLayout(
                Constants$root.C_LONG_LONG$LAYOUT.withName("g_type")
            ).withName("g_type_class"),
            Constants$root.C_POINTER$LAYOUT.withName("construct_properties"),
            Constants$root.C_POINTER$LAYOUT.withName("constructor"),
            Constants$root.C_POINTER$LAYOUT.withName("set_property"),
            Constants$root.C_POINTER$LAYOUT.withName("get_property"),
            Constants$root.C_POINTER$LAYOUT.withName("dispose"),
            Constants$root.C_POINTER$LAYOUT.withName("finalize"),
            Constants$root.C_POINTER$LAYOUT.withName("dispatch_properties_changed"),
            Constants$root.C_POINTER$LAYOUT.withName("notify"),
            Constants$root.C_POINTER$LAYOUT.withName("constructed"),
            Constants$root.C_LONG_LONG$LAYOUT.withName("flags"),
            MemoryLayout.sequenceLayout(6, Constants$root.C_POINTER$LAYOUT).withName("pdummy")
        ).withName("parent_class"),
        Constants$root.C_POINTER$LAYOUT.withName("realize"),
        Constants$root.C_POINTER$LAYOUT.withName("unrealize"),
        Constants$root.C_POINTER$LAYOUT.withName("copy"),
        Constants$root.C_POINTER$LAYOUT.withName("clone"),
        Constants$root.C_POINTER$LAYOUT.withName("init_from_rc"),
        Constants$root.C_POINTER$LAYOUT.withName("set_background"),
        Constants$root.C_POINTER$LAYOUT.withName("render_icon"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_hline"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_vline"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_shadow"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_arrow"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_diamond"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_box"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_flat_box"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_check"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_option"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_tab"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_shadow_gap"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_box_gap"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_extension"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_focus"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_slider"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_handle"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_expander"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_layout"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_resize_grip"),
        Constants$root.C_POINTER$LAYOUT.withName("draw_spinner"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved1"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved2"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved3"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved4"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved5"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved6"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved7"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved8"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved9"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved10"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved11")
    ).withName("_GtkStyleClass");
    public static MemoryLayout $LAYOUT() {
        return _GtkStyleClass.$struct$LAYOUT;
    }
    public static MemorySegment parent_class$slice(MemorySegment seg) {
        return seg.asSlice(0, 136);
    }
    static final FunctionDescriptor realize$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle realize$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.realize$FUNC
    );
    public interface realize {

        void apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(realize fi, MemorySession session) {
            return RuntimeHelper.upcallStub(realize.class, fi, _GtkStyleClass.realize$FUNC, session);
        }
        static realize ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    _GtkStyleClass.realize$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle realize$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("realize"));
    public static VarHandle realize$VH() {
        return _GtkStyleClass.realize$VH;
    }
    public static MemoryAddress realize$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.realize$VH.get(seg);
    }
    public static void realize$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.realize$VH.set(seg, x);
    }
    public static MemoryAddress realize$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.realize$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void realize$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.realize$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static realize realize (MemorySegment segment, MemorySession session) {
        return realize.ofAddress(realize$get(segment), session);
    }
    static final FunctionDescriptor unrealize$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle unrealize$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.unrealize$FUNC
    );
    public interface unrealize {

        void apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(unrealize fi, MemorySession session) {
            return RuntimeHelper.upcallStub(unrealize.class, fi, _GtkStyleClass.unrealize$FUNC, session);
        }
        static unrealize ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    _GtkStyleClass.unrealize$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle unrealize$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("unrealize"));
    public static VarHandle unrealize$VH() {
        return _GtkStyleClass.unrealize$VH;
    }
    public static MemoryAddress unrealize$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.unrealize$VH.get(seg);
    }
    public static void unrealize$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.unrealize$VH.set(seg, x);
    }
    public static MemoryAddress unrealize$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.unrealize$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void unrealize$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.unrealize$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static unrealize unrealize (MemorySegment segment, MemorySession session) {
        return unrealize.ofAddress(unrealize$get(segment), session);
    }
    static final FunctionDescriptor copy$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle copy$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.copy$FUNC
    );
    public interface copy {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(copy fi, MemorySession session) {
            return RuntimeHelper.upcallStub(copy.class, fi, _GtkStyleClass.copy$FUNC, session);
        }
        static copy ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    _GtkStyleClass.copy$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle copy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("copy"));
    public static VarHandle copy$VH() {
        return _GtkStyleClass.copy$VH;
    }
    public static MemoryAddress copy$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.copy$VH.get(seg);
    }
    public static void copy$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.copy$VH.set(seg, x);
    }
    public static MemoryAddress copy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.copy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void copy$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.copy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static copy copy (MemorySegment segment, MemorySession session) {
        return copy.ofAddress(copy$get(segment), session);
    }
    static final FunctionDescriptor clone$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle clone$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.clone$FUNC
    );
    public interface clone {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(clone fi, MemorySession session) {
            return RuntimeHelper.upcallStub(clone.class, fi, _GtkStyleClass.clone$FUNC, session);
        }
        static clone ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GtkStyleClass.clone$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle clone$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("clone"));
    public static VarHandle clone$VH() {
        return _GtkStyleClass.clone$VH;
    }
    public static MemoryAddress clone$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.clone$VH.get(seg);
    }
    public static void clone$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.clone$VH.set(seg, x);
    }
    public static MemoryAddress clone$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.clone$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void clone$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.clone$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static clone clone (MemorySegment segment, MemorySession session) {
        return clone.ofAddress(clone$get(segment), session);
    }
    static final FunctionDescriptor init_from_rc$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle init_from_rc$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.init_from_rc$FUNC
    );
    public interface init_from_rc {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(init_from_rc fi, MemorySession session) {
            return RuntimeHelper.upcallStub(init_from_rc.class, fi, _GtkStyleClass.init_from_rc$FUNC, session);
        }
        static init_from_rc ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    _GtkStyleClass.init_from_rc$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle init_from_rc$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("init_from_rc"));
    public static VarHandle init_from_rc$VH() {
        return _GtkStyleClass.init_from_rc$VH;
    }
    public static MemoryAddress init_from_rc$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.init_from_rc$VH.get(seg);
    }
    public static void init_from_rc$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.init_from_rc$VH.set(seg, x);
    }
    public static MemoryAddress init_from_rc$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.init_from_rc$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void init_from_rc$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.init_from_rc$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static init_from_rc init_from_rc (MemorySegment segment, MemorySession session) {
        return init_from_rc.ofAddress(init_from_rc$get(segment), session);
    }
    static final FunctionDescriptor set_background$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle set_background$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.set_background$FUNC
    );
    public interface set_background {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2);
        static MemorySegment allocate(set_background fi, MemorySession session) {
            return RuntimeHelper.upcallStub(set_background.class, fi, _GtkStyleClass.set_background$FUNC, session);
        }
        static set_background ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2) -> {
                try {
                    _GtkStyleClass.set_background$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle set_background$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("set_background"));
    public static VarHandle set_background$VH() {
        return _GtkStyleClass.set_background$VH;
    }
    public static MemoryAddress set_background$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.set_background$VH.get(seg);
    }
    public static void set_background$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.set_background$VH.set(seg, x);
    }
    public static MemoryAddress set_background$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.set_background$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void set_background$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.set_background$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static set_background set_background (MemorySegment segment, MemorySession session) {
        return set_background.ofAddress(set_background$get(segment), session);
    }
    static final FunctionDescriptor render_icon$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle render_icon$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.render_icon$FUNC
    );
    public interface render_icon {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, int _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6);
        static MemorySegment allocate(render_icon fi, MemorySession session) {
            return RuntimeHelper.upcallStub(render_icon.class, fi, _GtkStyleClass.render_icon$FUNC, session);
        }
        static render_icon ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, int __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GtkStyleClass.render_icon$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, __x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle render_icon$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("render_icon"));
    public static VarHandle render_icon$VH() {
        return _GtkStyleClass.render_icon$VH;
    }
    public static MemoryAddress render_icon$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.render_icon$VH.get(seg);
    }
    public static void render_icon$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.render_icon$VH.set(seg, x);
    }
    public static MemoryAddress render_icon$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.render_icon$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void render_icon$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.render_icon$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static render_icon render_icon (MemorySegment segment, MemorySession session) {
        return render_icon.ofAddress(render_icon$get(segment), session);
    }
    static final FunctionDescriptor draw_hline$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_hline$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_hline$FUNC
    );
    public interface draw_hline {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, int _x5, int _x6, int _x7);
        static MemorySegment allocate(draw_hline fi, MemorySession session) {
            return RuntimeHelper.upcallStub(draw_hline.class, fi, _GtkStyleClass.draw_hline$FUNC, session);
        }
        static draw_hline ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, int __x5, int __x6, int __x7) -> {
                try {
                    _GtkStyleClass.draw_hline$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, __x5, __x6, __x7);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_hline$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_hline"));
    public static VarHandle draw_hline$VH() {
        return _GtkStyleClass.draw_hline$VH;
    }
    public static MemoryAddress draw_hline$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_hline$VH.get(seg);
    }
    public static void draw_hline$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_hline$VH.set(seg, x);
    }
    public static MemoryAddress draw_hline$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_hline$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_hline$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_hline$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_hline draw_hline (MemorySegment segment, MemorySession session) {
        return draw_hline.ofAddress(draw_hline$get(segment), session);
    }
    static final FunctionDescriptor draw_vline$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_vline$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_vline$FUNC
    );
    public interface draw_vline {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, int _x5, int _x6, int _x7);
        static MemorySegment allocate(draw_vline fi, MemorySession session) {
            return RuntimeHelper.upcallStub(draw_vline.class, fi, _GtkStyleClass.draw_vline$FUNC, session);
        }
        static draw_vline ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, int __x5, int __x6, int __x7) -> {
                try {
                    _GtkStyleClass.draw_vline$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, __x5, __x6, __x7);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_vline$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_vline"));
    public static VarHandle draw_vline$VH() {
        return _GtkStyleClass.draw_vline$VH;
    }
    public static MemoryAddress draw_vline$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_vline$VH.get(seg);
    }
    public static void draw_vline$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_vline$VH.set(seg, x);
    }
    public static MemoryAddress draw_vline$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_vline$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_vline$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_vline$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_vline draw_vline (MemorySegment segment, MemorySession session) {
        return draw_vline.ofAddress(draw_vline$get(segment), session);
    }
    static final FunctionDescriptor draw_shadow$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_shadow$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_shadow$FUNC
    );
    public interface draw_shadow {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9);
        static MemorySegment allocate(draw_shadow fi, MemorySession session) {
            return RuntimeHelper.upcallStub(draw_shadow.class, fi, _GtkStyleClass.draw_shadow$FUNC, session);
        }
        static draw_shadow ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, int __x6, int __x7, int __x8, int __x9) -> {
                try {
                    _GtkStyleClass.draw_shadow$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, __x6, __x7, __x8, __x9);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_shadow$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_shadow"));
    public static VarHandle draw_shadow$VH() {
        return _GtkStyleClass.draw_shadow$VH;
    }
    public static MemoryAddress draw_shadow$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_shadow$VH.get(seg);
    }
    public static void draw_shadow$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_shadow$VH.set(seg, x);
    }
    public static MemoryAddress draw_shadow$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_shadow$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_shadow$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_shadow$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_shadow draw_shadow (MemorySegment segment, MemorySession session) {
        return draw_shadow.ofAddress(draw_shadow$get(segment), session);
    }
    static final FunctionDescriptor draw_arrow$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_arrow$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_arrow$FUNC
    );
    public interface draw_arrow {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9, int _x10, int _x11);
        static MemorySegment allocate(draw_arrow fi, MemorySession session) {
            return RuntimeHelper.upcallStub(draw_arrow.class, fi, _GtkStyleClass.draw_arrow$FUNC, session);
        }
        static draw_arrow ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, int __x6, int __x7, int __x8, int __x9, int __x10, int __x11) -> {
                try {
                    _GtkStyleClass.draw_arrow$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, __x6, __x7, __x8, __x9, __x10, __x11);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_arrow$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_arrow"));
    public static VarHandle draw_arrow$VH() {
        return _GtkStyleClass.draw_arrow$VH;
    }
    public static MemoryAddress draw_arrow$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_arrow$VH.get(seg);
    }
    public static void draw_arrow$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_arrow$VH.set(seg, x);
    }
    public static MemoryAddress draw_arrow$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_arrow$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_arrow$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_arrow$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_arrow draw_arrow (MemorySegment segment, MemorySession session) {
        return draw_arrow.ofAddress(draw_arrow$get(segment), session);
    }
    static final FunctionDescriptor draw_diamond$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_diamond$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_diamond$FUNC
    );
    public interface draw_diamond {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9);
        static MemorySegment allocate(draw_diamond fi, MemorySession session) {
            return RuntimeHelper.upcallStub(draw_diamond.class, fi, _GtkStyleClass.draw_diamond$FUNC, session);
        }
        static draw_diamond ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, int __x6, int __x7, int __x8, int __x9) -> {
                try {
                    _GtkStyleClass.draw_diamond$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, __x6, __x7, __x8, __x9);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_diamond$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_diamond"));
    public static VarHandle draw_diamond$VH() {
        return _GtkStyleClass.draw_diamond$VH;
    }
    public static MemoryAddress draw_diamond$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_diamond$VH.get(seg);
    }
    public static void draw_diamond$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_diamond$VH.set(seg, x);
    }
    public static MemoryAddress draw_diamond$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_diamond$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_diamond$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_diamond$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_diamond draw_diamond (MemorySegment segment, MemorySession session) {
        return draw_diamond.ofAddress(draw_diamond$get(segment), session);
    }
    static final FunctionDescriptor draw_box$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_box$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_box$FUNC
    );
    public interface draw_box {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9);
        static MemorySegment allocate(draw_box fi, MemorySession session) {
            return RuntimeHelper.upcallStub(draw_box.class, fi, _GtkStyleClass.draw_box$FUNC, session);
        }
        static draw_box ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, int __x6, int __x7, int __x8, int __x9) -> {
                try {
                    _GtkStyleClass.draw_box$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, __x6, __x7, __x8, __x9);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_box$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_box"));
    public static VarHandle draw_box$VH() {
        return _GtkStyleClass.draw_box$VH;
    }
    public static MemoryAddress draw_box$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_box$VH.get(seg);
    }
    public static void draw_box$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_box$VH.set(seg, x);
    }
    public static MemoryAddress draw_box$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_box$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_box$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_box$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_box draw_box (MemorySegment segment, MemorySession session) {
        return draw_box.ofAddress(draw_box$get(segment), session);
    }
    static final FunctionDescriptor draw_flat_box$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_flat_box$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_flat_box$FUNC
    );
    public interface draw_flat_box {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9);
        static MemorySegment allocate(draw_flat_box fi, MemorySession session) {
            return RuntimeHelper.upcallStub(draw_flat_box.class, fi, _GtkStyleClass.draw_flat_box$FUNC, session);
        }
        static draw_flat_box ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, int __x6, int __x7, int __x8, int __x9) -> {
                try {
                    _GtkStyleClass.draw_flat_box$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, __x6, __x7, __x8, __x9);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_flat_box$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_flat_box"));
    public static VarHandle draw_flat_box$VH() {
        return _GtkStyleClass.draw_flat_box$VH;
    }
    public static MemoryAddress draw_flat_box$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_flat_box$VH.get(seg);
    }
    public static void draw_flat_box$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_flat_box$VH.set(seg, x);
    }
    public static MemoryAddress draw_flat_box$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_flat_box$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_flat_box$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_flat_box$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_flat_box draw_flat_box (MemorySegment segment, MemorySession session) {
        return draw_flat_box.ofAddress(draw_flat_box$get(segment), session);
    }
    static final FunctionDescriptor draw_check$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_check$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_check$FUNC
    );
    public interface draw_check {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9);
        static MemorySegment allocate(draw_check fi, MemorySession session) {
            return RuntimeHelper.upcallStub(draw_check.class, fi, _GtkStyleClass.draw_check$FUNC, session);
        }
        static draw_check ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, int __x6, int __x7, int __x8, int __x9) -> {
                try {
                    _GtkStyleClass.draw_check$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, __x6, __x7, __x8, __x9);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_check$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_check"));
    public static VarHandle draw_check$VH() {
        return _GtkStyleClass.draw_check$VH;
    }
    public static MemoryAddress draw_check$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_check$VH.get(seg);
    }
    public static void draw_check$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_check$VH.set(seg, x);
    }
    public static MemoryAddress draw_check$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_check$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_check$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_check$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_check draw_check (MemorySegment segment, MemorySession session) {
        return draw_check.ofAddress(draw_check$get(segment), session);
    }
    static final FunctionDescriptor draw_option$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_option$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_option$FUNC
    );
    public interface draw_option {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9);
        static MemorySegment allocate(draw_option fi, MemorySession session) {
            return RuntimeHelper.upcallStub(draw_option.class, fi, _GtkStyleClass.draw_option$FUNC, session);
        }
        static draw_option ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, int __x6, int __x7, int __x8, int __x9) -> {
                try {
                    _GtkStyleClass.draw_option$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, __x6, __x7, __x8, __x9);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_option$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_option"));
    public static VarHandle draw_option$VH() {
        return _GtkStyleClass.draw_option$VH;
    }
    public static MemoryAddress draw_option$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_option$VH.get(seg);
    }
    public static void draw_option$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_option$VH.set(seg, x);
    }
    public static MemoryAddress draw_option$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_option$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_option$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_option$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_option draw_option (MemorySegment segment, MemorySession session) {
        return draw_option.ofAddress(draw_option$get(segment), session);
    }
    static final FunctionDescriptor draw_tab$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_tab$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_tab$FUNC
    );
    public interface draw_tab {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9);
        static MemorySegment allocate(draw_tab fi, MemorySession session) {
            return RuntimeHelper.upcallStub(draw_tab.class, fi, _GtkStyleClass.draw_tab$FUNC, session);
        }
        static draw_tab ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, int __x6, int __x7, int __x8, int __x9) -> {
                try {
                    _GtkStyleClass.draw_tab$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, __x6, __x7, __x8, __x9);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_tab$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_tab"));
    public static VarHandle draw_tab$VH() {
        return _GtkStyleClass.draw_tab$VH;
    }
    public static MemoryAddress draw_tab$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_tab$VH.get(seg);
    }
    public static void draw_tab$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_tab$VH.set(seg, x);
    }
    public static MemoryAddress draw_tab$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_tab$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_tab$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_tab$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_tab draw_tab (MemorySegment segment, MemorySession session) {
        return draw_tab.ofAddress(draw_tab$get(segment), session);
    }
    static final FunctionDescriptor draw_shadow_gap$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_shadow_gap$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_shadow_gap$FUNC
    );
    public interface draw_shadow_gap {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9, int _x10, int _x11, int _x12);
        static MemorySegment allocate(draw_shadow_gap fi, MemorySession session) {
            return RuntimeHelper.upcallStub(draw_shadow_gap.class, fi, _GtkStyleClass.draw_shadow_gap$FUNC, session);
        }
        static draw_shadow_gap ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, int __x6, int __x7, int __x8, int __x9, int __x10, int __x11, int __x12) -> {
                try {
                    _GtkStyleClass.draw_shadow_gap$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, __x6, __x7, __x8, __x9, __x10, __x11, __x12);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_shadow_gap$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_shadow_gap"));
    public static VarHandle draw_shadow_gap$VH() {
        return _GtkStyleClass.draw_shadow_gap$VH;
    }
    public static MemoryAddress draw_shadow_gap$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_shadow_gap$VH.get(seg);
    }
    public static void draw_shadow_gap$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_shadow_gap$VH.set(seg, x);
    }
    public static MemoryAddress draw_shadow_gap$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_shadow_gap$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_shadow_gap$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_shadow_gap$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_shadow_gap draw_shadow_gap (MemorySegment segment, MemorySession session) {
        return draw_shadow_gap.ofAddress(draw_shadow_gap$get(segment), session);
    }
    static final FunctionDescriptor draw_box_gap$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_box_gap$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_box_gap$FUNC
    );
    public interface draw_box_gap {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9, int _x10, int _x11, int _x12);
        static MemorySegment allocate(draw_box_gap fi, MemorySession session) {
            return RuntimeHelper.upcallStub(draw_box_gap.class, fi, _GtkStyleClass.draw_box_gap$FUNC, session);
        }
        static draw_box_gap ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, int __x6, int __x7, int __x8, int __x9, int __x10, int __x11, int __x12) -> {
                try {
                    _GtkStyleClass.draw_box_gap$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, __x6, __x7, __x8, __x9, __x10, __x11, __x12);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_box_gap$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_box_gap"));
    public static VarHandle draw_box_gap$VH() {
        return _GtkStyleClass.draw_box_gap$VH;
    }
    public static MemoryAddress draw_box_gap$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_box_gap$VH.get(seg);
    }
    public static void draw_box_gap$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_box_gap$VH.set(seg, x);
    }
    public static MemoryAddress draw_box_gap$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_box_gap$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_box_gap$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_box_gap$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_box_gap draw_box_gap (MemorySegment segment, MemorySession session) {
        return draw_box_gap.ofAddress(draw_box_gap$get(segment), session);
    }
    static final FunctionDescriptor draw_extension$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_extension$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_extension$FUNC
    );
    public interface draw_extension {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9, int _x10);
        static MemorySegment allocate(draw_extension fi, MemorySession session) {
            return RuntimeHelper.upcallStub(draw_extension.class, fi, _GtkStyleClass.draw_extension$FUNC, session);
        }
        static draw_extension ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, int __x6, int __x7, int __x8, int __x9, int __x10) -> {
                try {
                    _GtkStyleClass.draw_extension$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, __x6, __x7, __x8, __x9, __x10);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_extension$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_extension"));
    public static VarHandle draw_extension$VH() {
        return _GtkStyleClass.draw_extension$VH;
    }
    public static MemoryAddress draw_extension$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_extension$VH.get(seg);
    }
    public static void draw_extension$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_extension$VH.set(seg, x);
    }
    public static MemoryAddress draw_extension$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_extension$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_extension$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_extension$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_extension draw_extension (MemorySegment segment, MemorySession session) {
        return draw_extension.ofAddress(draw_extension$get(segment), session);
    }
    static final FunctionDescriptor draw_focus$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_focus$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_focus$FUNC
    );
    public interface draw_focus {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, int _x5, int _x6, int _x7, int _x8);
        static MemorySegment allocate(draw_focus fi, MemorySession session) {
            return RuntimeHelper.upcallStub(draw_focus.class, fi, _GtkStyleClass.draw_focus$FUNC, session);
        }
        static draw_focus ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, int __x5, int __x6, int __x7, int __x8) -> {
                try {
                    _GtkStyleClass.draw_focus$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, __x5, __x6, __x7, __x8);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_focus$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_focus"));
    public static VarHandle draw_focus$VH() {
        return _GtkStyleClass.draw_focus$VH;
    }
    public static MemoryAddress draw_focus$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_focus$VH.get(seg);
    }
    public static void draw_focus$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_focus$VH.set(seg, x);
    }
    public static MemoryAddress draw_focus$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_focus$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_focus$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_focus$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_focus draw_focus (MemorySegment segment, MemorySession session) {
        return draw_focus.ofAddress(draw_focus$get(segment), session);
    }
    static final FunctionDescriptor draw_slider$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_slider$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_slider$FUNC
    );
    public interface draw_slider {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9, int _x10);
        static MemorySegment allocate(draw_slider fi, MemorySession session) {
            return RuntimeHelper.upcallStub(draw_slider.class, fi, _GtkStyleClass.draw_slider$FUNC, session);
        }
        static draw_slider ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, int __x6, int __x7, int __x8, int __x9, int __x10) -> {
                try {
                    _GtkStyleClass.draw_slider$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, __x6, __x7, __x8, __x9, __x10);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_slider$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_slider"));
    public static VarHandle draw_slider$VH() {
        return _GtkStyleClass.draw_slider$VH;
    }
    public static MemoryAddress draw_slider$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_slider$VH.get(seg);
    }
    public static void draw_slider$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_slider$VH.set(seg, x);
    }
    public static MemoryAddress draw_slider$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_slider$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_slider$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_slider$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_slider draw_slider (MemorySegment segment, MemorySession session) {
        return draw_slider.ofAddress(draw_slider$get(segment), session);
    }
    static final FunctionDescriptor draw_handle$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_handle$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_handle$FUNC
    );
    public interface draw_handle {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, int _x6, int _x7, int _x8, int _x9, int _x10);
        static MemorySegment allocate(draw_handle fi, MemorySession session) {
            return RuntimeHelper.upcallStub(draw_handle.class, fi, _GtkStyleClass.draw_handle$FUNC, session);
        }
        static draw_handle ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, int __x6, int __x7, int __x8, int __x9, int __x10) -> {
                try {
                    _GtkStyleClass.draw_handle$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, __x6, __x7, __x8, __x9, __x10);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_handle$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_handle"));
    public static VarHandle draw_handle$VH() {
        return _GtkStyleClass.draw_handle$VH;
    }
    public static MemoryAddress draw_handle$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_handle$VH.get(seg);
    }
    public static void draw_handle$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_handle$VH.set(seg, x);
    }
    public static MemoryAddress draw_handle$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_handle$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_handle$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_handle$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_handle draw_handle (MemorySegment segment, MemorySession session) {
        return draw_handle.ofAddress(draw_handle$get(segment), session);
    }
    static final FunctionDescriptor draw_expander$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_expander$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_expander$FUNC
    );
    public interface draw_expander {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, int _x5, int _x6, int _x7);
        static MemorySegment allocate(draw_expander fi, MemorySession session) {
            return RuntimeHelper.upcallStub(draw_expander.class, fi, _GtkStyleClass.draw_expander$FUNC, session);
        }
        static draw_expander ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, int __x5, int __x6, int __x7) -> {
                try {
                    _GtkStyleClass.draw_expander$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, __x5, __x6, __x7);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_expander$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_expander"));
    public static VarHandle draw_expander$VH() {
        return _GtkStyleClass.draw_expander$VH;
    }
    public static MemoryAddress draw_expander$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_expander$VH.get(seg);
    }
    public static void draw_expander$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_expander$VH.set(seg, x);
    }
    public static MemoryAddress draw_expander$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_expander$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_expander$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_expander$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_expander draw_expander (MemorySegment segment, MemorySession session) {
        return draw_expander.ofAddress(draw_expander$get(segment), session);
    }
    static final FunctionDescriptor draw_layout$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle draw_layout$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_layout$FUNC
    );
    public interface draw_layout {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, int _x6, int _x7, java.lang.foreign.MemoryAddress _x8);
        static MemorySegment allocate(draw_layout fi, MemorySession session) {
            return RuntimeHelper.upcallStub(draw_layout.class, fi, _GtkStyleClass.draw_layout$FUNC, session);
        }
        static draw_layout ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, int __x6, int __x7, java.lang.foreign.MemoryAddress __x8) -> {
                try {
                    _GtkStyleClass.draw_layout$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, __x6, __x7, (java.lang.foreign.Addressable)__x8);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_layout$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_layout"));
    public static VarHandle draw_layout$VH() {
        return _GtkStyleClass.draw_layout$VH;
    }
    public static MemoryAddress draw_layout$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_layout$VH.get(seg);
    }
    public static void draw_layout$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_layout$VH.set(seg, x);
    }
    public static MemoryAddress draw_layout$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_layout$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_layout$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_layout$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_layout draw_layout (MemorySegment segment, MemorySession session) {
        return draw_layout.ofAddress(draw_layout$get(segment), session);
    }
    static final FunctionDescriptor draw_resize_grip$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_resize_grip$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_resize_grip$FUNC
    );
    public interface draw_resize_grip {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, int _x5, int _x6, int _x7, int _x8, int _x9);
        static MemorySegment allocate(draw_resize_grip fi, MemorySession session) {
            return RuntimeHelper.upcallStub(draw_resize_grip.class, fi, _GtkStyleClass.draw_resize_grip$FUNC, session);
        }
        static draw_resize_grip ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, int __x5, int __x6, int __x7, int __x8, int __x9) -> {
                try {
                    _GtkStyleClass.draw_resize_grip$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, __x5, __x6, __x7, __x8, __x9);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_resize_grip$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_resize_grip"));
    public static VarHandle draw_resize_grip$VH() {
        return _GtkStyleClass.draw_resize_grip$VH;
    }
    public static MemoryAddress draw_resize_grip$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_resize_grip$VH.get(seg);
    }
    public static void draw_resize_grip$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_resize_grip$VH.set(seg, x);
    }
    public static MemoryAddress draw_resize_grip$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_resize_grip$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_resize_grip$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_resize_grip$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_resize_grip draw_resize_grip (MemorySegment segment, MemorySession session) {
        return draw_resize_grip.ofAddress(draw_resize_grip$get(segment), session);
    }
    static final FunctionDescriptor draw_spinner$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle draw_spinner$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass.draw_spinner$FUNC
    );
    public interface draw_spinner {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, int _x5, int _x6, int _x7, int _x8, int _x9);
        static MemorySegment allocate(draw_spinner fi, MemorySession session) {
            return RuntimeHelper.upcallStub(draw_spinner.class, fi, _GtkStyleClass.draw_spinner$FUNC, session);
        }
        static draw_spinner ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, int __x5, int __x6, int __x7, int __x8, int __x9) -> {
                try {
                    _GtkStyleClass.draw_spinner$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, __x5, __x6, __x7, __x8, __x9);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle draw_spinner$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("draw_spinner"));
    public static VarHandle draw_spinner$VH() {
        return _GtkStyleClass.draw_spinner$VH;
    }
    public static MemoryAddress draw_spinner$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_spinner$VH.get(seg);
    }
    public static void draw_spinner$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass.draw_spinner$VH.set(seg, x);
    }
    public static MemoryAddress draw_spinner$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass.draw_spinner$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void draw_spinner$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass.draw_spinner$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static draw_spinner draw_spinner (MemorySegment segment, MemorySession session) {
        return draw_spinner.ofAddress(draw_spinner$get(segment), session);
    }
    static final FunctionDescriptor _gtk_reserved1$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved1$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved1$FUNC
    );
    public interface _gtk_reserved1 {

        void apply();
        static MemorySegment allocate(_gtk_reserved1 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_gtk_reserved1.class, fi, _GtkStyleClass._gtk_reserved1$FUNC, session);
        }
        static _gtk_reserved1 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GtkStyleClass._gtk_reserved1$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved1$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved1"));
    public static VarHandle _gtk_reserved1$VH() {
        return _GtkStyleClass._gtk_reserved1$VH;
    }
    public static MemoryAddress _gtk_reserved1$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved1$VH.get(seg);
    }
    public static void _gtk_reserved1$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved1$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved1$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved1$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved1$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved1$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved1 _gtk_reserved1 (MemorySegment segment, MemorySession session) {
        return _gtk_reserved1.ofAddress(_gtk_reserved1$get(segment), session);
    }
    static final FunctionDescriptor _gtk_reserved2$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved2$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved2$FUNC
    );
    public interface _gtk_reserved2 {

        void apply();
        static MemorySegment allocate(_gtk_reserved2 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_gtk_reserved2.class, fi, _GtkStyleClass._gtk_reserved2$FUNC, session);
        }
        static _gtk_reserved2 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GtkStyleClass._gtk_reserved2$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved2$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved2"));
    public static VarHandle _gtk_reserved2$VH() {
        return _GtkStyleClass._gtk_reserved2$VH;
    }
    public static MemoryAddress _gtk_reserved2$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved2$VH.get(seg);
    }
    public static void _gtk_reserved2$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved2$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved2$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved2$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved2$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved2$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved2 _gtk_reserved2 (MemorySegment segment, MemorySession session) {
        return _gtk_reserved2.ofAddress(_gtk_reserved2$get(segment), session);
    }
    static final FunctionDescriptor _gtk_reserved3$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved3$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved3$FUNC
    );
    public interface _gtk_reserved3 {

        void apply();
        static MemorySegment allocate(_gtk_reserved3 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_gtk_reserved3.class, fi, _GtkStyleClass._gtk_reserved3$FUNC, session);
        }
        static _gtk_reserved3 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GtkStyleClass._gtk_reserved3$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved3$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved3"));
    public static VarHandle _gtk_reserved3$VH() {
        return _GtkStyleClass._gtk_reserved3$VH;
    }
    public static MemoryAddress _gtk_reserved3$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved3$VH.get(seg);
    }
    public static void _gtk_reserved3$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved3$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved3$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved3$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved3$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved3$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved3 _gtk_reserved3 (MemorySegment segment, MemorySession session) {
        return _gtk_reserved3.ofAddress(_gtk_reserved3$get(segment), session);
    }
    static final FunctionDescriptor _gtk_reserved4$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved4$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved4$FUNC
    );
    public interface _gtk_reserved4 {

        void apply();
        static MemorySegment allocate(_gtk_reserved4 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_gtk_reserved4.class, fi, _GtkStyleClass._gtk_reserved4$FUNC, session);
        }
        static _gtk_reserved4 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GtkStyleClass._gtk_reserved4$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved4$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved4"));
    public static VarHandle _gtk_reserved4$VH() {
        return _GtkStyleClass._gtk_reserved4$VH;
    }
    public static MemoryAddress _gtk_reserved4$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved4$VH.get(seg);
    }
    public static void _gtk_reserved4$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved4$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved4$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved4$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved4$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved4$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved4 _gtk_reserved4 (MemorySegment segment, MemorySession session) {
        return _gtk_reserved4.ofAddress(_gtk_reserved4$get(segment), session);
    }
    static final FunctionDescriptor _gtk_reserved5$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved5$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved5$FUNC
    );
    public interface _gtk_reserved5 {

        void apply();
        static MemorySegment allocate(_gtk_reserved5 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_gtk_reserved5.class, fi, _GtkStyleClass._gtk_reserved5$FUNC, session);
        }
        static _gtk_reserved5 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GtkStyleClass._gtk_reserved5$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved5$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved5"));
    public static VarHandle _gtk_reserved5$VH() {
        return _GtkStyleClass._gtk_reserved5$VH;
    }
    public static MemoryAddress _gtk_reserved5$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved5$VH.get(seg);
    }
    public static void _gtk_reserved5$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved5$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved5$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved5$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved5$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved5$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved5 _gtk_reserved5 (MemorySegment segment, MemorySession session) {
        return _gtk_reserved5.ofAddress(_gtk_reserved5$get(segment), session);
    }
    static final FunctionDescriptor _gtk_reserved6$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved6$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved6$FUNC
    );
    public interface _gtk_reserved6 {

        void apply();
        static MemorySegment allocate(_gtk_reserved6 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_gtk_reserved6.class, fi, _GtkStyleClass._gtk_reserved6$FUNC, session);
        }
        static _gtk_reserved6 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GtkStyleClass._gtk_reserved6$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved6$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved6"));
    public static VarHandle _gtk_reserved6$VH() {
        return _GtkStyleClass._gtk_reserved6$VH;
    }
    public static MemoryAddress _gtk_reserved6$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved6$VH.get(seg);
    }
    public static void _gtk_reserved6$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved6$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved6$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved6$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved6$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved6$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved6 _gtk_reserved6 (MemorySegment segment, MemorySession session) {
        return _gtk_reserved6.ofAddress(_gtk_reserved6$get(segment), session);
    }
    static final FunctionDescriptor _gtk_reserved7$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved7$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved7$FUNC
    );
    public interface _gtk_reserved7 {

        void apply();
        static MemorySegment allocate(_gtk_reserved7 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_gtk_reserved7.class, fi, _GtkStyleClass._gtk_reserved7$FUNC, session);
        }
        static _gtk_reserved7 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GtkStyleClass._gtk_reserved7$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved7$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved7"));
    public static VarHandle _gtk_reserved7$VH() {
        return _GtkStyleClass._gtk_reserved7$VH;
    }
    public static MemoryAddress _gtk_reserved7$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved7$VH.get(seg);
    }
    public static void _gtk_reserved7$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved7$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved7$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved7$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved7$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved7$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved7 _gtk_reserved7 (MemorySegment segment, MemorySession session) {
        return _gtk_reserved7.ofAddress(_gtk_reserved7$get(segment), session);
    }
    static final FunctionDescriptor _gtk_reserved8$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved8$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved8$FUNC
    );
    public interface _gtk_reserved8 {

        void apply();
        static MemorySegment allocate(_gtk_reserved8 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_gtk_reserved8.class, fi, _GtkStyleClass._gtk_reserved8$FUNC, session);
        }
        static _gtk_reserved8 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GtkStyleClass._gtk_reserved8$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved8$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved8"));
    public static VarHandle _gtk_reserved8$VH() {
        return _GtkStyleClass._gtk_reserved8$VH;
    }
    public static MemoryAddress _gtk_reserved8$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved8$VH.get(seg);
    }
    public static void _gtk_reserved8$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved8$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved8$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved8$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved8$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved8$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved8 _gtk_reserved8 (MemorySegment segment, MemorySession session) {
        return _gtk_reserved8.ofAddress(_gtk_reserved8$get(segment), session);
    }
    static final FunctionDescriptor _gtk_reserved9$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved9$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved9$FUNC
    );
    public interface _gtk_reserved9 {

        void apply();
        static MemorySegment allocate(_gtk_reserved9 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_gtk_reserved9.class, fi, _GtkStyleClass._gtk_reserved9$FUNC, session);
        }
        static _gtk_reserved9 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GtkStyleClass._gtk_reserved9$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved9$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved9"));
    public static VarHandle _gtk_reserved9$VH() {
        return _GtkStyleClass._gtk_reserved9$VH;
    }
    public static MemoryAddress _gtk_reserved9$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved9$VH.get(seg);
    }
    public static void _gtk_reserved9$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved9$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved9$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved9$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved9$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved9$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved9 _gtk_reserved9 (MemorySegment segment, MemorySession session) {
        return _gtk_reserved9.ofAddress(_gtk_reserved9$get(segment), session);
    }
    static final FunctionDescriptor _gtk_reserved10$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved10$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved10$FUNC
    );
    public interface _gtk_reserved10 {

        void apply();
        static MemorySegment allocate(_gtk_reserved10 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_gtk_reserved10.class, fi, _GtkStyleClass._gtk_reserved10$FUNC, session);
        }
        static _gtk_reserved10 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GtkStyleClass._gtk_reserved10$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved10$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved10"));
    public static VarHandle _gtk_reserved10$VH() {
        return _GtkStyleClass._gtk_reserved10$VH;
    }
    public static MemoryAddress _gtk_reserved10$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved10$VH.get(seg);
    }
    public static void _gtk_reserved10$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved10$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved10$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved10$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved10$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved10$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved10 _gtk_reserved10 (MemorySegment segment, MemorySession session) {
        return _gtk_reserved10.ofAddress(_gtk_reserved10$get(segment), session);
    }
    static final FunctionDescriptor _gtk_reserved11$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved11$MH = RuntimeHelper.downcallHandle(
        _GtkStyleClass._gtk_reserved11$FUNC
    );
    public interface _gtk_reserved11 {

        void apply();
        static MemorySegment allocate(_gtk_reserved11 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_gtk_reserved11.class, fi, _GtkStyleClass._gtk_reserved11$FUNC, session);
        }
        static _gtk_reserved11 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GtkStyleClass._gtk_reserved11$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved11$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved11"));
    public static VarHandle _gtk_reserved11$VH() {
        return _GtkStyleClass._gtk_reserved11$VH;
    }
    public static MemoryAddress _gtk_reserved11$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved11$VH.get(seg);
    }
    public static void _gtk_reserved11$set( MemorySegment seg, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved11$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved11$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkStyleClass._gtk_reserved11$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved11$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkStyleClass._gtk_reserved11$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved11 _gtk_reserved11 (MemorySegment segment, MemorySession session) {
        return _gtk_reserved11.ofAddress(_gtk_reserved11$get(segment), session);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }
}


