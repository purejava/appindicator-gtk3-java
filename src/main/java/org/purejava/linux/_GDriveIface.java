// Generated by jextract

package org.purejava.linux;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
/**
 * {@snippet :
 * struct _GDriveIface {
 *     GTypeInterface g_iface;
 *     void (*changed)(GDrive*);
 *     void (*disconnected)(GDrive*);
 *     void (*eject_button)(GDrive*);
 *     char* (*get_name)(GDrive*);
 *     GIcon* (*get_icon)(GDrive*);
 *     gboolean (*has_volumes)(GDrive*);
 *     GList* (*get_volumes)(GDrive*);
 *     gboolean (*is_media_removable)(GDrive*);
 *     gboolean (*has_media)(GDrive*);
 *     gboolean (*is_media_check_automatic)(GDrive*);
 *     gboolean (*can_eject)(GDrive*);
 *     gboolean (*can_poll_for_media)(GDrive*);
 *     void (*eject)(GDrive*,GMountUnmountFlags,GCancellable*,GAsyncReadyCallback,gpointer);
 *     gboolean (*eject_finish)(GDrive*,GAsyncResult*,GError**);
 *     void (*poll_for_media)(GDrive*,GCancellable*,GAsyncReadyCallback,gpointer);
 *     gboolean (*poll_for_media_finish)(GDrive*,GAsyncResult*,GError**);
 *     char* (*get_identifier)(GDrive*,char*);
 *     char** (*enumerate_identifiers)(GDrive*);
 *     GDriveStartStopType (*get_start_stop_type)(GDrive*);
 *     gboolean (*can_start)(GDrive*);
 *     gboolean (*can_start_degraded)(GDrive*);
 *     void (*start)(GDrive*,GDriveStartFlags,GMountOperation*,GCancellable*,GAsyncReadyCallback,gpointer);
 *     gboolean (*start_finish)(GDrive*,GAsyncResult*,GError**);
 *     gboolean (*can_stop)(GDrive*);
 *     void (*stop)(GDrive*,GMountUnmountFlags,GMountOperation*,GCancellable*,GAsyncReadyCallback,gpointer);
 *     gboolean (*stop_finish)(GDrive*,GAsyncResult*,GError**);
 *     void (*stop_button)(GDrive*);
 *     void (*eject_with_operation)(GDrive*,GMountUnmountFlags,GMountOperation*,GCancellable*,GAsyncReadyCallback,gpointer);
 *     gboolean (*eject_with_operation_finish)(GDrive*,GAsyncResult*,GError**);
 *     const gchar* (*get_sort_key)(GDrive*);
 *     GIcon* (*get_symbolic_icon)(GDrive*);
 *     gboolean (*is_removable)(GDrive*);
 * };
 * }
 */
public class _GDriveIface {

    static final StructLayout $struct$LAYOUT = MemoryLayout.structLayout(
        MemoryLayout.structLayout(
            Constants$root.C_LONG_LONG$LAYOUT.withName("g_type"),
            Constants$root.C_LONG_LONG$LAYOUT.withName("g_instance_type")
        ).withName("g_iface"),
        Constants$root.C_POINTER$LAYOUT.withName("changed"),
        Constants$root.C_POINTER$LAYOUT.withName("disconnected"),
        Constants$root.C_POINTER$LAYOUT.withName("eject_button"),
        Constants$root.C_POINTER$LAYOUT.withName("get_name"),
        Constants$root.C_POINTER$LAYOUT.withName("get_icon"),
        Constants$root.C_POINTER$LAYOUT.withName("has_volumes"),
        Constants$root.C_POINTER$LAYOUT.withName("get_volumes"),
        Constants$root.C_POINTER$LAYOUT.withName("is_media_removable"),
        Constants$root.C_POINTER$LAYOUT.withName("has_media"),
        Constants$root.C_POINTER$LAYOUT.withName("is_media_check_automatic"),
        Constants$root.C_POINTER$LAYOUT.withName("can_eject"),
        Constants$root.C_POINTER$LAYOUT.withName("can_poll_for_media"),
        Constants$root.C_POINTER$LAYOUT.withName("eject"),
        Constants$root.C_POINTER$LAYOUT.withName("eject_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("poll_for_media"),
        Constants$root.C_POINTER$LAYOUT.withName("poll_for_media_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("get_identifier"),
        Constants$root.C_POINTER$LAYOUT.withName("enumerate_identifiers"),
        Constants$root.C_POINTER$LAYOUT.withName("get_start_stop_type"),
        Constants$root.C_POINTER$LAYOUT.withName("can_start"),
        Constants$root.C_POINTER$LAYOUT.withName("can_start_degraded"),
        Constants$root.C_POINTER$LAYOUT.withName("start"),
        Constants$root.C_POINTER$LAYOUT.withName("start_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("can_stop"),
        Constants$root.C_POINTER$LAYOUT.withName("stop"),
        Constants$root.C_POINTER$LAYOUT.withName("stop_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("stop_button"),
        Constants$root.C_POINTER$LAYOUT.withName("eject_with_operation"),
        Constants$root.C_POINTER$LAYOUT.withName("eject_with_operation_finish"),
        Constants$root.C_POINTER$LAYOUT.withName("get_sort_key"),
        Constants$root.C_POINTER$LAYOUT.withName("get_symbolic_icon"),
        Constants$root.C_POINTER$LAYOUT.withName("is_removable")
    ).withName("_GDriveIface");
    public static MemoryLayout $LAYOUT() {
        return _GDriveIface.$struct$LAYOUT;
    }
    public static MemorySegment g_iface$slice(MemorySegment seg) {
        return seg.asSlice(0, 16);
    }
    static final FunctionDescriptor changed$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor changed_UP$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle changed_UP$MH = RuntimeHelper.upcallHandle(changed.class, "apply", _GDriveIface.changed_UP$FUNC);
    static final FunctionDescriptor changed_DOWN$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle changed_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.changed_DOWN$FUNC
    );
    /**
     * {@snippet :
 * void (*changed)(GDrive*);
     * }
     */
    public interface changed {

        void apply(java.lang.foreign.MemorySegment display);
        static MemorySegment allocate(changed fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.changed_UP$MH, fi, _GDriveIface.changed$FUNC, scope);
        }
        static changed ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment _display) -> {
                try {
                    _GDriveIface.changed_DOWN$MH.invokeExact(symbol, _display);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle changed$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("changed"));
    public static VarHandle changed$VH() {
        return _GDriveIface.changed$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * void (*changed)(GDrive*);
     * }
     */
    public static MemorySegment changed$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.changed$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * void (*changed)(GDrive*);
     * }
     */
    public static void changed$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.changed$VH.set(seg, x);
    }
    public static MemorySegment changed$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.changed$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void changed$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.changed$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static changed changed(MemorySegment segment, SegmentScope scope) {
        return changed.ofAddress(changed$get(segment), scope);
    }
    static final FunctionDescriptor disconnected$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor disconnected_UP$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle disconnected_UP$MH = RuntimeHelper.upcallHandle(disconnected.class, "apply", _GDriveIface.disconnected_UP$FUNC);
    static final FunctionDescriptor disconnected_DOWN$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle disconnected_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.disconnected_DOWN$FUNC
    );
    /**
     * {@snippet :
 * void (*disconnected)(GDrive*);
     * }
     */
    public interface disconnected {

        void apply(java.lang.foreign.MemorySegment display);
        static MemorySegment allocate(disconnected fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.disconnected_UP$MH, fi, _GDriveIface.disconnected$FUNC, scope);
        }
        static disconnected ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment _display) -> {
                try {
                    _GDriveIface.disconnected_DOWN$MH.invokeExact(symbol, _display);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle disconnected$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("disconnected"));
    public static VarHandle disconnected$VH() {
        return _GDriveIface.disconnected$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * void (*disconnected)(GDrive*);
     * }
     */
    public static MemorySegment disconnected$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.disconnected$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * void (*disconnected)(GDrive*);
     * }
     */
    public static void disconnected$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.disconnected$VH.set(seg, x);
    }
    public static MemorySegment disconnected$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.disconnected$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void disconnected$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.disconnected$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static disconnected disconnected(MemorySegment segment, SegmentScope scope) {
        return disconnected.ofAddress(disconnected$get(segment), scope);
    }
    static final FunctionDescriptor eject_button$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor eject_button_UP$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle eject_button_UP$MH = RuntimeHelper.upcallHandle(eject_button.class, "apply", _GDriveIface.eject_button_UP$FUNC);
    static final FunctionDescriptor eject_button_DOWN$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle eject_button_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.eject_button_DOWN$FUNC
    );
    /**
     * {@snippet :
 * void (*eject_button)(GDrive*);
     * }
     */
    public interface eject_button {

        void apply(java.lang.foreign.MemorySegment display);
        static MemorySegment allocate(eject_button fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.eject_button_UP$MH, fi, _GDriveIface.eject_button$FUNC, scope);
        }
        static eject_button ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment _display) -> {
                try {
                    _GDriveIface.eject_button_DOWN$MH.invokeExact(symbol, _display);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle eject_button$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("eject_button"));
    public static VarHandle eject_button$VH() {
        return _GDriveIface.eject_button$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * void (*eject_button)(GDrive*);
     * }
     */
    public static MemorySegment eject_button$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.eject_button$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * void (*eject_button)(GDrive*);
     * }
     */
    public static void eject_button$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.eject_button$VH.set(seg, x);
    }
    public static MemorySegment eject_button$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.eject_button$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void eject_button$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.eject_button$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static eject_button eject_button(MemorySegment segment, SegmentScope scope) {
        return eject_button.ofAddress(eject_button$get(segment), scope);
    }
    static final FunctionDescriptor get_name$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor get_name_UP$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_name_UP$MH = RuntimeHelper.upcallHandle(get_name.class, "apply", _GDriveIface.get_name_UP$FUNC);
    static final FunctionDescriptor get_name_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_name_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.get_name_DOWN$FUNC
    );
    /**
     * {@snippet :
 * char* (*get_name)(GDrive*);
     * }
     */
    public interface get_name {

        java.lang.foreign.MemorySegment apply(java.lang.foreign.MemorySegment user_data);
        static MemorySegment allocate(get_name fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.get_name_UP$MH, fi, _GDriveIface.get_name$FUNC, scope);
        }
        static get_name ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment _user_data) -> {
                try {
                    return (java.lang.foreign.MemorySegment)_GDriveIface.get_name_DOWN$MH.invokeExact(symbol, _user_data);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_name$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_name"));
    public static VarHandle get_name$VH() {
        return _GDriveIface.get_name$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * char* (*get_name)(GDrive*);
     * }
     */
    public static MemorySegment get_name$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.get_name$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * char* (*get_name)(GDrive*);
     * }
     */
    public static void get_name$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.get_name$VH.set(seg, x);
    }
    public static MemorySegment get_name$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.get_name$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_name$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.get_name$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_name get_name(MemorySegment segment, SegmentScope scope) {
        return get_name.ofAddress(get_name$get(segment), scope);
    }
    static final FunctionDescriptor get_icon$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor get_icon_UP$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_icon_UP$MH = RuntimeHelper.upcallHandle(get_icon.class, "apply", _GDriveIface.get_icon_UP$FUNC);
    static final FunctionDescriptor get_icon_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_icon_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.get_icon_DOWN$FUNC
    );
    /**
     * {@snippet :
 * GIcon* (*get_icon)(GDrive*);
     * }
     */
    public interface get_icon {

        java.lang.foreign.MemorySegment apply(java.lang.foreign.MemorySegment user_data);
        static MemorySegment allocate(get_icon fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.get_icon_UP$MH, fi, _GDriveIface.get_icon$FUNC, scope);
        }
        static get_icon ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment _user_data) -> {
                try {
                    return (java.lang.foreign.MemorySegment)_GDriveIface.get_icon_DOWN$MH.invokeExact(symbol, _user_data);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_icon$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_icon"));
    public static VarHandle get_icon$VH() {
        return _GDriveIface.get_icon$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * GIcon* (*get_icon)(GDrive*);
     * }
     */
    public static MemorySegment get_icon$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.get_icon$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * GIcon* (*get_icon)(GDrive*);
     * }
     */
    public static void get_icon$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.get_icon$VH.set(seg, x);
    }
    public static MemorySegment get_icon$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.get_icon$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_icon$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.get_icon$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_icon get_icon(MemorySegment segment, SegmentScope scope) {
        return get_icon.ofAddress(get_icon$get(segment), scope);
    }
    static final FunctionDescriptor has_volumes$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor has_volumes_UP$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle has_volumes_UP$MH = RuntimeHelper.upcallHandle(has_volumes.class, "apply", _GDriveIface.has_volumes_UP$FUNC);
    static final FunctionDescriptor has_volumes_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle has_volumes_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.has_volumes_DOWN$FUNC
    );
    /**
     * {@snippet :
 * gboolean (*has_volumes)(GDrive*);
     * }
     */
    public interface has_volumes {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(has_volumes fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.has_volumes_UP$MH, fi, _GDriveIface.has_volumes$FUNC, scope);
        }
        static has_volumes ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)_GDriveIface.has_volumes_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle has_volumes$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("has_volumes"));
    public static VarHandle has_volumes$VH() {
        return _GDriveIface.has_volumes$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * gboolean (*has_volumes)(GDrive*);
     * }
     */
    public static MemorySegment has_volumes$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.has_volumes$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * gboolean (*has_volumes)(GDrive*);
     * }
     */
    public static void has_volumes$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.has_volumes$VH.set(seg, x);
    }
    public static MemorySegment has_volumes$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.has_volumes$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void has_volumes$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.has_volumes$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static has_volumes has_volumes(MemorySegment segment, SegmentScope scope) {
        return has_volumes.ofAddress(has_volumes$get(segment), scope);
    }
    static final FunctionDescriptor get_volumes$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor get_volumes_UP$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_volumes_UP$MH = RuntimeHelper.upcallHandle(get_volumes.class, "apply", _GDriveIface.get_volumes_UP$FUNC);
    static final FunctionDescriptor get_volumes_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_volumes_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.get_volumes_DOWN$FUNC
    );
    /**
     * {@snippet :
 * GList* (*get_volumes)(GDrive*);
     * }
     */
    public interface get_volumes {

        java.lang.foreign.MemorySegment apply(java.lang.foreign.MemorySegment user_data);
        static MemorySegment allocate(get_volumes fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.get_volumes_UP$MH, fi, _GDriveIface.get_volumes$FUNC, scope);
        }
        static get_volumes ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment _user_data) -> {
                try {
                    return (java.lang.foreign.MemorySegment)_GDriveIface.get_volumes_DOWN$MH.invokeExact(symbol, _user_data);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_volumes$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_volumes"));
    public static VarHandle get_volumes$VH() {
        return _GDriveIface.get_volumes$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * GList* (*get_volumes)(GDrive*);
     * }
     */
    public static MemorySegment get_volumes$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.get_volumes$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * GList* (*get_volumes)(GDrive*);
     * }
     */
    public static void get_volumes$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.get_volumes$VH.set(seg, x);
    }
    public static MemorySegment get_volumes$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.get_volumes$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_volumes$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.get_volumes$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_volumes get_volumes(MemorySegment segment, SegmentScope scope) {
        return get_volumes.ofAddress(get_volumes$get(segment), scope);
    }
    static final FunctionDescriptor is_media_removable$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor is_media_removable_UP$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle is_media_removable_UP$MH = RuntimeHelper.upcallHandle(is_media_removable.class, "apply", _GDriveIface.is_media_removable_UP$FUNC);
    static final FunctionDescriptor is_media_removable_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle is_media_removable_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.is_media_removable_DOWN$FUNC
    );
    /**
     * {@snippet :
 * gboolean (*is_media_removable)(GDrive*);
     * }
     */
    public interface is_media_removable {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(is_media_removable fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.is_media_removable_UP$MH, fi, _GDriveIface.is_media_removable$FUNC, scope);
        }
        static is_media_removable ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)_GDriveIface.is_media_removable_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle is_media_removable$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("is_media_removable"));
    public static VarHandle is_media_removable$VH() {
        return _GDriveIface.is_media_removable$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * gboolean (*is_media_removable)(GDrive*);
     * }
     */
    public static MemorySegment is_media_removable$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.is_media_removable$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * gboolean (*is_media_removable)(GDrive*);
     * }
     */
    public static void is_media_removable$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.is_media_removable$VH.set(seg, x);
    }
    public static MemorySegment is_media_removable$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.is_media_removable$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void is_media_removable$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.is_media_removable$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static is_media_removable is_media_removable(MemorySegment segment, SegmentScope scope) {
        return is_media_removable.ofAddress(is_media_removable$get(segment), scope);
    }
    static final FunctionDescriptor has_media$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor has_media_UP$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle has_media_UP$MH = RuntimeHelper.upcallHandle(has_media.class, "apply", _GDriveIface.has_media_UP$FUNC);
    static final FunctionDescriptor has_media_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle has_media_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.has_media_DOWN$FUNC
    );
    /**
     * {@snippet :
 * gboolean (*has_media)(GDrive*);
     * }
     */
    public interface has_media {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(has_media fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.has_media_UP$MH, fi, _GDriveIface.has_media$FUNC, scope);
        }
        static has_media ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)_GDriveIface.has_media_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle has_media$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("has_media"));
    public static VarHandle has_media$VH() {
        return _GDriveIface.has_media$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * gboolean (*has_media)(GDrive*);
     * }
     */
    public static MemorySegment has_media$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.has_media$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * gboolean (*has_media)(GDrive*);
     * }
     */
    public static void has_media$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.has_media$VH.set(seg, x);
    }
    public static MemorySegment has_media$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.has_media$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void has_media$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.has_media$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static has_media has_media(MemorySegment segment, SegmentScope scope) {
        return has_media.ofAddress(has_media$get(segment), scope);
    }
    static final FunctionDescriptor is_media_check_automatic$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor is_media_check_automatic_UP$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle is_media_check_automatic_UP$MH = RuntimeHelper.upcallHandle(is_media_check_automatic.class, "apply", _GDriveIface.is_media_check_automatic_UP$FUNC);
    static final FunctionDescriptor is_media_check_automatic_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle is_media_check_automatic_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.is_media_check_automatic_DOWN$FUNC
    );
    /**
     * {@snippet :
 * gboolean (*is_media_check_automatic)(GDrive*);
     * }
     */
    public interface is_media_check_automatic {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(is_media_check_automatic fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.is_media_check_automatic_UP$MH, fi, _GDriveIface.is_media_check_automatic$FUNC, scope);
        }
        static is_media_check_automatic ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)_GDriveIface.is_media_check_automatic_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle is_media_check_automatic$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("is_media_check_automatic"));
    public static VarHandle is_media_check_automatic$VH() {
        return _GDriveIface.is_media_check_automatic$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * gboolean (*is_media_check_automatic)(GDrive*);
     * }
     */
    public static MemorySegment is_media_check_automatic$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.is_media_check_automatic$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * gboolean (*is_media_check_automatic)(GDrive*);
     * }
     */
    public static void is_media_check_automatic$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.is_media_check_automatic$VH.set(seg, x);
    }
    public static MemorySegment is_media_check_automatic$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.is_media_check_automatic$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void is_media_check_automatic$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.is_media_check_automatic$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static is_media_check_automatic is_media_check_automatic(MemorySegment segment, SegmentScope scope) {
        return is_media_check_automatic.ofAddress(is_media_check_automatic$get(segment), scope);
    }
    static final FunctionDescriptor can_eject$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor can_eject_UP$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle can_eject_UP$MH = RuntimeHelper.upcallHandle(can_eject.class, "apply", _GDriveIface.can_eject_UP$FUNC);
    static final FunctionDescriptor can_eject_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle can_eject_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.can_eject_DOWN$FUNC
    );
    /**
     * {@snippet :
 * gboolean (*can_eject)(GDrive*);
     * }
     */
    public interface can_eject {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(can_eject fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.can_eject_UP$MH, fi, _GDriveIface.can_eject$FUNC, scope);
        }
        static can_eject ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)_GDriveIface.can_eject_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle can_eject$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("can_eject"));
    public static VarHandle can_eject$VH() {
        return _GDriveIface.can_eject$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * gboolean (*can_eject)(GDrive*);
     * }
     */
    public static MemorySegment can_eject$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.can_eject$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * gboolean (*can_eject)(GDrive*);
     * }
     */
    public static void can_eject$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.can_eject$VH.set(seg, x);
    }
    public static MemorySegment can_eject$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.can_eject$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void can_eject$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.can_eject$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static can_eject can_eject(MemorySegment segment, SegmentScope scope) {
        return can_eject.ofAddress(can_eject$get(segment), scope);
    }
    static final FunctionDescriptor can_poll_for_media$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor can_poll_for_media_UP$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle can_poll_for_media_UP$MH = RuntimeHelper.upcallHandle(can_poll_for_media.class, "apply", _GDriveIface.can_poll_for_media_UP$FUNC);
    static final FunctionDescriptor can_poll_for_media_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle can_poll_for_media_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.can_poll_for_media_DOWN$FUNC
    );
    /**
     * {@snippet :
 * gboolean (*can_poll_for_media)(GDrive*);
     * }
     */
    public interface can_poll_for_media {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(can_poll_for_media fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.can_poll_for_media_UP$MH, fi, _GDriveIface.can_poll_for_media$FUNC, scope);
        }
        static can_poll_for_media ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)_GDriveIface.can_poll_for_media_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle can_poll_for_media$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("can_poll_for_media"));
    public static VarHandle can_poll_for_media$VH() {
        return _GDriveIface.can_poll_for_media$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * gboolean (*can_poll_for_media)(GDrive*);
     * }
     */
    public static MemorySegment can_poll_for_media$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.can_poll_for_media$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * gboolean (*can_poll_for_media)(GDrive*);
     * }
     */
    public static void can_poll_for_media$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.can_poll_for_media$VH.set(seg, x);
    }
    public static MemorySegment can_poll_for_media$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.can_poll_for_media$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void can_poll_for_media$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.can_poll_for_media$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static can_poll_for_media can_poll_for_media(MemorySegment segment, SegmentScope scope) {
        return can_poll_for_media.ofAddress(can_poll_for_media$get(segment), scope);
    }
    static final FunctionDescriptor eject$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor eject_UP$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle eject_UP$MH = RuntimeHelper.upcallHandle(eject.class, "apply", _GDriveIface.eject_UP$FUNC);
    static final FunctionDescriptor eject_DOWN$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle eject_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.eject_DOWN$FUNC
    );
    /**
     * {@snippet :
 * void (*eject)(GDrive*,GMountUnmountFlags,GCancellable*,GAsyncReadyCallback,gpointer);
     * }
     */
    public interface eject {

        void apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2, java.lang.foreign.MemorySegment _x3, java.lang.foreign.MemorySegment _x4);
        static MemorySegment allocate(eject fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.eject_UP$MH, fi, _GDriveIface.eject$FUNC, scope);
        }
        static eject ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2, java.lang.foreign.MemorySegment __x3, java.lang.foreign.MemorySegment __x4) -> {
                try {
                    _GDriveIface.eject_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle eject$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("eject"));
    public static VarHandle eject$VH() {
        return _GDriveIface.eject$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * void (*eject)(GDrive*,GMountUnmountFlags,GCancellable*,GAsyncReadyCallback,gpointer);
     * }
     */
    public static MemorySegment eject$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.eject$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * void (*eject)(GDrive*,GMountUnmountFlags,GCancellable*,GAsyncReadyCallback,gpointer);
     * }
     */
    public static void eject$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.eject$VH.set(seg, x);
    }
    public static MemorySegment eject$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.eject$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void eject$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.eject$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static eject eject(MemorySegment segment, SegmentScope scope) {
        return eject.ofAddress(eject$get(segment), scope);
    }
    static final FunctionDescriptor eject_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor eject_finish_UP$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle eject_finish_UP$MH = RuntimeHelper.upcallHandle(eject_finish.class, "apply", _GDriveIface.eject_finish_UP$FUNC);
    static final FunctionDescriptor eject_finish_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle eject_finish_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.eject_finish_DOWN$FUNC
    );
    /**
     * {@snippet :
 * gboolean (*eject_finish)(GDrive*,GAsyncResult*,GError**);
     * }
     */
    public interface eject_finish {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(eject_finish fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.eject_finish_UP$MH, fi, _GDriveIface.eject_finish$FUNC, scope);
        }
        static eject_finish ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)_GDriveIface.eject_finish_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle eject_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("eject_finish"));
    public static VarHandle eject_finish$VH() {
        return _GDriveIface.eject_finish$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * gboolean (*eject_finish)(GDrive*,GAsyncResult*,GError**);
     * }
     */
    public static MemorySegment eject_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.eject_finish$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * gboolean (*eject_finish)(GDrive*,GAsyncResult*,GError**);
     * }
     */
    public static void eject_finish$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.eject_finish$VH.set(seg, x);
    }
    public static MemorySegment eject_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.eject_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void eject_finish$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.eject_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static eject_finish eject_finish(MemorySegment segment, SegmentScope scope) {
        return eject_finish.ofAddress(eject_finish$get(segment), scope);
    }
    static final FunctionDescriptor poll_for_media$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor poll_for_media_UP$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle poll_for_media_UP$MH = RuntimeHelper.upcallHandle(poll_for_media.class, "apply", _GDriveIface.poll_for_media_UP$FUNC);
    static final FunctionDescriptor poll_for_media_DOWN$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle poll_for_media_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.poll_for_media_DOWN$FUNC
    );
    /**
     * {@snippet :
 * void (*poll_for_media)(GDrive*,GCancellable*,GAsyncReadyCallback,gpointer);
     * }
     */
    public interface poll_for_media {

        void apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2, java.lang.foreign.MemorySegment _x3);
        static MemorySegment allocate(poll_for_media fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.poll_for_media_UP$MH, fi, _GDriveIface.poll_for_media$FUNC, scope);
        }
        static poll_for_media ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2, java.lang.foreign.MemorySegment __x3) -> {
                try {
                    _GDriveIface.poll_for_media_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle poll_for_media$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("poll_for_media"));
    public static VarHandle poll_for_media$VH() {
        return _GDriveIface.poll_for_media$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * void (*poll_for_media)(GDrive*,GCancellable*,GAsyncReadyCallback,gpointer);
     * }
     */
    public static MemorySegment poll_for_media$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.poll_for_media$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * void (*poll_for_media)(GDrive*,GCancellable*,GAsyncReadyCallback,gpointer);
     * }
     */
    public static void poll_for_media$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.poll_for_media$VH.set(seg, x);
    }
    public static MemorySegment poll_for_media$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.poll_for_media$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void poll_for_media$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.poll_for_media$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static poll_for_media poll_for_media(MemorySegment segment, SegmentScope scope) {
        return poll_for_media.ofAddress(poll_for_media$get(segment), scope);
    }
    static final FunctionDescriptor poll_for_media_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor poll_for_media_finish_UP$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle poll_for_media_finish_UP$MH = RuntimeHelper.upcallHandle(poll_for_media_finish.class, "apply", _GDriveIface.poll_for_media_finish_UP$FUNC);
    static final FunctionDescriptor poll_for_media_finish_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle poll_for_media_finish_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.poll_for_media_finish_DOWN$FUNC
    );
    /**
     * {@snippet :
 * gboolean (*poll_for_media_finish)(GDrive*,GAsyncResult*,GError**);
     * }
     */
    public interface poll_for_media_finish {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(poll_for_media_finish fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.poll_for_media_finish_UP$MH, fi, _GDriveIface.poll_for_media_finish$FUNC, scope);
        }
        static poll_for_media_finish ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)_GDriveIface.poll_for_media_finish_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle poll_for_media_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("poll_for_media_finish"));
    public static VarHandle poll_for_media_finish$VH() {
        return _GDriveIface.poll_for_media_finish$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * gboolean (*poll_for_media_finish)(GDrive*,GAsyncResult*,GError**);
     * }
     */
    public static MemorySegment poll_for_media_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.poll_for_media_finish$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * gboolean (*poll_for_media_finish)(GDrive*,GAsyncResult*,GError**);
     * }
     */
    public static void poll_for_media_finish$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.poll_for_media_finish$VH.set(seg, x);
    }
    public static MemorySegment poll_for_media_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.poll_for_media_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void poll_for_media_finish$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.poll_for_media_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static poll_for_media_finish poll_for_media_finish(MemorySegment segment, SegmentScope scope) {
        return poll_for_media_finish.ofAddress(poll_for_media_finish$get(segment), scope);
    }
    static final FunctionDescriptor get_identifier$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor get_identifier_UP$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_identifier_UP$MH = RuntimeHelper.upcallHandle(get_identifier.class, "apply", _GDriveIface.get_identifier_UP$FUNC);
    static final FunctionDescriptor get_identifier_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_identifier_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.get_identifier_DOWN$FUNC
    );
    /**
     * {@snippet :
 * char* (*get_identifier)(GDrive*,char*);
     * }
     */
    public interface get_identifier {

        java.lang.foreign.MemorySegment apply(java.lang.foreign.MemorySegment path, java.lang.foreign.MemorySegment func_data);
        static MemorySegment allocate(get_identifier fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.get_identifier_UP$MH, fi, _GDriveIface.get_identifier$FUNC, scope);
        }
        static get_identifier ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment _path, java.lang.foreign.MemorySegment _func_data) -> {
                try {
                    return (java.lang.foreign.MemorySegment)_GDriveIface.get_identifier_DOWN$MH.invokeExact(symbol, _path, _func_data);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_identifier$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_identifier"));
    public static VarHandle get_identifier$VH() {
        return _GDriveIface.get_identifier$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * char* (*get_identifier)(GDrive*,char*);
     * }
     */
    public static MemorySegment get_identifier$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.get_identifier$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * char* (*get_identifier)(GDrive*,char*);
     * }
     */
    public static void get_identifier$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.get_identifier$VH.set(seg, x);
    }
    public static MemorySegment get_identifier$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.get_identifier$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_identifier$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.get_identifier$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_identifier get_identifier(MemorySegment segment, SegmentScope scope) {
        return get_identifier.ofAddress(get_identifier$get(segment), scope);
    }
    static final FunctionDescriptor enumerate_identifiers$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor enumerate_identifiers_UP$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle enumerate_identifiers_UP$MH = RuntimeHelper.upcallHandle(enumerate_identifiers.class, "apply", _GDriveIface.enumerate_identifiers_UP$FUNC);
    static final FunctionDescriptor enumerate_identifiers_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle enumerate_identifiers_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.enumerate_identifiers_DOWN$FUNC
    );
    /**
     * {@snippet :
 * char** (*enumerate_identifiers)(GDrive*);
     * }
     */
    public interface enumerate_identifiers {

        java.lang.foreign.MemorySegment apply(java.lang.foreign.MemorySegment user_data);
        static MemorySegment allocate(enumerate_identifiers fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.enumerate_identifiers_UP$MH, fi, _GDriveIface.enumerate_identifiers$FUNC, scope);
        }
        static enumerate_identifiers ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment _user_data) -> {
                try {
                    return (java.lang.foreign.MemorySegment)_GDriveIface.enumerate_identifiers_DOWN$MH.invokeExact(symbol, _user_data);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle enumerate_identifiers$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("enumerate_identifiers"));
    public static VarHandle enumerate_identifiers$VH() {
        return _GDriveIface.enumerate_identifiers$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * char** (*enumerate_identifiers)(GDrive*);
     * }
     */
    public static MemorySegment enumerate_identifiers$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.enumerate_identifiers$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * char** (*enumerate_identifiers)(GDrive*);
     * }
     */
    public static void enumerate_identifiers$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.enumerate_identifiers$VH.set(seg, x);
    }
    public static MemorySegment enumerate_identifiers$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.enumerate_identifiers$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void enumerate_identifiers$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.enumerate_identifiers$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static enumerate_identifiers enumerate_identifiers(MemorySegment segment, SegmentScope scope) {
        return enumerate_identifiers.ofAddress(enumerate_identifiers$get(segment), scope);
    }
    static final FunctionDescriptor get_start_stop_type$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor get_start_stop_type_UP$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_start_stop_type_UP$MH = RuntimeHelper.upcallHandle(get_start_stop_type.class, "apply", _GDriveIface.get_start_stop_type_UP$FUNC);
    static final FunctionDescriptor get_start_stop_type_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_start_stop_type_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.get_start_stop_type_DOWN$FUNC
    );
    /**
     * {@snippet :
 * GDriveStartStopType (*get_start_stop_type)(GDrive*);
     * }
     */
    public interface get_start_stop_type {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(get_start_stop_type fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.get_start_stop_type_UP$MH, fi, _GDriveIface.get_start_stop_type$FUNC, scope);
        }
        static get_start_stop_type ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)_GDriveIface.get_start_stop_type_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_start_stop_type$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_start_stop_type"));
    public static VarHandle get_start_stop_type$VH() {
        return _GDriveIface.get_start_stop_type$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * GDriveStartStopType (*get_start_stop_type)(GDrive*);
     * }
     */
    public static MemorySegment get_start_stop_type$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.get_start_stop_type$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * GDriveStartStopType (*get_start_stop_type)(GDrive*);
     * }
     */
    public static void get_start_stop_type$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.get_start_stop_type$VH.set(seg, x);
    }
    public static MemorySegment get_start_stop_type$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.get_start_stop_type$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_start_stop_type$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.get_start_stop_type$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_start_stop_type get_start_stop_type(MemorySegment segment, SegmentScope scope) {
        return get_start_stop_type.ofAddress(get_start_stop_type$get(segment), scope);
    }
    static final FunctionDescriptor can_start$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor can_start_UP$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle can_start_UP$MH = RuntimeHelper.upcallHandle(can_start.class, "apply", _GDriveIface.can_start_UP$FUNC);
    static final FunctionDescriptor can_start_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle can_start_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.can_start_DOWN$FUNC
    );
    /**
     * {@snippet :
 * gboolean (*can_start)(GDrive*);
     * }
     */
    public interface can_start {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(can_start fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.can_start_UP$MH, fi, _GDriveIface.can_start$FUNC, scope);
        }
        static can_start ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)_GDriveIface.can_start_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle can_start$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("can_start"));
    public static VarHandle can_start$VH() {
        return _GDriveIface.can_start$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * gboolean (*can_start)(GDrive*);
     * }
     */
    public static MemorySegment can_start$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.can_start$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * gboolean (*can_start)(GDrive*);
     * }
     */
    public static void can_start$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.can_start$VH.set(seg, x);
    }
    public static MemorySegment can_start$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.can_start$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void can_start$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.can_start$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static can_start can_start(MemorySegment segment, SegmentScope scope) {
        return can_start.ofAddress(can_start$get(segment), scope);
    }
    static final FunctionDescriptor can_start_degraded$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor can_start_degraded_UP$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle can_start_degraded_UP$MH = RuntimeHelper.upcallHandle(can_start_degraded.class, "apply", _GDriveIface.can_start_degraded_UP$FUNC);
    static final FunctionDescriptor can_start_degraded_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle can_start_degraded_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.can_start_degraded_DOWN$FUNC
    );
    /**
     * {@snippet :
 * gboolean (*can_start_degraded)(GDrive*);
     * }
     */
    public interface can_start_degraded {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(can_start_degraded fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.can_start_degraded_UP$MH, fi, _GDriveIface.can_start_degraded$FUNC, scope);
        }
        static can_start_degraded ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)_GDriveIface.can_start_degraded_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle can_start_degraded$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("can_start_degraded"));
    public static VarHandle can_start_degraded$VH() {
        return _GDriveIface.can_start_degraded$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * gboolean (*can_start_degraded)(GDrive*);
     * }
     */
    public static MemorySegment can_start_degraded$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.can_start_degraded$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * gboolean (*can_start_degraded)(GDrive*);
     * }
     */
    public static void can_start_degraded$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.can_start_degraded$VH.set(seg, x);
    }
    public static MemorySegment can_start_degraded$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.can_start_degraded$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void can_start_degraded$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.can_start_degraded$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static can_start_degraded can_start_degraded(MemorySegment segment, SegmentScope scope) {
        return can_start_degraded.ofAddress(can_start_degraded$get(segment), scope);
    }
    static final FunctionDescriptor start$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor start_UP$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle start_UP$MH = RuntimeHelper.upcallHandle(start.class, "apply", _GDriveIface.start_UP$FUNC);
    static final FunctionDescriptor start_DOWN$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle start_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.start_DOWN$FUNC
    );
    /**
     * {@snippet :
 * void (*start)(GDrive*,GDriveStartFlags,GMountOperation*,GCancellable*,GAsyncReadyCallback,gpointer);
     * }
     */
    public interface start {

        void apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2, java.lang.foreign.MemorySegment _x3, java.lang.foreign.MemorySegment _x4, java.lang.foreign.MemorySegment _x5);
        static MemorySegment allocate(start fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.start_UP$MH, fi, _GDriveIface.start$FUNC, scope);
        }
        static start ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2, java.lang.foreign.MemorySegment __x3, java.lang.foreign.MemorySegment __x4, java.lang.foreign.MemorySegment __x5) -> {
                try {
                    _GDriveIface.start_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4, __x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle start$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("start"));
    public static VarHandle start$VH() {
        return _GDriveIface.start$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * void (*start)(GDrive*,GDriveStartFlags,GMountOperation*,GCancellable*,GAsyncReadyCallback,gpointer);
     * }
     */
    public static MemorySegment start$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.start$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * void (*start)(GDrive*,GDriveStartFlags,GMountOperation*,GCancellable*,GAsyncReadyCallback,gpointer);
     * }
     */
    public static void start$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.start$VH.set(seg, x);
    }
    public static MemorySegment start$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.start$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void start$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.start$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static start start(MemorySegment segment, SegmentScope scope) {
        return start.ofAddress(start$get(segment), scope);
    }
    static final FunctionDescriptor start_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor start_finish_UP$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle start_finish_UP$MH = RuntimeHelper.upcallHandle(start_finish.class, "apply", _GDriveIface.start_finish_UP$FUNC);
    static final FunctionDescriptor start_finish_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle start_finish_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.start_finish_DOWN$FUNC
    );
    /**
     * {@snippet :
 * gboolean (*start_finish)(GDrive*,GAsyncResult*,GError**);
     * }
     */
    public interface start_finish {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(start_finish fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.start_finish_UP$MH, fi, _GDriveIface.start_finish$FUNC, scope);
        }
        static start_finish ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)_GDriveIface.start_finish_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle start_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("start_finish"));
    public static VarHandle start_finish$VH() {
        return _GDriveIface.start_finish$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * gboolean (*start_finish)(GDrive*,GAsyncResult*,GError**);
     * }
     */
    public static MemorySegment start_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.start_finish$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * gboolean (*start_finish)(GDrive*,GAsyncResult*,GError**);
     * }
     */
    public static void start_finish$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.start_finish$VH.set(seg, x);
    }
    public static MemorySegment start_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.start_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void start_finish$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.start_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static start_finish start_finish(MemorySegment segment, SegmentScope scope) {
        return start_finish.ofAddress(start_finish$get(segment), scope);
    }
    static final FunctionDescriptor can_stop$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor can_stop_UP$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle can_stop_UP$MH = RuntimeHelper.upcallHandle(can_stop.class, "apply", _GDriveIface.can_stop_UP$FUNC);
    static final FunctionDescriptor can_stop_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle can_stop_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.can_stop_DOWN$FUNC
    );
    /**
     * {@snippet :
 * gboolean (*can_stop)(GDrive*);
     * }
     */
    public interface can_stop {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(can_stop fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.can_stop_UP$MH, fi, _GDriveIface.can_stop$FUNC, scope);
        }
        static can_stop ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)_GDriveIface.can_stop_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle can_stop$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("can_stop"));
    public static VarHandle can_stop$VH() {
        return _GDriveIface.can_stop$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * gboolean (*can_stop)(GDrive*);
     * }
     */
    public static MemorySegment can_stop$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.can_stop$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * gboolean (*can_stop)(GDrive*);
     * }
     */
    public static void can_stop$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.can_stop$VH.set(seg, x);
    }
    public static MemorySegment can_stop$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.can_stop$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void can_stop$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.can_stop$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static can_stop can_stop(MemorySegment segment, SegmentScope scope) {
        return can_stop.ofAddress(can_stop$get(segment), scope);
    }
    static final FunctionDescriptor stop$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor stop_UP$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle stop_UP$MH = RuntimeHelper.upcallHandle(stop.class, "apply", _GDriveIface.stop_UP$FUNC);
    static final FunctionDescriptor stop_DOWN$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle stop_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.stop_DOWN$FUNC
    );
    /**
     * {@snippet :
 * void (*stop)(GDrive*,GMountUnmountFlags,GMountOperation*,GCancellable*,GAsyncReadyCallback,gpointer);
     * }
     */
    public interface stop {

        void apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2, java.lang.foreign.MemorySegment _x3, java.lang.foreign.MemorySegment _x4, java.lang.foreign.MemorySegment _x5);
        static MemorySegment allocate(stop fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.stop_UP$MH, fi, _GDriveIface.stop$FUNC, scope);
        }
        static stop ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2, java.lang.foreign.MemorySegment __x3, java.lang.foreign.MemorySegment __x4, java.lang.foreign.MemorySegment __x5) -> {
                try {
                    _GDriveIface.stop_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4, __x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle stop$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("stop"));
    public static VarHandle stop$VH() {
        return _GDriveIface.stop$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * void (*stop)(GDrive*,GMountUnmountFlags,GMountOperation*,GCancellable*,GAsyncReadyCallback,gpointer);
     * }
     */
    public static MemorySegment stop$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.stop$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * void (*stop)(GDrive*,GMountUnmountFlags,GMountOperation*,GCancellable*,GAsyncReadyCallback,gpointer);
     * }
     */
    public static void stop$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.stop$VH.set(seg, x);
    }
    public static MemorySegment stop$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.stop$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void stop$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.stop$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static stop stop(MemorySegment segment, SegmentScope scope) {
        return stop.ofAddress(stop$get(segment), scope);
    }
    static final FunctionDescriptor stop_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor stop_finish_UP$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle stop_finish_UP$MH = RuntimeHelper.upcallHandle(stop_finish.class, "apply", _GDriveIface.stop_finish_UP$FUNC);
    static final FunctionDescriptor stop_finish_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle stop_finish_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.stop_finish_DOWN$FUNC
    );
    /**
     * {@snippet :
 * gboolean (*stop_finish)(GDrive*,GAsyncResult*,GError**);
     * }
     */
    public interface stop_finish {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(stop_finish fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.stop_finish_UP$MH, fi, _GDriveIface.stop_finish$FUNC, scope);
        }
        static stop_finish ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)_GDriveIface.stop_finish_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle stop_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("stop_finish"));
    public static VarHandle stop_finish$VH() {
        return _GDriveIface.stop_finish$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * gboolean (*stop_finish)(GDrive*,GAsyncResult*,GError**);
     * }
     */
    public static MemorySegment stop_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.stop_finish$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * gboolean (*stop_finish)(GDrive*,GAsyncResult*,GError**);
     * }
     */
    public static void stop_finish$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.stop_finish$VH.set(seg, x);
    }
    public static MemorySegment stop_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.stop_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void stop_finish$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.stop_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static stop_finish stop_finish(MemorySegment segment, SegmentScope scope) {
        return stop_finish.ofAddress(stop_finish$get(segment), scope);
    }
    static final FunctionDescriptor stop_button$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor stop_button_UP$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle stop_button_UP$MH = RuntimeHelper.upcallHandle(stop_button.class, "apply", _GDriveIface.stop_button_UP$FUNC);
    static final FunctionDescriptor stop_button_DOWN$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle stop_button_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.stop_button_DOWN$FUNC
    );
    /**
     * {@snippet :
 * void (*stop_button)(GDrive*);
     * }
     */
    public interface stop_button {

        void apply(java.lang.foreign.MemorySegment display);
        static MemorySegment allocate(stop_button fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.stop_button_UP$MH, fi, _GDriveIface.stop_button$FUNC, scope);
        }
        static stop_button ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment _display) -> {
                try {
                    _GDriveIface.stop_button_DOWN$MH.invokeExact(symbol, _display);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle stop_button$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("stop_button"));
    public static VarHandle stop_button$VH() {
        return _GDriveIface.stop_button$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * void (*stop_button)(GDrive*);
     * }
     */
    public static MemorySegment stop_button$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.stop_button$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * void (*stop_button)(GDrive*);
     * }
     */
    public static void stop_button$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.stop_button$VH.set(seg, x);
    }
    public static MemorySegment stop_button$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.stop_button$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void stop_button$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.stop_button$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static stop_button stop_button(MemorySegment segment, SegmentScope scope) {
        return stop_button.ofAddress(stop_button$get(segment), scope);
    }
    static final FunctionDescriptor eject_with_operation$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor eject_with_operation_UP$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle eject_with_operation_UP$MH = RuntimeHelper.upcallHandle(eject_with_operation.class, "apply", _GDriveIface.eject_with_operation_UP$FUNC);
    static final FunctionDescriptor eject_with_operation_DOWN$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle eject_with_operation_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.eject_with_operation_DOWN$FUNC
    );
    /**
     * {@snippet :
 * void (*eject_with_operation)(GDrive*,GMountUnmountFlags,GMountOperation*,GCancellable*,GAsyncReadyCallback,gpointer);
     * }
     */
    public interface eject_with_operation {

        void apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2, java.lang.foreign.MemorySegment _x3, java.lang.foreign.MemorySegment _x4, java.lang.foreign.MemorySegment _x5);
        static MemorySegment allocate(eject_with_operation fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.eject_with_operation_UP$MH, fi, _GDriveIface.eject_with_operation$FUNC, scope);
        }
        static eject_with_operation ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2, java.lang.foreign.MemorySegment __x3, java.lang.foreign.MemorySegment __x4, java.lang.foreign.MemorySegment __x5) -> {
                try {
                    _GDriveIface.eject_with_operation_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4, __x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle eject_with_operation$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("eject_with_operation"));
    public static VarHandle eject_with_operation$VH() {
        return _GDriveIface.eject_with_operation$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * void (*eject_with_operation)(GDrive*,GMountUnmountFlags,GMountOperation*,GCancellable*,GAsyncReadyCallback,gpointer);
     * }
     */
    public static MemorySegment eject_with_operation$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.eject_with_operation$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * void (*eject_with_operation)(GDrive*,GMountUnmountFlags,GMountOperation*,GCancellable*,GAsyncReadyCallback,gpointer);
     * }
     */
    public static void eject_with_operation$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.eject_with_operation$VH.set(seg, x);
    }
    public static MemorySegment eject_with_operation$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.eject_with_operation$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void eject_with_operation$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.eject_with_operation$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static eject_with_operation eject_with_operation(MemorySegment segment, SegmentScope scope) {
        return eject_with_operation.ofAddress(eject_with_operation$get(segment), scope);
    }
    static final FunctionDescriptor eject_with_operation_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor eject_with_operation_finish_UP$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle eject_with_operation_finish_UP$MH = RuntimeHelper.upcallHandle(eject_with_operation_finish.class, "apply", _GDriveIface.eject_with_operation_finish_UP$FUNC);
    static final FunctionDescriptor eject_with_operation_finish_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle eject_with_operation_finish_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.eject_with_operation_finish_DOWN$FUNC
    );
    /**
     * {@snippet :
 * gboolean (*eject_with_operation_finish)(GDrive*,GAsyncResult*,GError**);
     * }
     */
    public interface eject_with_operation_finish {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(eject_with_operation_finish fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.eject_with_operation_finish_UP$MH, fi, _GDriveIface.eject_with_operation_finish$FUNC, scope);
        }
        static eject_with_operation_finish ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)_GDriveIface.eject_with_operation_finish_DOWN$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle eject_with_operation_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("eject_with_operation_finish"));
    public static VarHandle eject_with_operation_finish$VH() {
        return _GDriveIface.eject_with_operation_finish$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * gboolean (*eject_with_operation_finish)(GDrive*,GAsyncResult*,GError**);
     * }
     */
    public static MemorySegment eject_with_operation_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.eject_with_operation_finish$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * gboolean (*eject_with_operation_finish)(GDrive*,GAsyncResult*,GError**);
     * }
     */
    public static void eject_with_operation_finish$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.eject_with_operation_finish$VH.set(seg, x);
    }
    public static MemorySegment eject_with_operation_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.eject_with_operation_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void eject_with_operation_finish$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.eject_with_operation_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static eject_with_operation_finish eject_with_operation_finish(MemorySegment segment, SegmentScope scope) {
        return eject_with_operation_finish.ofAddress(eject_with_operation_finish$get(segment), scope);
    }
    static final FunctionDescriptor get_sort_key$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor get_sort_key_UP$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_sort_key_UP$MH = RuntimeHelper.upcallHandle(get_sort_key.class, "apply", _GDriveIface.get_sort_key_UP$FUNC);
    static final FunctionDescriptor get_sort_key_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_sort_key_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.get_sort_key_DOWN$FUNC
    );
    /**
     * {@snippet :
 * const gchar* (*get_sort_key)(GDrive*);
     * }
     */
    public interface get_sort_key {

        java.lang.foreign.MemorySegment apply(java.lang.foreign.MemorySegment user_data);
        static MemorySegment allocate(get_sort_key fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.get_sort_key_UP$MH, fi, _GDriveIface.get_sort_key$FUNC, scope);
        }
        static get_sort_key ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment _user_data) -> {
                try {
                    return (java.lang.foreign.MemorySegment)_GDriveIface.get_sort_key_DOWN$MH.invokeExact(symbol, _user_data);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_sort_key$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_sort_key"));
    public static VarHandle get_sort_key$VH() {
        return _GDriveIface.get_sort_key$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * const gchar* (*get_sort_key)(GDrive*);
     * }
     */
    public static MemorySegment get_sort_key$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.get_sort_key$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * const gchar* (*get_sort_key)(GDrive*);
     * }
     */
    public static void get_sort_key$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.get_sort_key$VH.set(seg, x);
    }
    public static MemorySegment get_sort_key$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.get_sort_key$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_sort_key$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.get_sort_key$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_sort_key get_sort_key(MemorySegment segment, SegmentScope scope) {
        return get_sort_key.ofAddress(get_sort_key$get(segment), scope);
    }
    static final FunctionDescriptor get_symbolic_icon$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor get_symbolic_icon_UP$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_symbolic_icon_UP$MH = RuntimeHelper.upcallHandle(get_symbolic_icon.class, "apply", _GDriveIface.get_symbolic_icon_UP$FUNC);
    static final FunctionDescriptor get_symbolic_icon_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_symbolic_icon_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.get_symbolic_icon_DOWN$FUNC
    );
    /**
     * {@snippet :
 * GIcon* (*get_symbolic_icon)(GDrive*);
     * }
     */
    public interface get_symbolic_icon {

        java.lang.foreign.MemorySegment apply(java.lang.foreign.MemorySegment user_data);
        static MemorySegment allocate(get_symbolic_icon fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.get_symbolic_icon_UP$MH, fi, _GDriveIface.get_symbolic_icon$FUNC, scope);
        }
        static get_symbolic_icon ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment _user_data) -> {
                try {
                    return (java.lang.foreign.MemorySegment)_GDriveIface.get_symbolic_icon_DOWN$MH.invokeExact(symbol, _user_data);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_symbolic_icon$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_symbolic_icon"));
    public static VarHandle get_symbolic_icon$VH() {
        return _GDriveIface.get_symbolic_icon$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * GIcon* (*get_symbolic_icon)(GDrive*);
     * }
     */
    public static MemorySegment get_symbolic_icon$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.get_symbolic_icon$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * GIcon* (*get_symbolic_icon)(GDrive*);
     * }
     */
    public static void get_symbolic_icon$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.get_symbolic_icon$VH.set(seg, x);
    }
    public static MemorySegment get_symbolic_icon$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.get_symbolic_icon$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_symbolic_icon$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.get_symbolic_icon$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_symbolic_icon get_symbolic_icon(MemorySegment segment, SegmentScope scope) {
        return get_symbolic_icon.ofAddress(get_symbolic_icon$get(segment), scope);
    }
    static final FunctionDescriptor is_removable$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final FunctionDescriptor is_removable_UP$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle is_removable_UP$MH = RuntimeHelper.upcallHandle(is_removable.class, "apply", _GDriveIface.is_removable_UP$FUNC);
    static final FunctionDescriptor is_removable_DOWN$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle is_removable_DOWN$MH = RuntimeHelper.downcallHandle(
        _GDriveIface.is_removable_DOWN$FUNC
    );
    /**
     * {@snippet :
 * gboolean (*is_removable)(GDrive*);
     * }
     */
    public interface is_removable {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(is_removable fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(_GDriveIface.is_removable_UP$MH, fi, _GDriveIface.is_removable$FUNC, scope);
        }
        static is_removable ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)_GDriveIface.is_removable_DOWN$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle is_removable$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("is_removable"));
    public static VarHandle is_removable$VH() {
        return _GDriveIface.is_removable$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * gboolean (*is_removable)(GDrive*);
     * }
     */
    public static MemorySegment is_removable$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.is_removable$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * gboolean (*is_removable)(GDrive*);
     * }
     */
    public static void is_removable$set(MemorySegment seg, MemorySegment x) {
        _GDriveIface.is_removable$VH.set(seg, x);
    }
    public static MemorySegment is_removable$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)_GDriveIface.is_removable$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void is_removable$set(MemorySegment seg, long index, MemorySegment x) {
        _GDriveIface.is_removable$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static is_removable is_removable(MemorySegment segment, SegmentScope scope) {
        return is_removable.ofAddress(is_removable$get(segment), scope);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(long len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemorySegment addr, SegmentScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }
}


