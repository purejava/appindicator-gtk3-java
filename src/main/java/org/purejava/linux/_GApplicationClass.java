// Generated by jextract

package org.purejava.linux;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
public class _GApplicationClass {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        MemoryLayout.structLayout(
            MemoryLayout.structLayout(
                Constants$root.C_LONG_LONG$LAYOUT.withName("g_type")
            ).withName("g_type_class"),
            Constants$root.C_POINTER$LAYOUT.withName("construct_properties"),
            Constants$root.C_POINTER$LAYOUT.withName("constructor"),
            Constants$root.C_POINTER$LAYOUT.withName("set_property"),
            Constants$root.C_POINTER$LAYOUT.withName("get_property"),
            Constants$root.C_POINTER$LAYOUT.withName("dispose"),
            Constants$root.C_POINTER$LAYOUT.withName("finalize"),
            Constants$root.C_POINTER$LAYOUT.withName("dispatch_properties_changed"),
            Constants$root.C_POINTER$LAYOUT.withName("notify"),
            Constants$root.C_POINTER$LAYOUT.withName("constructed"),
            Constants$root.C_LONG_LONG$LAYOUT.withName("flags"),
            MemoryLayout.sequenceLayout(6, Constants$root.C_POINTER$LAYOUT).withName("pdummy")
        ).withName("parent_class"),
        Constants$root.C_POINTER$LAYOUT.withName("startup"),
        Constants$root.C_POINTER$LAYOUT.withName("activate"),
        Constants$root.C_POINTER$LAYOUT.withName("open"),
        Constants$root.C_POINTER$LAYOUT.withName("command_line"),
        Constants$root.C_POINTER$LAYOUT.withName("local_command_line"),
        Constants$root.C_POINTER$LAYOUT.withName("before_emit"),
        Constants$root.C_POINTER$LAYOUT.withName("after_emit"),
        Constants$root.C_POINTER$LAYOUT.withName("add_platform_data"),
        Constants$root.C_POINTER$LAYOUT.withName("quit_mainloop"),
        Constants$root.C_POINTER$LAYOUT.withName("run_mainloop"),
        Constants$root.C_POINTER$LAYOUT.withName("shutdown"),
        Constants$root.C_POINTER$LAYOUT.withName("dbus_register"),
        Constants$root.C_POINTER$LAYOUT.withName("dbus_unregister"),
        Constants$root.C_POINTER$LAYOUT.withName("handle_local_options"),
        Constants$root.C_POINTER$LAYOUT.withName("name_lost"),
        MemoryLayout.sequenceLayout(7, Constants$root.C_POINTER$LAYOUT).withName("padding")
    ).withName("_GApplicationClass");
    public static MemoryLayout $LAYOUT() {
        return _GApplicationClass.$struct$LAYOUT;
    }
    public static MemorySegment parent_class$slice(MemorySegment seg) {
        return seg.asSlice(0, 136);
    }
    static final FunctionDescriptor startup$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle startup$MH = RuntimeHelper.downcallHandle(
        _GApplicationClass.startup$FUNC
    );
    public interface startup {

        void apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(startup fi, MemorySession session) {
            return RuntimeHelper.upcallStub(startup.class, fi, _GApplicationClass.startup$FUNC, session);
        }
        static startup ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    _GApplicationClass.startup$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle startup$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("startup"));
    public static VarHandle startup$VH() {
        return _GApplicationClass.startup$VH;
    }
    public static MemoryAddress startup$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.startup$VH.get(seg);
    }
    public static void startup$set( MemorySegment seg, MemoryAddress x) {
        _GApplicationClass.startup$VH.set(seg, x);
    }
    public static MemoryAddress startup$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.startup$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void startup$set(MemorySegment seg, long index, MemoryAddress x) {
        _GApplicationClass.startup$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static startup startup (MemorySegment segment, MemorySession session) {
        return startup.ofAddress(startup$get(segment), session);
    }
    static final FunctionDescriptor activate$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle activate$MH = RuntimeHelper.downcallHandle(
        _GApplicationClass.activate$FUNC
    );
    public interface activate {

        void apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(activate fi, MemorySession session) {
            return RuntimeHelper.upcallStub(activate.class, fi, _GApplicationClass.activate$FUNC, session);
        }
        static activate ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    _GApplicationClass.activate$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle activate$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("activate"));
    public static VarHandle activate$VH() {
        return _GApplicationClass.activate$VH;
    }
    public static MemoryAddress activate$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.activate$VH.get(seg);
    }
    public static void activate$set( MemorySegment seg, MemoryAddress x) {
        _GApplicationClass.activate$VH.set(seg, x);
    }
    public static MemoryAddress activate$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.activate$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void activate$set(MemorySegment seg, long index, MemoryAddress x) {
        _GApplicationClass.activate$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static activate activate (MemorySegment segment, MemorySession session) {
        return activate.ofAddress(activate$get(segment), session);
    }
    static final FunctionDescriptor open$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle open$MH = RuntimeHelper.downcallHandle(
        _GApplicationClass.open$FUNC
    );
    public interface open {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(open fi, MemorySession session) {
            return RuntimeHelper.upcallStub(open.class, fi, _GApplicationClass.open$FUNC, session);
        }
        static open ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    _GApplicationClass.open$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle open$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("open"));
    public static VarHandle open$VH() {
        return _GApplicationClass.open$VH;
    }
    public static MemoryAddress open$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.open$VH.get(seg);
    }
    public static void open$set( MemorySegment seg, MemoryAddress x) {
        _GApplicationClass.open$VH.set(seg, x);
    }
    public static MemoryAddress open$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.open$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void open$set(MemorySegment seg, long index, MemoryAddress x) {
        _GApplicationClass.open$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static open open (MemorySegment segment, MemorySession session) {
        return open.ofAddress(open$get(segment), session);
    }
    static final FunctionDescriptor command_line$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle command_line$MH = RuntimeHelper.downcallHandle(
        _GApplicationClass.command_line$FUNC
    );
    public interface command_line {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(command_line fi, MemorySession session) {
            return RuntimeHelper.upcallStub(command_line.class, fi, _GApplicationClass.command_line$FUNC, session);
        }
        static command_line ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)_GApplicationClass.command_line$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle command_line$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("command_line"));
    public static VarHandle command_line$VH() {
        return _GApplicationClass.command_line$VH;
    }
    public static MemoryAddress command_line$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.command_line$VH.get(seg);
    }
    public static void command_line$set( MemorySegment seg, MemoryAddress x) {
        _GApplicationClass.command_line$VH.set(seg, x);
    }
    public static MemoryAddress command_line$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.command_line$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void command_line$set(MemorySegment seg, long index, MemoryAddress x) {
        _GApplicationClass.command_line$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static command_line command_line (MemorySegment segment, MemorySession session) {
        return command_line.ofAddress(command_line$get(segment), session);
    }
    static final FunctionDescriptor local_command_line$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle local_command_line$MH = RuntimeHelper.downcallHandle(
        _GApplicationClass.local_command_line$FUNC
    );
    public interface local_command_line {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(local_command_line fi, MemorySession session) {
            return RuntimeHelper.upcallStub(local_command_line.class, fi, _GApplicationClass.local_command_line$FUNC, session);
        }
        static local_command_line ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GApplicationClass.local_command_line$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle local_command_line$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("local_command_line"));
    public static VarHandle local_command_line$VH() {
        return _GApplicationClass.local_command_line$VH;
    }
    public static MemoryAddress local_command_line$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.local_command_line$VH.get(seg);
    }
    public static void local_command_line$set( MemorySegment seg, MemoryAddress x) {
        _GApplicationClass.local_command_line$VH.set(seg, x);
    }
    public static MemoryAddress local_command_line$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.local_command_line$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void local_command_line$set(MemorySegment seg, long index, MemoryAddress x) {
        _GApplicationClass.local_command_line$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static local_command_line local_command_line (MemorySegment segment, MemorySession session) {
        return local_command_line.ofAddress(local_command_line$get(segment), session);
    }
    static final FunctionDescriptor before_emit$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle before_emit$MH = RuntimeHelper.downcallHandle(
        _GApplicationClass.before_emit$FUNC
    );
    public interface before_emit {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(before_emit fi, MemorySession session) {
            return RuntimeHelper.upcallStub(before_emit.class, fi, _GApplicationClass.before_emit$FUNC, session);
        }
        static before_emit ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    _GApplicationClass.before_emit$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle before_emit$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("before_emit"));
    public static VarHandle before_emit$VH() {
        return _GApplicationClass.before_emit$VH;
    }
    public static MemoryAddress before_emit$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.before_emit$VH.get(seg);
    }
    public static void before_emit$set( MemorySegment seg, MemoryAddress x) {
        _GApplicationClass.before_emit$VH.set(seg, x);
    }
    public static MemoryAddress before_emit$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.before_emit$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void before_emit$set(MemorySegment seg, long index, MemoryAddress x) {
        _GApplicationClass.before_emit$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static before_emit before_emit (MemorySegment segment, MemorySession session) {
        return before_emit.ofAddress(before_emit$get(segment), session);
    }
    static final FunctionDescriptor after_emit$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle after_emit$MH = RuntimeHelper.downcallHandle(
        _GApplicationClass.after_emit$FUNC
    );
    public interface after_emit {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(after_emit fi, MemorySession session) {
            return RuntimeHelper.upcallStub(after_emit.class, fi, _GApplicationClass.after_emit$FUNC, session);
        }
        static after_emit ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    _GApplicationClass.after_emit$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle after_emit$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("after_emit"));
    public static VarHandle after_emit$VH() {
        return _GApplicationClass.after_emit$VH;
    }
    public static MemoryAddress after_emit$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.after_emit$VH.get(seg);
    }
    public static void after_emit$set( MemorySegment seg, MemoryAddress x) {
        _GApplicationClass.after_emit$VH.set(seg, x);
    }
    public static MemoryAddress after_emit$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.after_emit$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void after_emit$set(MemorySegment seg, long index, MemoryAddress x) {
        _GApplicationClass.after_emit$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static after_emit after_emit (MemorySegment segment, MemorySession session) {
        return after_emit.ofAddress(after_emit$get(segment), session);
    }
    static final FunctionDescriptor add_platform_data$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle add_platform_data$MH = RuntimeHelper.downcallHandle(
        _GApplicationClass.add_platform_data$FUNC
    );
    public interface add_platform_data {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(add_platform_data fi, MemorySession session) {
            return RuntimeHelper.upcallStub(add_platform_data.class, fi, _GApplicationClass.add_platform_data$FUNC, session);
        }
        static add_platform_data ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    _GApplicationClass.add_platform_data$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle add_platform_data$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("add_platform_data"));
    public static VarHandle add_platform_data$VH() {
        return _GApplicationClass.add_platform_data$VH;
    }
    public static MemoryAddress add_platform_data$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.add_platform_data$VH.get(seg);
    }
    public static void add_platform_data$set( MemorySegment seg, MemoryAddress x) {
        _GApplicationClass.add_platform_data$VH.set(seg, x);
    }
    public static MemoryAddress add_platform_data$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.add_platform_data$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void add_platform_data$set(MemorySegment seg, long index, MemoryAddress x) {
        _GApplicationClass.add_platform_data$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static add_platform_data add_platform_data (MemorySegment segment, MemorySession session) {
        return add_platform_data.ofAddress(add_platform_data$get(segment), session);
    }
    static final FunctionDescriptor quit_mainloop$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle quit_mainloop$MH = RuntimeHelper.downcallHandle(
        _GApplicationClass.quit_mainloop$FUNC
    );
    public interface quit_mainloop {

        void apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(quit_mainloop fi, MemorySession session) {
            return RuntimeHelper.upcallStub(quit_mainloop.class, fi, _GApplicationClass.quit_mainloop$FUNC, session);
        }
        static quit_mainloop ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    _GApplicationClass.quit_mainloop$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle quit_mainloop$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("quit_mainloop"));
    public static VarHandle quit_mainloop$VH() {
        return _GApplicationClass.quit_mainloop$VH;
    }
    public static MemoryAddress quit_mainloop$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.quit_mainloop$VH.get(seg);
    }
    public static void quit_mainloop$set( MemorySegment seg, MemoryAddress x) {
        _GApplicationClass.quit_mainloop$VH.set(seg, x);
    }
    public static MemoryAddress quit_mainloop$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.quit_mainloop$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void quit_mainloop$set(MemorySegment seg, long index, MemoryAddress x) {
        _GApplicationClass.quit_mainloop$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static quit_mainloop quit_mainloop (MemorySegment segment, MemorySession session) {
        return quit_mainloop.ofAddress(quit_mainloop$get(segment), session);
    }
    static final FunctionDescriptor run_mainloop$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle run_mainloop$MH = RuntimeHelper.downcallHandle(
        _GApplicationClass.run_mainloop$FUNC
    );
    public interface run_mainloop {

        void apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(run_mainloop fi, MemorySession session) {
            return RuntimeHelper.upcallStub(run_mainloop.class, fi, _GApplicationClass.run_mainloop$FUNC, session);
        }
        static run_mainloop ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    _GApplicationClass.run_mainloop$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle run_mainloop$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("run_mainloop"));
    public static VarHandle run_mainloop$VH() {
        return _GApplicationClass.run_mainloop$VH;
    }
    public static MemoryAddress run_mainloop$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.run_mainloop$VH.get(seg);
    }
    public static void run_mainloop$set( MemorySegment seg, MemoryAddress x) {
        _GApplicationClass.run_mainloop$VH.set(seg, x);
    }
    public static MemoryAddress run_mainloop$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.run_mainloop$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void run_mainloop$set(MemorySegment seg, long index, MemoryAddress x) {
        _GApplicationClass.run_mainloop$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static run_mainloop run_mainloop (MemorySegment segment, MemorySession session) {
        return run_mainloop.ofAddress(run_mainloop$get(segment), session);
    }
    static final FunctionDescriptor shutdown$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle shutdown$MH = RuntimeHelper.downcallHandle(
        _GApplicationClass.shutdown$FUNC
    );
    public interface shutdown {

        void apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(shutdown fi, MemorySession session) {
            return RuntimeHelper.upcallStub(shutdown.class, fi, _GApplicationClass.shutdown$FUNC, session);
        }
        static shutdown ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    _GApplicationClass.shutdown$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle shutdown$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("shutdown"));
    public static VarHandle shutdown$VH() {
        return _GApplicationClass.shutdown$VH;
    }
    public static MemoryAddress shutdown$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.shutdown$VH.get(seg);
    }
    public static void shutdown$set( MemorySegment seg, MemoryAddress x) {
        _GApplicationClass.shutdown$VH.set(seg, x);
    }
    public static MemoryAddress shutdown$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.shutdown$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void shutdown$set(MemorySegment seg, long index, MemoryAddress x) {
        _GApplicationClass.shutdown$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static shutdown shutdown (MemorySegment segment, MemorySession session) {
        return shutdown.ofAddress(shutdown$get(segment), session);
    }
    static final FunctionDescriptor dbus_register$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle dbus_register$MH = RuntimeHelper.downcallHandle(
        _GApplicationClass.dbus_register$FUNC
    );
    public interface dbus_register {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(dbus_register fi, MemorySession session) {
            return RuntimeHelper.upcallStub(dbus_register.class, fi, _GApplicationClass.dbus_register$FUNC, session);
        }
        static dbus_register ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (int)_GApplicationClass.dbus_register$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle dbus_register$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("dbus_register"));
    public static VarHandle dbus_register$VH() {
        return _GApplicationClass.dbus_register$VH;
    }
    public static MemoryAddress dbus_register$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.dbus_register$VH.get(seg);
    }
    public static void dbus_register$set( MemorySegment seg, MemoryAddress x) {
        _GApplicationClass.dbus_register$VH.set(seg, x);
    }
    public static MemoryAddress dbus_register$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.dbus_register$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void dbus_register$set(MemorySegment seg, long index, MemoryAddress x) {
        _GApplicationClass.dbus_register$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static dbus_register dbus_register (MemorySegment segment, MemorySession session) {
        return dbus_register.ofAddress(dbus_register$get(segment), session);
    }
    static final FunctionDescriptor dbus_unregister$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle dbus_unregister$MH = RuntimeHelper.downcallHandle(
        _GApplicationClass.dbus_unregister$FUNC
    );
    public interface dbus_unregister {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(dbus_unregister fi, MemorySession session) {
            return RuntimeHelper.upcallStub(dbus_unregister.class, fi, _GApplicationClass.dbus_unregister$FUNC, session);
        }
        static dbus_unregister ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    _GApplicationClass.dbus_unregister$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle dbus_unregister$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("dbus_unregister"));
    public static VarHandle dbus_unregister$VH() {
        return _GApplicationClass.dbus_unregister$VH;
    }
    public static MemoryAddress dbus_unregister$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.dbus_unregister$VH.get(seg);
    }
    public static void dbus_unregister$set( MemorySegment seg, MemoryAddress x) {
        _GApplicationClass.dbus_unregister$VH.set(seg, x);
    }
    public static MemoryAddress dbus_unregister$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.dbus_unregister$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void dbus_unregister$set(MemorySegment seg, long index, MemoryAddress x) {
        _GApplicationClass.dbus_unregister$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static dbus_unregister dbus_unregister (MemorySegment segment, MemorySession session) {
        return dbus_unregister.ofAddress(dbus_unregister$get(segment), session);
    }
    static final FunctionDescriptor handle_local_options$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle handle_local_options$MH = RuntimeHelper.downcallHandle(
        _GApplicationClass.handle_local_options$FUNC
    );
    public interface handle_local_options {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(handle_local_options fi, MemorySession session) {
            return RuntimeHelper.upcallStub(handle_local_options.class, fi, _GApplicationClass.handle_local_options$FUNC, session);
        }
        static handle_local_options ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)_GApplicationClass.handle_local_options$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle handle_local_options$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("handle_local_options"));
    public static VarHandle handle_local_options$VH() {
        return _GApplicationClass.handle_local_options$VH;
    }
    public static MemoryAddress handle_local_options$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.handle_local_options$VH.get(seg);
    }
    public static void handle_local_options$set( MemorySegment seg, MemoryAddress x) {
        _GApplicationClass.handle_local_options$VH.set(seg, x);
    }
    public static MemoryAddress handle_local_options$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.handle_local_options$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void handle_local_options$set(MemorySegment seg, long index, MemoryAddress x) {
        _GApplicationClass.handle_local_options$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static handle_local_options handle_local_options (MemorySegment segment, MemorySession session) {
        return handle_local_options.ofAddress(handle_local_options$get(segment), session);
    }
    static final FunctionDescriptor name_lost$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle name_lost$MH = RuntimeHelper.downcallHandle(
        _GApplicationClass.name_lost$FUNC
    );
    public interface name_lost {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(name_lost fi, MemorySession session) {
            return RuntimeHelper.upcallStub(name_lost.class, fi, _GApplicationClass.name_lost$FUNC, session);
        }
        static name_lost ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)_GApplicationClass.name_lost$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle name_lost$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("name_lost"));
    public static VarHandle name_lost$VH() {
        return _GApplicationClass.name_lost$VH;
    }
    public static MemoryAddress name_lost$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.name_lost$VH.get(seg);
    }
    public static void name_lost$set( MemorySegment seg, MemoryAddress x) {
        _GApplicationClass.name_lost$VH.set(seg, x);
    }
    public static MemoryAddress name_lost$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GApplicationClass.name_lost$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void name_lost$set(MemorySegment seg, long index, MemoryAddress x) {
        _GApplicationClass.name_lost$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static name_lost name_lost (MemorySegment segment, MemorySession session) {
        return name_lost.ofAddress(name_lost$get(segment), session);
    }
    public static MemorySegment padding$slice(MemorySegment seg) {
        return seg.asSlice(256, 56);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }
}


