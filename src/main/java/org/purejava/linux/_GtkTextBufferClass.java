// Generated by jextract

package org.purejava.linux;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
public class _GtkTextBufferClass {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        MemoryLayout.structLayout(
            MemoryLayout.structLayout(
                Constants$root.C_LONG_LONG$LAYOUT.withName("g_type")
            ).withName("g_type_class"),
            Constants$root.C_POINTER$LAYOUT.withName("construct_properties"),
            Constants$root.C_POINTER$LAYOUT.withName("constructor"),
            Constants$root.C_POINTER$LAYOUT.withName("set_property"),
            Constants$root.C_POINTER$LAYOUT.withName("get_property"),
            Constants$root.C_POINTER$LAYOUT.withName("dispose"),
            Constants$root.C_POINTER$LAYOUT.withName("finalize"),
            Constants$root.C_POINTER$LAYOUT.withName("dispatch_properties_changed"),
            Constants$root.C_POINTER$LAYOUT.withName("notify"),
            Constants$root.C_POINTER$LAYOUT.withName("constructed"),
            Constants$root.C_LONG_LONG$LAYOUT.withName("flags"),
            MemoryLayout.sequenceLayout(6, Constants$root.C_POINTER$LAYOUT).withName("pdummy")
        ).withName("parent_class"),
        Constants$root.C_POINTER$LAYOUT.withName("insert_text"),
        Constants$root.C_POINTER$LAYOUT.withName("insert_pixbuf"),
        Constants$root.C_POINTER$LAYOUT.withName("insert_child_anchor"),
        Constants$root.C_POINTER$LAYOUT.withName("delete_range"),
        Constants$root.C_POINTER$LAYOUT.withName("changed"),
        Constants$root.C_POINTER$LAYOUT.withName("modified_changed"),
        Constants$root.C_POINTER$LAYOUT.withName("mark_set"),
        Constants$root.C_POINTER$LAYOUT.withName("mark_deleted"),
        Constants$root.C_POINTER$LAYOUT.withName("apply_tag"),
        Constants$root.C_POINTER$LAYOUT.withName("remove_tag"),
        Constants$root.C_POINTER$LAYOUT.withName("begin_user_action"),
        Constants$root.C_POINTER$LAYOUT.withName("end_user_action"),
        Constants$root.C_POINTER$LAYOUT.withName("paste_done"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved1"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved2"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved3"),
        Constants$root.C_POINTER$LAYOUT.withName("_gtk_reserved4")
    ).withName("_GtkTextBufferClass");
    public static MemoryLayout $LAYOUT() {
        return _GtkTextBufferClass.$struct$LAYOUT;
    }
    public static MemorySegment parent_class$slice(MemorySegment seg) {
        return seg.asSlice(0, 136);
    }
    static final FunctionDescriptor insert_text$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle insert_text$MH = RuntimeHelper.downcallHandle(
        _GtkTextBufferClass.insert_text$FUNC
    );
    public interface insert_text {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, int _x3);
        static MemorySegment allocate(insert_text fi, MemorySession session) {
            return RuntimeHelper.upcallStub(insert_text.class, fi, _GtkTextBufferClass.insert_text$FUNC, session);
        }
        static insert_text ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, int __x3) -> {
                try {
                    _GtkTextBufferClass.insert_text$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle insert_text$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("insert_text"));
    public static VarHandle insert_text$VH() {
        return _GtkTextBufferClass.insert_text$VH;
    }
    public static MemoryAddress insert_text$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.insert_text$VH.get(seg);
    }
    public static void insert_text$set( MemorySegment seg, MemoryAddress x) {
        _GtkTextBufferClass.insert_text$VH.set(seg, x);
    }
    public static MemoryAddress insert_text$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.insert_text$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void insert_text$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkTextBufferClass.insert_text$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static insert_text insert_text (MemorySegment segment, MemorySession session) {
        return insert_text.ofAddress(insert_text$get(segment), session);
    }
    static final FunctionDescriptor insert_pixbuf$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle insert_pixbuf$MH = RuntimeHelper.downcallHandle(
        _GtkTextBufferClass.insert_pixbuf$FUNC
    );
    public interface insert_pixbuf {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(insert_pixbuf fi, MemorySession session) {
            return RuntimeHelper.upcallStub(insert_pixbuf.class, fi, _GtkTextBufferClass.insert_pixbuf$FUNC, session);
        }
        static insert_pixbuf ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    _GtkTextBufferClass.insert_pixbuf$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle insert_pixbuf$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("insert_pixbuf"));
    public static VarHandle insert_pixbuf$VH() {
        return _GtkTextBufferClass.insert_pixbuf$VH;
    }
    public static MemoryAddress insert_pixbuf$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.insert_pixbuf$VH.get(seg);
    }
    public static void insert_pixbuf$set( MemorySegment seg, MemoryAddress x) {
        _GtkTextBufferClass.insert_pixbuf$VH.set(seg, x);
    }
    public static MemoryAddress insert_pixbuf$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.insert_pixbuf$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void insert_pixbuf$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkTextBufferClass.insert_pixbuf$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static insert_pixbuf insert_pixbuf (MemorySegment segment, MemorySession session) {
        return insert_pixbuf.ofAddress(insert_pixbuf$get(segment), session);
    }
    static final FunctionDescriptor insert_child_anchor$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle insert_child_anchor$MH = RuntimeHelper.downcallHandle(
        _GtkTextBufferClass.insert_child_anchor$FUNC
    );
    public interface insert_child_anchor {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(insert_child_anchor fi, MemorySession session) {
            return RuntimeHelper.upcallStub(insert_child_anchor.class, fi, _GtkTextBufferClass.insert_child_anchor$FUNC, session);
        }
        static insert_child_anchor ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    _GtkTextBufferClass.insert_child_anchor$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle insert_child_anchor$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("insert_child_anchor"));
    public static VarHandle insert_child_anchor$VH() {
        return _GtkTextBufferClass.insert_child_anchor$VH;
    }
    public static MemoryAddress insert_child_anchor$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.insert_child_anchor$VH.get(seg);
    }
    public static void insert_child_anchor$set( MemorySegment seg, MemoryAddress x) {
        _GtkTextBufferClass.insert_child_anchor$VH.set(seg, x);
    }
    public static MemoryAddress insert_child_anchor$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.insert_child_anchor$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void insert_child_anchor$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkTextBufferClass.insert_child_anchor$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static insert_child_anchor insert_child_anchor (MemorySegment segment, MemorySession session) {
        return insert_child_anchor.ofAddress(insert_child_anchor$get(segment), session);
    }
    static final FunctionDescriptor delete_range$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle delete_range$MH = RuntimeHelper.downcallHandle(
        _GtkTextBufferClass.delete_range$FUNC
    );
    public interface delete_range {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(delete_range fi, MemorySession session) {
            return RuntimeHelper.upcallStub(delete_range.class, fi, _GtkTextBufferClass.delete_range$FUNC, session);
        }
        static delete_range ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    _GtkTextBufferClass.delete_range$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle delete_range$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("delete_range"));
    public static VarHandle delete_range$VH() {
        return _GtkTextBufferClass.delete_range$VH;
    }
    public static MemoryAddress delete_range$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.delete_range$VH.get(seg);
    }
    public static void delete_range$set( MemorySegment seg, MemoryAddress x) {
        _GtkTextBufferClass.delete_range$VH.set(seg, x);
    }
    public static MemoryAddress delete_range$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.delete_range$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void delete_range$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkTextBufferClass.delete_range$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static delete_range delete_range (MemorySegment segment, MemorySession session) {
        return delete_range.ofAddress(delete_range$get(segment), session);
    }
    static final FunctionDescriptor changed$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle changed$MH = RuntimeHelper.downcallHandle(
        _GtkTextBufferClass.changed$FUNC
    );
    public interface changed {

        void apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(changed fi, MemorySession session) {
            return RuntimeHelper.upcallStub(changed.class, fi, _GtkTextBufferClass.changed$FUNC, session);
        }
        static changed ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    _GtkTextBufferClass.changed$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle changed$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("changed"));
    public static VarHandle changed$VH() {
        return _GtkTextBufferClass.changed$VH;
    }
    public static MemoryAddress changed$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.changed$VH.get(seg);
    }
    public static void changed$set( MemorySegment seg, MemoryAddress x) {
        _GtkTextBufferClass.changed$VH.set(seg, x);
    }
    public static MemoryAddress changed$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.changed$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void changed$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkTextBufferClass.changed$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static changed changed (MemorySegment segment, MemorySession session) {
        return changed.ofAddress(changed$get(segment), session);
    }
    static final FunctionDescriptor modified_changed$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle modified_changed$MH = RuntimeHelper.downcallHandle(
        _GtkTextBufferClass.modified_changed$FUNC
    );
    public interface modified_changed {

        void apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(modified_changed fi, MemorySession session) {
            return RuntimeHelper.upcallStub(modified_changed.class, fi, _GtkTextBufferClass.modified_changed$FUNC, session);
        }
        static modified_changed ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    _GtkTextBufferClass.modified_changed$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle modified_changed$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("modified_changed"));
    public static VarHandle modified_changed$VH() {
        return _GtkTextBufferClass.modified_changed$VH;
    }
    public static MemoryAddress modified_changed$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.modified_changed$VH.get(seg);
    }
    public static void modified_changed$set( MemorySegment seg, MemoryAddress x) {
        _GtkTextBufferClass.modified_changed$VH.set(seg, x);
    }
    public static MemoryAddress modified_changed$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.modified_changed$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void modified_changed$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkTextBufferClass.modified_changed$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static modified_changed modified_changed (MemorySegment segment, MemorySession session) {
        return modified_changed.ofAddress(modified_changed$get(segment), session);
    }
    static final FunctionDescriptor mark_set$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle mark_set$MH = RuntimeHelper.downcallHandle(
        _GtkTextBufferClass.mark_set$FUNC
    );
    public interface mark_set {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(mark_set fi, MemorySession session) {
            return RuntimeHelper.upcallStub(mark_set.class, fi, _GtkTextBufferClass.mark_set$FUNC, session);
        }
        static mark_set ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    _GtkTextBufferClass.mark_set$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle mark_set$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("mark_set"));
    public static VarHandle mark_set$VH() {
        return _GtkTextBufferClass.mark_set$VH;
    }
    public static MemoryAddress mark_set$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.mark_set$VH.get(seg);
    }
    public static void mark_set$set( MemorySegment seg, MemoryAddress x) {
        _GtkTextBufferClass.mark_set$VH.set(seg, x);
    }
    public static MemoryAddress mark_set$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.mark_set$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void mark_set$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkTextBufferClass.mark_set$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static mark_set mark_set (MemorySegment segment, MemorySession session) {
        return mark_set.ofAddress(mark_set$get(segment), session);
    }
    static final FunctionDescriptor mark_deleted$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle mark_deleted$MH = RuntimeHelper.downcallHandle(
        _GtkTextBufferClass.mark_deleted$FUNC
    );
    public interface mark_deleted {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(mark_deleted fi, MemorySession session) {
            return RuntimeHelper.upcallStub(mark_deleted.class, fi, _GtkTextBufferClass.mark_deleted$FUNC, session);
        }
        static mark_deleted ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    _GtkTextBufferClass.mark_deleted$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle mark_deleted$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("mark_deleted"));
    public static VarHandle mark_deleted$VH() {
        return _GtkTextBufferClass.mark_deleted$VH;
    }
    public static MemoryAddress mark_deleted$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.mark_deleted$VH.get(seg);
    }
    public static void mark_deleted$set( MemorySegment seg, MemoryAddress x) {
        _GtkTextBufferClass.mark_deleted$VH.set(seg, x);
    }
    public static MemoryAddress mark_deleted$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.mark_deleted$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void mark_deleted$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkTextBufferClass.mark_deleted$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static mark_deleted mark_deleted (MemorySegment segment, MemorySession session) {
        return mark_deleted.ofAddress(mark_deleted$get(segment), session);
    }
    static final FunctionDescriptor apply_tag$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle apply_tag$MH = RuntimeHelper.downcallHandle(
        _GtkTextBufferClass.apply_tag$FUNC
    );
    public interface apply_tag {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(apply_tag fi, MemorySession session) {
            return RuntimeHelper.upcallStub(apply_tag.class, fi, _GtkTextBufferClass.apply_tag$FUNC, session);
        }
        static apply_tag ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    _GtkTextBufferClass.apply_tag$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle apply_tag$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("apply_tag"));
    public static VarHandle apply_tag$VH() {
        return _GtkTextBufferClass.apply_tag$VH;
    }
    public static MemoryAddress apply_tag$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.apply_tag$VH.get(seg);
    }
    public static void apply_tag$set( MemorySegment seg, MemoryAddress x) {
        _GtkTextBufferClass.apply_tag$VH.set(seg, x);
    }
    public static MemoryAddress apply_tag$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.apply_tag$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void apply_tag$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkTextBufferClass.apply_tag$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static apply_tag apply_tag (MemorySegment segment, MemorySession session) {
        return apply_tag.ofAddress(apply_tag$get(segment), session);
    }
    static final FunctionDescriptor remove_tag$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle remove_tag$MH = RuntimeHelper.downcallHandle(
        _GtkTextBufferClass.remove_tag$FUNC
    );
    public interface remove_tag {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(remove_tag fi, MemorySession session) {
            return RuntimeHelper.upcallStub(remove_tag.class, fi, _GtkTextBufferClass.remove_tag$FUNC, session);
        }
        static remove_tag ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    _GtkTextBufferClass.remove_tag$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle remove_tag$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("remove_tag"));
    public static VarHandle remove_tag$VH() {
        return _GtkTextBufferClass.remove_tag$VH;
    }
    public static MemoryAddress remove_tag$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.remove_tag$VH.get(seg);
    }
    public static void remove_tag$set( MemorySegment seg, MemoryAddress x) {
        _GtkTextBufferClass.remove_tag$VH.set(seg, x);
    }
    public static MemoryAddress remove_tag$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.remove_tag$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void remove_tag$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkTextBufferClass.remove_tag$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static remove_tag remove_tag (MemorySegment segment, MemorySession session) {
        return remove_tag.ofAddress(remove_tag$get(segment), session);
    }
    static final FunctionDescriptor begin_user_action$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle begin_user_action$MH = RuntimeHelper.downcallHandle(
        _GtkTextBufferClass.begin_user_action$FUNC
    );
    public interface begin_user_action {

        void apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(begin_user_action fi, MemorySession session) {
            return RuntimeHelper.upcallStub(begin_user_action.class, fi, _GtkTextBufferClass.begin_user_action$FUNC, session);
        }
        static begin_user_action ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    _GtkTextBufferClass.begin_user_action$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle begin_user_action$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("begin_user_action"));
    public static VarHandle begin_user_action$VH() {
        return _GtkTextBufferClass.begin_user_action$VH;
    }
    public static MemoryAddress begin_user_action$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.begin_user_action$VH.get(seg);
    }
    public static void begin_user_action$set( MemorySegment seg, MemoryAddress x) {
        _GtkTextBufferClass.begin_user_action$VH.set(seg, x);
    }
    public static MemoryAddress begin_user_action$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.begin_user_action$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void begin_user_action$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkTextBufferClass.begin_user_action$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static begin_user_action begin_user_action (MemorySegment segment, MemorySession session) {
        return begin_user_action.ofAddress(begin_user_action$get(segment), session);
    }
    static final FunctionDescriptor end_user_action$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle end_user_action$MH = RuntimeHelper.downcallHandle(
        _GtkTextBufferClass.end_user_action$FUNC
    );
    public interface end_user_action {

        void apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(end_user_action fi, MemorySession session) {
            return RuntimeHelper.upcallStub(end_user_action.class, fi, _GtkTextBufferClass.end_user_action$FUNC, session);
        }
        static end_user_action ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    _GtkTextBufferClass.end_user_action$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle end_user_action$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("end_user_action"));
    public static VarHandle end_user_action$VH() {
        return _GtkTextBufferClass.end_user_action$VH;
    }
    public static MemoryAddress end_user_action$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.end_user_action$VH.get(seg);
    }
    public static void end_user_action$set( MemorySegment seg, MemoryAddress x) {
        _GtkTextBufferClass.end_user_action$VH.set(seg, x);
    }
    public static MemoryAddress end_user_action$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.end_user_action$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void end_user_action$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkTextBufferClass.end_user_action$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static end_user_action end_user_action (MemorySegment segment, MemorySession session) {
        return end_user_action.ofAddress(end_user_action$get(segment), session);
    }
    static final FunctionDescriptor paste_done$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle paste_done$MH = RuntimeHelper.downcallHandle(
        _GtkTextBufferClass.paste_done$FUNC
    );
    public interface paste_done {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(paste_done fi, MemorySession session) {
            return RuntimeHelper.upcallStub(paste_done.class, fi, _GtkTextBufferClass.paste_done$FUNC, session);
        }
        static paste_done ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    _GtkTextBufferClass.paste_done$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle paste_done$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("paste_done"));
    public static VarHandle paste_done$VH() {
        return _GtkTextBufferClass.paste_done$VH;
    }
    public static MemoryAddress paste_done$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.paste_done$VH.get(seg);
    }
    public static void paste_done$set( MemorySegment seg, MemoryAddress x) {
        _GtkTextBufferClass.paste_done$VH.set(seg, x);
    }
    public static MemoryAddress paste_done$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass.paste_done$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void paste_done$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkTextBufferClass.paste_done$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static paste_done paste_done (MemorySegment segment, MemorySession session) {
        return paste_done.ofAddress(paste_done$get(segment), session);
    }
    static final FunctionDescriptor _gtk_reserved1$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved1$MH = RuntimeHelper.downcallHandle(
        _GtkTextBufferClass._gtk_reserved1$FUNC
    );
    public interface _gtk_reserved1 {

        void apply();
        static MemorySegment allocate(_gtk_reserved1 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_gtk_reserved1.class, fi, _GtkTextBufferClass._gtk_reserved1$FUNC, session);
        }
        static _gtk_reserved1 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GtkTextBufferClass._gtk_reserved1$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved1$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved1"));
    public static VarHandle _gtk_reserved1$VH() {
        return _GtkTextBufferClass._gtk_reserved1$VH;
    }
    public static MemoryAddress _gtk_reserved1$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass._gtk_reserved1$VH.get(seg);
    }
    public static void _gtk_reserved1$set( MemorySegment seg, MemoryAddress x) {
        _GtkTextBufferClass._gtk_reserved1$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved1$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass._gtk_reserved1$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved1$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkTextBufferClass._gtk_reserved1$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved1 _gtk_reserved1 (MemorySegment segment, MemorySession session) {
        return _gtk_reserved1.ofAddress(_gtk_reserved1$get(segment), session);
    }
    static final FunctionDescriptor _gtk_reserved2$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved2$MH = RuntimeHelper.downcallHandle(
        _GtkTextBufferClass._gtk_reserved2$FUNC
    );
    public interface _gtk_reserved2 {

        void apply();
        static MemorySegment allocate(_gtk_reserved2 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_gtk_reserved2.class, fi, _GtkTextBufferClass._gtk_reserved2$FUNC, session);
        }
        static _gtk_reserved2 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GtkTextBufferClass._gtk_reserved2$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved2$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved2"));
    public static VarHandle _gtk_reserved2$VH() {
        return _GtkTextBufferClass._gtk_reserved2$VH;
    }
    public static MemoryAddress _gtk_reserved2$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass._gtk_reserved2$VH.get(seg);
    }
    public static void _gtk_reserved2$set( MemorySegment seg, MemoryAddress x) {
        _GtkTextBufferClass._gtk_reserved2$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved2$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass._gtk_reserved2$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved2$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkTextBufferClass._gtk_reserved2$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved2 _gtk_reserved2 (MemorySegment segment, MemorySession session) {
        return _gtk_reserved2.ofAddress(_gtk_reserved2$get(segment), session);
    }
    static final FunctionDescriptor _gtk_reserved3$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved3$MH = RuntimeHelper.downcallHandle(
        _GtkTextBufferClass._gtk_reserved3$FUNC
    );
    public interface _gtk_reserved3 {

        void apply();
        static MemorySegment allocate(_gtk_reserved3 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_gtk_reserved3.class, fi, _GtkTextBufferClass._gtk_reserved3$FUNC, session);
        }
        static _gtk_reserved3 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GtkTextBufferClass._gtk_reserved3$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved3$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved3"));
    public static VarHandle _gtk_reserved3$VH() {
        return _GtkTextBufferClass._gtk_reserved3$VH;
    }
    public static MemoryAddress _gtk_reserved3$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass._gtk_reserved3$VH.get(seg);
    }
    public static void _gtk_reserved3$set( MemorySegment seg, MemoryAddress x) {
        _GtkTextBufferClass._gtk_reserved3$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved3$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass._gtk_reserved3$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved3$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkTextBufferClass._gtk_reserved3$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved3 _gtk_reserved3 (MemorySegment segment, MemorySession session) {
        return _gtk_reserved3.ofAddress(_gtk_reserved3$get(segment), session);
    }
    static final FunctionDescriptor _gtk_reserved4$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _gtk_reserved4$MH = RuntimeHelper.downcallHandle(
        _GtkTextBufferClass._gtk_reserved4$FUNC
    );
    public interface _gtk_reserved4 {

        void apply();
        static MemorySegment allocate(_gtk_reserved4 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_gtk_reserved4.class, fi, _GtkTextBufferClass._gtk_reserved4$FUNC, session);
        }
        static _gtk_reserved4 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _GtkTextBufferClass._gtk_reserved4$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _gtk_reserved4$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_gtk_reserved4"));
    public static VarHandle _gtk_reserved4$VH() {
        return _GtkTextBufferClass._gtk_reserved4$VH;
    }
    public static MemoryAddress _gtk_reserved4$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass._gtk_reserved4$VH.get(seg);
    }
    public static void _gtk_reserved4$set( MemorySegment seg, MemoryAddress x) {
        _GtkTextBufferClass._gtk_reserved4$VH.set(seg, x);
    }
    public static MemoryAddress _gtk_reserved4$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GtkTextBufferClass._gtk_reserved4$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _gtk_reserved4$set(MemorySegment seg, long index, MemoryAddress x) {
        _GtkTextBufferClass._gtk_reserved4$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _gtk_reserved4 _gtk_reserved4 (MemorySegment segment, MemorySession session) {
        return _gtk_reserved4.ofAddress(_gtk_reserved4$get(segment), session);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }
}


