// Generated by jextract

package org.purejava.linux;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
public class _GAppInfoIface {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        MemoryLayout.structLayout(
            Constants$root.C_LONG_LONG$LAYOUT.withName("g_type"),
            Constants$root.C_LONG_LONG$LAYOUT.withName("g_instance_type")
        ).withName("g_iface"),
        Constants$root.C_POINTER$LAYOUT.withName("dup"),
        Constants$root.C_POINTER$LAYOUT.withName("equal"),
        Constants$root.C_POINTER$LAYOUT.withName("get_id"),
        Constants$root.C_POINTER$LAYOUT.withName("get_name"),
        Constants$root.C_POINTER$LAYOUT.withName("get_description"),
        Constants$root.C_POINTER$LAYOUT.withName("get_executable"),
        Constants$root.C_POINTER$LAYOUT.withName("get_icon"),
        Constants$root.C_POINTER$LAYOUT.withName("launch"),
        Constants$root.C_POINTER$LAYOUT.withName("supports_uris"),
        Constants$root.C_POINTER$LAYOUT.withName("supports_files"),
        Constants$root.C_POINTER$LAYOUT.withName("launch_uris"),
        Constants$root.C_POINTER$LAYOUT.withName("should_show"),
        Constants$root.C_POINTER$LAYOUT.withName("set_as_default_for_type"),
        Constants$root.C_POINTER$LAYOUT.withName("set_as_default_for_extension"),
        Constants$root.C_POINTER$LAYOUT.withName("add_supports_type"),
        Constants$root.C_POINTER$LAYOUT.withName("can_remove_supports_type"),
        Constants$root.C_POINTER$LAYOUT.withName("remove_supports_type"),
        Constants$root.C_POINTER$LAYOUT.withName("can_delete"),
        Constants$root.C_POINTER$LAYOUT.withName("do_delete"),
        Constants$root.C_POINTER$LAYOUT.withName("get_commandline"),
        Constants$root.C_POINTER$LAYOUT.withName("get_display_name"),
        Constants$root.C_POINTER$LAYOUT.withName("set_as_last_used_for_type"),
        Constants$root.C_POINTER$LAYOUT.withName("get_supported_types"),
        Constants$root.C_POINTER$LAYOUT.withName("launch_uris_async"),
        Constants$root.C_POINTER$LAYOUT.withName("launch_uris_finish")
    ).withName("_GAppInfoIface");
    public static MemoryLayout $LAYOUT() {
        return _GAppInfoIface.$struct$LAYOUT;
    }
    public static MemorySegment g_iface$slice(MemorySegment seg) {
        return seg.asSlice(0, 16);
    }
    static final FunctionDescriptor dup$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle dup$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.dup$FUNC
    );
    public interface dup {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(dup fi, MemorySession session) {
            return RuntimeHelper.upcallStub(dup.class, fi, _GAppInfoIface.dup$FUNC, session);
        }
        static dup ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GAppInfoIface.dup$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle dup$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("dup"));
    public static VarHandle dup$VH() {
        return _GAppInfoIface.dup$VH;
    }
    public static MemoryAddress dup$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.dup$VH.get(seg);
    }
    public static void dup$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.dup$VH.set(seg, x);
    }
    public static MemoryAddress dup$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.dup$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void dup$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.dup$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static dup dup (MemorySegment segment, MemorySession session) {
        return dup.ofAddress(dup$get(segment), session);
    }
    static final FunctionDescriptor equal$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle equal$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.equal$FUNC
    );
    public interface equal {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(equal fi, MemorySession session) {
            return RuntimeHelper.upcallStub(equal.class, fi, _GAppInfoIface.equal$FUNC, session);
        }
        static equal ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)_GAppInfoIface.equal$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle equal$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("equal"));
    public static VarHandle equal$VH() {
        return _GAppInfoIface.equal$VH;
    }
    public static MemoryAddress equal$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.equal$VH.get(seg);
    }
    public static void equal$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.equal$VH.set(seg, x);
    }
    public static MemoryAddress equal$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.equal$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void equal$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.equal$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static equal equal (MemorySegment segment, MemorySession session) {
        return equal.ofAddress(equal$get(segment), session);
    }
    static final FunctionDescriptor get_id$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_id$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.get_id$FUNC
    );
    public interface get_id {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(get_id fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_id.class, fi, _GAppInfoIface.get_id$FUNC, session);
        }
        static get_id ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GAppInfoIface.get_id$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_id$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_id"));
    public static VarHandle get_id$VH() {
        return _GAppInfoIface.get_id$VH;
    }
    public static MemoryAddress get_id$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.get_id$VH.get(seg);
    }
    public static void get_id$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.get_id$VH.set(seg, x);
    }
    public static MemoryAddress get_id$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.get_id$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_id$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.get_id$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_id get_id (MemorySegment segment, MemorySession session) {
        return get_id.ofAddress(get_id$get(segment), session);
    }
    static final FunctionDescriptor get_name$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_name$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.get_name$FUNC
    );
    public interface get_name {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(get_name fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_name.class, fi, _GAppInfoIface.get_name$FUNC, session);
        }
        static get_name ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GAppInfoIface.get_name$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_name$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_name"));
    public static VarHandle get_name$VH() {
        return _GAppInfoIface.get_name$VH;
    }
    public static MemoryAddress get_name$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.get_name$VH.get(seg);
    }
    public static void get_name$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.get_name$VH.set(seg, x);
    }
    public static MemoryAddress get_name$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.get_name$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_name$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.get_name$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_name get_name (MemorySegment segment, MemorySession session) {
        return get_name.ofAddress(get_name$get(segment), session);
    }
    static final FunctionDescriptor get_description$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_description$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.get_description$FUNC
    );
    public interface get_description {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(get_description fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_description.class, fi, _GAppInfoIface.get_description$FUNC, session);
        }
        static get_description ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GAppInfoIface.get_description$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_description$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_description"));
    public static VarHandle get_description$VH() {
        return _GAppInfoIface.get_description$VH;
    }
    public static MemoryAddress get_description$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.get_description$VH.get(seg);
    }
    public static void get_description$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.get_description$VH.set(seg, x);
    }
    public static MemoryAddress get_description$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.get_description$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_description$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.get_description$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_description get_description (MemorySegment segment, MemorySession session) {
        return get_description.ofAddress(get_description$get(segment), session);
    }
    static final FunctionDescriptor get_executable$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_executable$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.get_executable$FUNC
    );
    public interface get_executable {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(get_executable fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_executable.class, fi, _GAppInfoIface.get_executable$FUNC, session);
        }
        static get_executable ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GAppInfoIface.get_executable$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_executable$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_executable"));
    public static VarHandle get_executable$VH() {
        return _GAppInfoIface.get_executable$VH;
    }
    public static MemoryAddress get_executable$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.get_executable$VH.get(seg);
    }
    public static void get_executable$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.get_executable$VH.set(seg, x);
    }
    public static MemoryAddress get_executable$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.get_executable$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_executable$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.get_executable$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_executable get_executable (MemorySegment segment, MemorySession session) {
        return get_executable.ofAddress(get_executable$get(segment), session);
    }
    static final FunctionDescriptor get_icon$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_icon$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.get_icon$FUNC
    );
    public interface get_icon {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(get_icon fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_icon.class, fi, _GAppInfoIface.get_icon$FUNC, session);
        }
        static get_icon ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GAppInfoIface.get_icon$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_icon$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_icon"));
    public static VarHandle get_icon$VH() {
        return _GAppInfoIface.get_icon$VH;
    }
    public static MemoryAddress get_icon$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.get_icon$VH.get(seg);
    }
    public static void get_icon$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.get_icon$VH.set(seg, x);
    }
    public static MemoryAddress get_icon$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.get_icon$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_icon$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.get_icon$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_icon get_icon (MemorySegment segment, MemorySession session) {
        return get_icon.ofAddress(get_icon$get(segment), session);
    }
    static final FunctionDescriptor launch$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle launch$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.launch$FUNC
    );
    public interface launch {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(launch fi, MemorySession session) {
            return RuntimeHelper.upcallStub(launch.class, fi, _GAppInfoIface.launch$FUNC, session);
        }
        static launch ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (int)_GAppInfoIface.launch$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle launch$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("launch"));
    public static VarHandle launch$VH() {
        return _GAppInfoIface.launch$VH;
    }
    public static MemoryAddress launch$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.launch$VH.get(seg);
    }
    public static void launch$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.launch$VH.set(seg, x);
    }
    public static MemoryAddress launch$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.launch$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void launch$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.launch$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static launch launch (MemorySegment segment, MemorySession session) {
        return launch.ofAddress(launch$get(segment), session);
    }
    static final FunctionDescriptor supports_uris$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle supports_uris$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.supports_uris$FUNC
    );
    public interface supports_uris {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(supports_uris fi, MemorySession session) {
            return RuntimeHelper.upcallStub(supports_uris.class, fi, _GAppInfoIface.supports_uris$FUNC, session);
        }
        static supports_uris ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)_GAppInfoIface.supports_uris$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle supports_uris$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("supports_uris"));
    public static VarHandle supports_uris$VH() {
        return _GAppInfoIface.supports_uris$VH;
    }
    public static MemoryAddress supports_uris$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.supports_uris$VH.get(seg);
    }
    public static void supports_uris$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.supports_uris$VH.set(seg, x);
    }
    public static MemoryAddress supports_uris$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.supports_uris$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void supports_uris$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.supports_uris$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static supports_uris supports_uris (MemorySegment segment, MemorySession session) {
        return supports_uris.ofAddress(supports_uris$get(segment), session);
    }
    static final FunctionDescriptor supports_files$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle supports_files$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.supports_files$FUNC
    );
    public interface supports_files {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(supports_files fi, MemorySession session) {
            return RuntimeHelper.upcallStub(supports_files.class, fi, _GAppInfoIface.supports_files$FUNC, session);
        }
        static supports_files ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)_GAppInfoIface.supports_files$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle supports_files$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("supports_files"));
    public static VarHandle supports_files$VH() {
        return _GAppInfoIface.supports_files$VH;
    }
    public static MemoryAddress supports_files$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.supports_files$VH.get(seg);
    }
    public static void supports_files$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.supports_files$VH.set(seg, x);
    }
    public static MemoryAddress supports_files$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.supports_files$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void supports_files$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.supports_files$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static supports_files supports_files (MemorySegment segment, MemorySession session) {
        return supports_files.ofAddress(supports_files$get(segment), session);
    }
    static final FunctionDescriptor launch_uris$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle launch_uris$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.launch_uris$FUNC
    );
    public interface launch_uris {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(launch_uris fi, MemorySession session) {
            return RuntimeHelper.upcallStub(launch_uris.class, fi, _GAppInfoIface.launch_uris$FUNC, session);
        }
        static launch_uris ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (int)_GAppInfoIface.launch_uris$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle launch_uris$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("launch_uris"));
    public static VarHandle launch_uris$VH() {
        return _GAppInfoIface.launch_uris$VH;
    }
    public static MemoryAddress launch_uris$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.launch_uris$VH.get(seg);
    }
    public static void launch_uris$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.launch_uris$VH.set(seg, x);
    }
    public static MemoryAddress launch_uris$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.launch_uris$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void launch_uris$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.launch_uris$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static launch_uris launch_uris (MemorySegment segment, MemorySession session) {
        return launch_uris.ofAddress(launch_uris$get(segment), session);
    }
    static final FunctionDescriptor should_show$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle should_show$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.should_show$FUNC
    );
    public interface should_show {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(should_show fi, MemorySession session) {
            return RuntimeHelper.upcallStub(should_show.class, fi, _GAppInfoIface.should_show$FUNC, session);
        }
        static should_show ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)_GAppInfoIface.should_show$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle should_show$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("should_show"));
    public static VarHandle should_show$VH() {
        return _GAppInfoIface.should_show$VH;
    }
    public static MemoryAddress should_show$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.should_show$VH.get(seg);
    }
    public static void should_show$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.should_show$VH.set(seg, x);
    }
    public static MemoryAddress should_show$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.should_show$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void should_show$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.should_show$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static should_show should_show (MemorySegment segment, MemorySession session) {
        return should_show.ofAddress(should_show$get(segment), session);
    }
    static final FunctionDescriptor set_as_default_for_type$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle set_as_default_for_type$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.set_as_default_for_type$FUNC
    );
    public interface set_as_default_for_type {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(set_as_default_for_type fi, MemorySession session) {
            return RuntimeHelper.upcallStub(set_as_default_for_type.class, fi, _GAppInfoIface.set_as_default_for_type$FUNC, session);
        }
        static set_as_default_for_type ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GAppInfoIface.set_as_default_for_type$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle set_as_default_for_type$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("set_as_default_for_type"));
    public static VarHandle set_as_default_for_type$VH() {
        return _GAppInfoIface.set_as_default_for_type$VH;
    }
    public static MemoryAddress set_as_default_for_type$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.set_as_default_for_type$VH.get(seg);
    }
    public static void set_as_default_for_type$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.set_as_default_for_type$VH.set(seg, x);
    }
    public static MemoryAddress set_as_default_for_type$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.set_as_default_for_type$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void set_as_default_for_type$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.set_as_default_for_type$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static set_as_default_for_type set_as_default_for_type (MemorySegment segment, MemorySession session) {
        return set_as_default_for_type.ofAddress(set_as_default_for_type$get(segment), session);
    }
    static final FunctionDescriptor set_as_default_for_extension$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle set_as_default_for_extension$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.set_as_default_for_extension$FUNC
    );
    public interface set_as_default_for_extension {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(set_as_default_for_extension fi, MemorySession session) {
            return RuntimeHelper.upcallStub(set_as_default_for_extension.class, fi, _GAppInfoIface.set_as_default_for_extension$FUNC, session);
        }
        static set_as_default_for_extension ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GAppInfoIface.set_as_default_for_extension$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle set_as_default_for_extension$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("set_as_default_for_extension"));
    public static VarHandle set_as_default_for_extension$VH() {
        return _GAppInfoIface.set_as_default_for_extension$VH;
    }
    public static MemoryAddress set_as_default_for_extension$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.set_as_default_for_extension$VH.get(seg);
    }
    public static void set_as_default_for_extension$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.set_as_default_for_extension$VH.set(seg, x);
    }
    public static MemoryAddress set_as_default_for_extension$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.set_as_default_for_extension$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void set_as_default_for_extension$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.set_as_default_for_extension$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static set_as_default_for_extension set_as_default_for_extension (MemorySegment segment, MemorySession session) {
        return set_as_default_for_extension.ofAddress(set_as_default_for_extension$get(segment), session);
    }
    static final FunctionDescriptor add_supports_type$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle add_supports_type$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.add_supports_type$FUNC
    );
    public interface add_supports_type {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(add_supports_type fi, MemorySession session) {
            return RuntimeHelper.upcallStub(add_supports_type.class, fi, _GAppInfoIface.add_supports_type$FUNC, session);
        }
        static add_supports_type ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GAppInfoIface.add_supports_type$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle add_supports_type$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("add_supports_type"));
    public static VarHandle add_supports_type$VH() {
        return _GAppInfoIface.add_supports_type$VH;
    }
    public static MemoryAddress add_supports_type$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.add_supports_type$VH.get(seg);
    }
    public static void add_supports_type$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.add_supports_type$VH.set(seg, x);
    }
    public static MemoryAddress add_supports_type$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.add_supports_type$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void add_supports_type$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.add_supports_type$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static add_supports_type add_supports_type (MemorySegment segment, MemorySession session) {
        return add_supports_type.ofAddress(add_supports_type$get(segment), session);
    }
    static final FunctionDescriptor can_remove_supports_type$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle can_remove_supports_type$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.can_remove_supports_type$FUNC
    );
    public interface can_remove_supports_type {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(can_remove_supports_type fi, MemorySession session) {
            return RuntimeHelper.upcallStub(can_remove_supports_type.class, fi, _GAppInfoIface.can_remove_supports_type$FUNC, session);
        }
        static can_remove_supports_type ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)_GAppInfoIface.can_remove_supports_type$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle can_remove_supports_type$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("can_remove_supports_type"));
    public static VarHandle can_remove_supports_type$VH() {
        return _GAppInfoIface.can_remove_supports_type$VH;
    }
    public static MemoryAddress can_remove_supports_type$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.can_remove_supports_type$VH.get(seg);
    }
    public static void can_remove_supports_type$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.can_remove_supports_type$VH.set(seg, x);
    }
    public static MemoryAddress can_remove_supports_type$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.can_remove_supports_type$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void can_remove_supports_type$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.can_remove_supports_type$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static can_remove_supports_type can_remove_supports_type (MemorySegment segment, MemorySession session) {
        return can_remove_supports_type.ofAddress(can_remove_supports_type$get(segment), session);
    }
    static final FunctionDescriptor remove_supports_type$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle remove_supports_type$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.remove_supports_type$FUNC
    );
    public interface remove_supports_type {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(remove_supports_type fi, MemorySession session) {
            return RuntimeHelper.upcallStub(remove_supports_type.class, fi, _GAppInfoIface.remove_supports_type$FUNC, session);
        }
        static remove_supports_type ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GAppInfoIface.remove_supports_type$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle remove_supports_type$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("remove_supports_type"));
    public static VarHandle remove_supports_type$VH() {
        return _GAppInfoIface.remove_supports_type$VH;
    }
    public static MemoryAddress remove_supports_type$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.remove_supports_type$VH.get(seg);
    }
    public static void remove_supports_type$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.remove_supports_type$VH.set(seg, x);
    }
    public static MemoryAddress remove_supports_type$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.remove_supports_type$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void remove_supports_type$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.remove_supports_type$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static remove_supports_type remove_supports_type (MemorySegment segment, MemorySession session) {
        return remove_supports_type.ofAddress(remove_supports_type$get(segment), session);
    }
    static final FunctionDescriptor can_delete$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle can_delete$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.can_delete$FUNC
    );
    public interface can_delete {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(can_delete fi, MemorySession session) {
            return RuntimeHelper.upcallStub(can_delete.class, fi, _GAppInfoIface.can_delete$FUNC, session);
        }
        static can_delete ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)_GAppInfoIface.can_delete$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle can_delete$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("can_delete"));
    public static VarHandle can_delete$VH() {
        return _GAppInfoIface.can_delete$VH;
    }
    public static MemoryAddress can_delete$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.can_delete$VH.get(seg);
    }
    public static void can_delete$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.can_delete$VH.set(seg, x);
    }
    public static MemoryAddress can_delete$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.can_delete$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void can_delete$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.can_delete$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static can_delete can_delete (MemorySegment segment, MemorySession session) {
        return can_delete.ofAddress(can_delete$get(segment), session);
    }
    static final FunctionDescriptor do_delete$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle do_delete$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.do_delete$FUNC
    );
    public interface do_delete {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(do_delete fi, MemorySession session) {
            return RuntimeHelper.upcallStub(do_delete.class, fi, _GAppInfoIface.do_delete$FUNC, session);
        }
        static do_delete ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)_GAppInfoIface.do_delete$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle do_delete$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("do_delete"));
    public static VarHandle do_delete$VH() {
        return _GAppInfoIface.do_delete$VH;
    }
    public static MemoryAddress do_delete$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.do_delete$VH.get(seg);
    }
    public static void do_delete$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.do_delete$VH.set(seg, x);
    }
    public static MemoryAddress do_delete$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.do_delete$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void do_delete$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.do_delete$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static do_delete do_delete (MemorySegment segment, MemorySession session) {
        return do_delete.ofAddress(do_delete$get(segment), session);
    }
    static final FunctionDescriptor get_commandline$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_commandline$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.get_commandline$FUNC
    );
    public interface get_commandline {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(get_commandline fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_commandline.class, fi, _GAppInfoIface.get_commandline$FUNC, session);
        }
        static get_commandline ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GAppInfoIface.get_commandline$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_commandline$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_commandline"));
    public static VarHandle get_commandline$VH() {
        return _GAppInfoIface.get_commandline$VH;
    }
    public static MemoryAddress get_commandline$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.get_commandline$VH.get(seg);
    }
    public static void get_commandline$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.get_commandline$VH.set(seg, x);
    }
    public static MemoryAddress get_commandline$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.get_commandline$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_commandline$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.get_commandline$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_commandline get_commandline (MemorySegment segment, MemorySession session) {
        return get_commandline.ofAddress(get_commandline$get(segment), session);
    }
    static final FunctionDescriptor get_display_name$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_display_name$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.get_display_name$FUNC
    );
    public interface get_display_name {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(get_display_name fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_display_name.class, fi, _GAppInfoIface.get_display_name$FUNC, session);
        }
        static get_display_name ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GAppInfoIface.get_display_name$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_display_name$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_display_name"));
    public static VarHandle get_display_name$VH() {
        return _GAppInfoIface.get_display_name$VH;
    }
    public static MemoryAddress get_display_name$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.get_display_name$VH.get(seg);
    }
    public static void get_display_name$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.get_display_name$VH.set(seg, x);
    }
    public static MemoryAddress get_display_name$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.get_display_name$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_display_name$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.get_display_name$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_display_name get_display_name (MemorySegment segment, MemorySession session) {
        return get_display_name.ofAddress(get_display_name$get(segment), session);
    }
    static final FunctionDescriptor set_as_last_used_for_type$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle set_as_last_used_for_type$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.set_as_last_used_for_type$FUNC
    );
    public interface set_as_last_used_for_type {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(set_as_last_used_for_type fi, MemorySession session) {
            return RuntimeHelper.upcallStub(set_as_last_used_for_type.class, fi, _GAppInfoIface.set_as_last_used_for_type$FUNC, session);
        }
        static set_as_last_used_for_type ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GAppInfoIface.set_as_last_used_for_type$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle set_as_last_used_for_type$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("set_as_last_used_for_type"));
    public static VarHandle set_as_last_used_for_type$VH() {
        return _GAppInfoIface.set_as_last_used_for_type$VH;
    }
    public static MemoryAddress set_as_last_used_for_type$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.set_as_last_used_for_type$VH.get(seg);
    }
    public static void set_as_last_used_for_type$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.set_as_last_used_for_type$VH.set(seg, x);
    }
    public static MemoryAddress set_as_last_used_for_type$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.set_as_last_used_for_type$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void set_as_last_used_for_type$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.set_as_last_used_for_type$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static set_as_last_used_for_type set_as_last_used_for_type (MemorySegment segment, MemorySession session) {
        return set_as_last_used_for_type.ofAddress(set_as_last_used_for_type$get(segment), session);
    }
    static final FunctionDescriptor get_supported_types$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_supported_types$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.get_supported_types$FUNC
    );
    public interface get_supported_types {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(get_supported_types fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_supported_types.class, fi, _GAppInfoIface.get_supported_types$FUNC, session);
        }
        static get_supported_types ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_GAppInfoIface.get_supported_types$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_supported_types$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_supported_types"));
    public static VarHandle get_supported_types$VH() {
        return _GAppInfoIface.get_supported_types$VH;
    }
    public static MemoryAddress get_supported_types$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.get_supported_types$VH.get(seg);
    }
    public static void get_supported_types$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.get_supported_types$VH.set(seg, x);
    }
    public static MemoryAddress get_supported_types$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.get_supported_types$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_supported_types$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.get_supported_types$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_supported_types get_supported_types (MemorySegment segment, MemorySession session) {
        return get_supported_types.ofAddress(get_supported_types$get(segment), session);
    }
    static final FunctionDescriptor launch_uris_async$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle launch_uris_async$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.launch_uris_async$FUNC
    );
    public interface launch_uris_async {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(launch_uris_async fi, MemorySession session) {
            return RuntimeHelper.upcallStub(launch_uris_async.class, fi, _GAppInfoIface.launch_uris_async$FUNC, session);
        }
        static launch_uris_async ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    _GAppInfoIface.launch_uris_async$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle launch_uris_async$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("launch_uris_async"));
    public static VarHandle launch_uris_async$VH() {
        return _GAppInfoIface.launch_uris_async$VH;
    }
    public static MemoryAddress launch_uris_async$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.launch_uris_async$VH.get(seg);
    }
    public static void launch_uris_async$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.launch_uris_async$VH.set(seg, x);
    }
    public static MemoryAddress launch_uris_async$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.launch_uris_async$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void launch_uris_async$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.launch_uris_async$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static launch_uris_async launch_uris_async (MemorySegment segment, MemorySession session) {
        return launch_uris_async.ofAddress(launch_uris_async$get(segment), session);
    }
    static final FunctionDescriptor launch_uris_finish$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle launch_uris_finish$MH = RuntimeHelper.downcallHandle(
        _GAppInfoIface.launch_uris_finish$FUNC
    );
    public interface launch_uris_finish {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(launch_uris_finish fi, MemorySession session) {
            return RuntimeHelper.upcallStub(launch_uris_finish.class, fi, _GAppInfoIface.launch_uris_finish$FUNC, session);
        }
        static launch_uris_finish ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)_GAppInfoIface.launch_uris_finish$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle launch_uris_finish$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("launch_uris_finish"));
    public static VarHandle launch_uris_finish$VH() {
        return _GAppInfoIface.launch_uris_finish$VH;
    }
    public static MemoryAddress launch_uris_finish$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.launch_uris_finish$VH.get(seg);
    }
    public static void launch_uris_finish$set( MemorySegment seg, MemoryAddress x) {
        _GAppInfoIface.launch_uris_finish$VH.set(seg, x);
    }
    public static MemoryAddress launch_uris_finish$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_GAppInfoIface.launch_uris_finish$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void launch_uris_finish$set(MemorySegment seg, long index, MemoryAddress x) {
        _GAppInfoIface.launch_uris_finish$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static launch_uris_finish launch_uris_finish (MemorySegment segment, MemorySession session) {
        return launch_uris_finish.ofAddress(launch_uris_finish$get(segment), session);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }
}


